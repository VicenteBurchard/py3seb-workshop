{"version":"1","records":[{"hierarchy":{"lvl1":"Radiation transfer in canopies"},"type":"lvl1","url":"/net-radiation","position":0},{"hierarchy":{"lvl1":"Radiation transfer in canopies"},"content":"","type":"content","url":"/net-radiation","position":1},{"hierarchy":{"lvl1":"Radiation transfer in canopies","lvl2":"Summary"},"type":"lvl2","url":"/net-radiation#summary","position":2},{"hierarchy":{"lvl1":"Radiation transfer in canopies","lvl2":"Summary"},"content":"This interactive Jupyter Notebook has the objective of evaluating the different relationships and basic processes related to the interception and absorption of irradiance.\n\nWe will make use of simulation models, particularly radiative transfer models at both leaf and canopy levels.\n\n","type":"content","url":"/net-radiation#summary","position":3},{"hierarchy":{"lvl1":"Radiation transfer in canopies","lvl2":"Instructions"},"type":"lvl2","url":"/net-radiation#instructions","position":4},{"hierarchy":{"lvl1":"Radiation transfer in canopies","lvl2":"Instructions"},"content":"Read carefully all the text and follow the instructions.\n\nOnce each section is read, run the jupyter code cell underneath (marked as In []) by clicking the icon Run, or pressing the keys SHIFT+ENTER of your keyboard. A graphical interface will then display, which allows you to interact with and perform the assigned tasks.\n\nTo start, please run the following cell to import all the packages required for this notebook. Once you run the cell below, an acknowledgement message, stating all libraries were correctly imported, should be printed on screen.\n\n%matplotlib inline\nfrom ipywidgets import interact, interactive, fixed\nfrom IPython.display import display\nfrom functions import radiation_and_available_energy as fn\nimport numpy as np\n\n","type":"content","url":"/net-radiation#instructions","position":5},{"hierarchy":{"lvl1":"Radiation transfer in canopies","lvl2":"The energy balance"},"type":"lvl2","url":"/net-radiation#the-energy-balance","position":6},{"hierarchy":{"lvl1":"Radiation transfer in canopies","lvl2":"The energy balance"},"content":"Evapotranspiration is basically an exchange of heat and water between the land surface and the atmosphere. Therefore, the estimation of the energy available at the land surface is one of the key factors affecting its retrieval.\n\n\n\nFigure 1:The Global energy balance model\n\nDepending on the surface water status, this available energy is utilized for evaporating water (ET or latent heat flux - \\lambda E in terms of energy fluxes) and/or for increasing the surface temperature (sensible heat flux - H).\\lambda E + H = R_n - G\n\nwhere G is the heat transmitted and stored into the ground, and R_n is the net radiation.\n\nThe net radiation (R_n) can be computed as:R_n = S^\\downarrow \\left(1 - \\alpha\\right) +  \\epsilon \\left(L^\\downarrow - \\sigma LST^4\\right)\n\nwhere S^\\downarrow and L^\\downarrow are the shortwave and longwave incoming irradiances, respectively, which can be obtained from meteorological stations, numerical weather models or meteorological satellites. \\alpha and \\epsilon are surface albedo and emissivity, respectively, LST is the Land Surface Temperature, and \\sigma\\approx5.67E-8 (W/m²K⁴) is the Stefan-Boltzmann constant. \\alpha, \\epsilon and LST can be estimated, more or less accurately, from Earth Observation (EO) data.\n\nConsidering the larger magnitude of shortwave radiance (S) compared to the longwave radiance (L), we will place more emphasis on the former in this tutorial/notebook. In particular, we will concentrate on the canopy and leaf properties that influence albedo and radiation partitioning between soil and canopy.\n\nOn the other hand, G is usually of much lower magnitude, usually considered negligible at daily or even longer scales. When working at shorter timescale, e.g. when estimating \\lambda E at the satellite overpass time, G is usually estimated as a fraction of surface net radiation (e.g. G \\approx 0.1 R_n for dense canopies), or as a fraction of net radiation of the soil below the canopy (G \\approx 0.3 R_{ns}).","type":"content","url":"/net-radiation#the-energy-balance","position":7},{"hierarchy":{"lvl1":"Radiation transfer in canopies","lvl2":"Beer-Lambert law"},"type":"lvl2","url":"/net-radiation#beer-lambert-law","position":8},{"hierarchy":{"lvl1":"Radiation transfer in canopies","lvl2":"Beer-Lambert law"},"content":"The Beer-Lambert law is a physical law that allows to describe and interpret most of the radiative processes of our interest. When an electromagnetic beam passes through a medium containing an absorber of radiation, this light is attenuated proportionally to the concentration of such absorber (\\kappa) and to the optical path length of the beam (\\ell):\\tau = e^{-\\kappa\\ell}\n\nIn the following interactive graph, you can see the effect of this law. Try modifying the values of the extinction coefficient, which increases with the concentration of the absorbing material in the medium.\n\nThe plot will display the fraction of light that is transmitted through the medium as the beam path becomes longer:\n\nw_lambert = interactive(fn.beer_lambert_law, kappa=fn.w_kappa, length=fixed(np.linspace(0, 10, 50)))\ndisplay(w_lambert)\n\nThis law permits, for instance, to explain the attenuation of solar radiation from the stratosphere to the Earth’s surface. The air is composed of gases and particles that absorb radiation (most of them at certain wavelengths such as the ozone or the oxygen). The higher the sun is in the sky, the shorter the path length across the atmosphere, and, thus, a greater amount of solar irradiance reaches the land surface.\n\n\n\nFigure 2:The solar optical path length in a sphere (left) and its planar simplification (right)","type":"content","url":"/net-radiation#beer-lambert-law","position":9},{"hierarchy":{"lvl1":"Radiation transfer in canopies","lvl3":"Application to the fraction of intercepted radiation","lvl2":"Beer-Lambert law"},"type":"lvl3","url":"/net-radiation#application-to-the-fraction-of-intercepted-radiation","position":10},{"hierarchy":{"lvl1":"Radiation transfer in canopies","lvl3":"Application to the fraction of intercepted radiation","lvl2":"Beer-Lambert law"},"content":"Beer-Lambert law also allows the analysis or estimation of the radiation that is intercepted by the foliage in a canopy, as well as the radiation transmitted towards the ground.\n\nAssuming that a canopy is primarily composed of leaves, and that these leaves intercept and absorb radiation (mostly photosynthetically active radiation, PAR), we can evaluate how much radiation is intercepted by the canopy according to the foliage density. The latter is usually defined as the Leaf Area Index (LAI): half of the total leaf surface per unit ground. The larger the LAI, the more likely that the sun beams will be intercepted by one or more leaves, and, thus less likely for solar beams to reach the ground.\n\nThe solar elevation angle (\\beta in the previous graph), or its complementary the solar zenith angle (SZA), also plays a relevant role. The lower the sun is above the horizon, the longer the path of the sun beams will be when passing through the canopy, and thus the larger the light attenuation.\n\nSince leaves are solid elements with a finite size (as opposed to the gases in the atmosphere), their orientation with respect to the nadir also plays a relevant role. Therefore, the Beer-Lambert law must be adapted to account for this effect. In the next graph, you will be able to experiment with this phenomenon. Try changing both the amount of leaves in terms of LAI and the dominant zenith orientation of leaves, i.e. from canopies with predominantly vertical (LIDF\\approx90º) leaves to predominantly horizontal (LIDF\\approx0º) leaves.\n\nw_fipar = interactive(fn.plot_fipar, lai=fn.w_lai, leaf_angle=fn.w_leaf_angle)\ndisplay(w_fipar)\n\nWatch how the largest fraction of intercepted radiation (or the largest light attenuation) always occurs at higher solar zenith angles (when the path length of the solar beams is larger), but that the attenuation rate depends mostly on the amount of leaves (higher LAI) and their dominant orientation.\n\nLAI depends mainly on the plant development stage and plant growth, while the leaf orientation is more specific for the different species or plant functional types.\n\nAs a rule of thumb, we could expect that plants with predominantly vertical (i.e. erectophylle) leaves are usually adapted to climates with high irradiance levels, with the aim of avoiding large exposure and interception around noon, when irradiance is maximum. On the other hand, plants with predominantly horizontal leaves tend to thrive in more shaded conditions or with low irradiance levels, in order to maximize the interception of solar radiation along the daytime. Between these two extremes, most of the plants show an angular distribution more or less random. For those cases, the calculation of intercepted radiation can be simplified as:fIPAR = 1 - \\exp \\left(\\frac{-0.5 LAI}{\\cos\\theta_s}\\right)\n\nwhere \\theta_s is the sun zenith angle.\n\nSee Also\n\nIf you want to know more details on these calculations you can check the \n\npyTSEB GitHub source code.","type":"content","url":"/net-radiation#application-to-the-fraction-of-intercepted-radiation","position":11},{"hierarchy":{"lvl1":"Radiation transfer in canopies","lvl2":"The albedo"},"type":"lvl2","url":"/net-radiation#the-albedo","position":12},{"hierarchy":{"lvl1":"Radiation transfer in canopies","lvl2":"The albedo"},"content":"As we have previously mentioned, the albedo (\\alpha) is the key variable that determines the amount of intercepted light that is absorbed by the surface. \\alpha is defined as the proportion of incident shortwave radiation that is reflected by the surface. The shortwave net radiation (S_n) is therefore the balance between the incident shortwave irradiance (S^\\downarrow) and the reflected shortwave radiance (S^\\uparrow = \\alpha S^\\downarrow)\n\nThe spectral properties of the surface are key in determining the albedo. For instance, fresh snow shows large values (\\alpha\\approx 0.9) and, thus, reflects most of the solar irradiance, while oceans have much lower values (\\alpha\\approx0.05), absorbing a large amount of solar irradiance.\n\nLeaves, due to their photosynthetic activity, absorb a large proportion of light due to the presence of chlorophylls, as well as other leaf pigments. For that reason, leaves yield relative low albedo values (\\approx0.15). On the other hand, soils can have a large range of albedo values, depending on their mineral composition, texture and topsoil moisture. Therefore, the albedo of a vegetated surface will depend not only on leaf chlorophyll concentration but also on canopy density and, in a lesser degree, on the soil albedo in situations of sparse vegetation or initial growth stages.","type":"content","url":"/net-radiation#the-albedo","position":13},{"hierarchy":{"lvl1":"Radiation transfer in canopies","lvl3":"Vegetation anisotropy","lvl2":"The albedo"},"type":"lvl3","url":"/net-radiation#vegetation-anisotropy","position":14},{"hierarchy":{"lvl1":"Radiation transfer in canopies","lvl3":"Vegetation anisotropy","lvl2":"The albedo"},"content":"Most of the Earth’s surface show certain anisotropic behaviour when reflecting radiation i.e. it scatters different amounts of radiation depending on the scattering direction. The most extreme cases would be specular surfaces (such as mirrors, still water bodies or ice), which scatter most the irradiance in the opposite direction of the incidence angle. The opposite case would be lambertian surfaces, where apparent brightness/scattering is the same regardless the direction.\n\n\n\nFigure 3:The Lambertian (thin arrow lines) and specular (bold arrow line) scattering\n\nNote\n\nUnpolished wood would be closer to a lambertian surface, while polished and varnished wood would behave more as a specular/non-lambertian surface.\n\nVegetation, as it is mainly composed by an array of leaves, is also affected by this anisotropic behaviour. Therefore, plants will reflect radiation differently depending on the illumination geometry (i.e. the solar  position) and the scattering direction (i.e. the sensor position), possibly changing their albedo.\n\nYou can visualize this effect in the following plot. It depicts two polar graphs, one for the photosynthetically active radiation (PAR, 400-700\\mum) and a second one for the shortwave radiation (SW, 400-2500\\mum). These plots represent the reflectance factors simulated for a homogeneous canopy, using the radiative transfer models PROSPECT-D \n\nFéret et al., 2017 and 4SAIL \n\nVerhoef et al., 2007.\n\nThe concentric rings represent the range of zenith angles (zenith=0º at the plot origin, and 90º at the outermost ring). The radii of the plots show the azimuth angles (0º bearing north, 90º bearing east, 180º bearing south, and 270º bearing west). The solar position is depicted in the graph with a star. By default the sun is placed at solar noon in Northern latitudes (180º azimuth), at a solar zenith angle of 37º. The plots also print the integrated value of the reflectance factors , which is actually the albedo.\n\nSee Also\n\nIf you want to know more details on these calculations you can check \n\npypro4sail GithHub source code\n\nw_bidirectional = interactive(fn.bidirectional_reflectance,\n                              cab=fn.w_cab, cw=fn.w_cw, lai=fn.w_lai, leaf_angle=fn.w_leaf_angle, \n                              sza=fn.w_sza, saa=fn.w_saa, skyl=fn.w_skyl, soil_type=fn.w_soil)\ndisplay(w_bidirectional)                             \n\nModify the chlorophyll content - Cab. How do reflectance factors and albedo change in the PAR region (400-700\\mum) and in the solar spectrum (400-2500\\mum)?\n\nLikewise, modify the leaf water content- Cw. How do reflectance factors and albedo change in the PAR region (400-700\\mum) and in the solar spectrum (400-2500\\mum)?\n\nModify the solar position - SZA and SAA. On one side, you will see a peak of reflectance around the solar position (the star in the plot). This is the so-called hotspot, or the area most illuminated in the canopy. By contrast, the lowest values are on the opposite side, since leaves in this area are more occluded by the rest of the canopy. The albedo values also vary with the solar position, i.e. albedo changes along the day.\n\nThis variation of albedo with solar  position is stronger with lower values of diffuse radiation. Increase the ratio of diffuse radiation skyl, which would simulate cloudy days. On totally overcast days (skyl=1), you will notice that the solar position is no longer relevant for the albedo or reflectance factors.","type":"content","url":"/net-radiation#vegetation-anisotropy","position":15},{"hierarchy":{"lvl1":"Radiation transfer in canopies","lvl2":"Net shortwave radiation"},"type":"lvl2","url":"/net-radiation#net-shortwave-radiation","position":16},{"hierarchy":{"lvl1":"Radiation transfer in canopies","lvl2":"Net shortwave radiation"},"content":"Previously, we have seen that LAI, leaf angle distribution and chlorophyll concentrations are the probably the most relevant variables that determine the absorption of shortwave irradiance within a crop/vegetation layer.\n\nIn the next plot, we see the daily trend of net shortwave radiation for a horizontally homogeneous herbaceous crop (such a wheat field). These simulations assume that the cloudiness remains constant along the day and, thus, shortwave irradiance displays a sinusoidal curve: should cloudiness change along the day, the shortwave irradiance would display a series of valleys and peaks, according to whether the sun is occluded by clouds or not.\n\nImportant\n\nOn the other hand, these simulations assume a constant ratio of diffuse irradiance along the day (fixed by the value set by Skyl). This is unrealistic in most cases, since around sunrise and sundown diffuse radiation tends to be larger, even under clear sky conditions. But for simplicity in these simulations, we made this assumption.\n\nThe plot depicts the net radiation at the land surface (S_n, black line) as well as the net radiation partitioning between crop (S_{n,C}, green line) and ground (S_{n,S}, yellow line). The secondary axis displays the albedo in blue line.S_{n,C}+S_{n,S}=S_n\\\\\n\\alpha = 1 - S_n/S\\downarrow\n\nw_sn = interactive(fn.plot_net_solar_radiation,\n                   lai=fn.w_lai, leaf_angle=fn.w_leaf_angle, h_c=fixed(1), f_c=fixed(1),\n                   sdn_day=fn.w_sdn,\n                   row_distance=fixed(1), row_direction=fixed(1), skyl=fn.w_skyl, \n                   fvis=fixed(0.55), lat=fn.w_lat, cab=fn.w_cab, cw=fn.w_cw, soil_type=fn.w_soil)\ndisplay(w_sn)\n\nImportant\n\nAll parameters for all the plots used in this notebook are synchronized: any parameter change in one of the interactive plots is as well changed for the other plots, with all the graphs updated accordingly. This allows a quick intercomparison between graphs and simulations.\n\nWhile keeping the chlorophyll and water content constant, observe how net radiation barely changes with variations of LAI. However, the partitioning of net radiation between the canopy and soil does drastically change with LAI. This has an important implications since LAI is key for the radiation partitioning and, thus, for the evaporative/transpirative capacity of soil and vegetation, as well as for photosynthesis.\n\nNow keep relatively low values of LAI (<1.5) and inspect the effect of leaf angular distribution. More vertical leaves (LIDF\\rightarrow 90^{\\circ}) would provoke a reduction of intercepted, and thus absorbed, radiation near solar noon. Watch now that if diffuse radiation increases (Skyl\\rightarrow1), this effect is no longer evident. In this case, most of the radiation is coming equally from any direction of the hemisphere, making leaf inclination less relevant.\n\nChange the soil type and see how soil albedo affects net radiation, in particular at lower values of LAI when soil is more exposed to solar irradiance.\n\nSee Also\n\nIf you want to know more details about these calculations you can check the \n\npyTSEB Github source code.\n\n","type":"content","url":"/net-radiation#net-shortwave-radiation","position":17},{"hierarchy":{"lvl1":"Radiation transfer in canopies","lvl2":"Net longwave radiation"},"type":"lvl2","url":"/net-radiation#net-longwave-radiation","position":18},{"hierarchy":{"lvl1":"Radiation transfer in canopies","lvl2":"Net longwave radiation"},"content":"Net longwave radiation (L_n) corresponds to the thermal emission of radiation from the land surface and the absorption  of thermal irradiance from the atmosphere. L_n depends therefore on the surface’s temperature and its emissivity, as well as on the atmospheric thermal emission (L\\downarrow), which at the same time depends on the atmospheric temperature and emissivity.\n\nL_n = \\left(1 - \\epsilon_{surf}\\right) L\\downarrow - \\epsilon_{surf} \\sigma T_{surf}^4\n\nIn the next interactive plot, we will see how net longwave radiation changes as a function of atmospheric conditions (air temperature and humidity) and the surface’s temperature and emissivity. Since surface temperature also depends on atmospheric conditions, we simulated various ranges of surface temperatures in the x-axis, from fully watered crops in which the surface temperature is closer to the air temperature, to stressed crops and bare/sparse areas, in which surface temperature is significantly hotter than the air.\n\nw_ln = interactive(fn.plot_longwave_radiation, t_air=fn.w_tair, hr=fn.w_hr, delta_t=fixed(np.linspace(-1, 20, 50)),\n                   emiss=fn.w_emiss)\ndisplay(w_ln)\n\nObserve that the net longwave radiation yield values at a lower magnitude than the net shortwave radiation ( especially for clear skies around solar noon time). Only in cases with high temperatures and humidity net radiation exceeds 400 W/m².\n\nFinally, the surface emissivity, the values of which usually range from 0.95 in arid areas with scarce vegetation to 0.99 in dense vegetation surfaces, has a lesser effect in the calculation of net longwave radiation. Therefore, for computing of net radiation its retrieval does not require very high accuracy.\n\n","type":"content","url":"/net-radiation#net-longwave-radiation","position":19},{"hierarchy":{"lvl1":"Radiation transfer in canopies","lvl2":"Conclusions"},"type":"lvl2","url":"/net-radiation#conclusions","position":20},{"hierarchy":{"lvl1":"Radiation transfer in canopies","lvl2":"Conclusions"},"content":"In this exercise we have seen that net shortwave radiation depends mainly on:\n\nShortwave irradiance, which can be obtained from meteorological stations or from numerical weather models (e.g. \n\nCopernicus Climate Data Store).\n\nSurface albedo\n\nFurthermore, the surface albedo mainly depends on:\n\nLeaf and soil spectral properties, mainly leaf chlorophyll content as the main pigment absorber in the PAR region.\n\nCanopy structural characteristics, mainly LAI but also leaf angle distribution.\n\nIn addition, for row crops, the row architecture may be crucial in characterizing the radiation partitioning between ground and canopy.\n\nThe net longwave radiation has a lower contribution to the global net radiation (R_n), and its estimation is usually simpler, requiring:\n\nIncident longwave irradiance, which can be obtained from meteorological stations or from numerical weather models (e.g. \n\nCopernicus Climate Data Store).\n\nSurface emissivity and temperature, both of which can be obtained from thermal infrared Earth Observation data.\n\nThese analyses will allow you to better understand the radiative part of the energy balance. In addition, these simulations will permit evaluating the cost/benefit of using simpler or more sophisticated models for estimating net radiation and its partitioning between soil and canopy in structurally complex canopies.\n\nIn the next exercise, you will work on the other main factor of the energy balance that can be estimated with thermal infrared Earth Observation, the \n\nsensible heat flux.\n\nNote\n\nPlease feel free comment any thoughts.","type":"content","url":"/net-radiation#conclusions","position":21},{"hierarchy":{"lvl1":"Turbulent exchange of heat and water vapour"},"type":"lvl1","url":"/turbulence-and-sensible-heat-flux","position":0},{"hierarchy":{"lvl1":"Turbulent exchange of heat and water vapour"},"content":"","type":"content","url":"/turbulence-and-sensible-heat-flux","position":1},{"hierarchy":{"lvl1":"Turbulent exchange of heat and water vapour","lvl2":"Summary"},"type":"lvl2","url":"/turbulence-and-sensible-heat-flux#summary","position":2},{"hierarchy":{"lvl1":"Turbulent exchange of heat and water vapour","lvl2":"Summary"},"content":"This interactive notebook has the objective of demonstrating the relationships between canopy structure, turbulent transport of heat and water and surface temperature.\n\nFor this purpose, we will use simulations based on energy combination models, both the “big  leaf” \n\nPenman-Monteith model as well the dual source \n\nShuttleworth-Wallace model.\n\n","type":"content","url":"/turbulence-and-sensible-heat-flux#summary","position":3},{"hierarchy":{"lvl1":"Turbulent exchange of heat and water vapour","lvl2":"Instructions"},"type":"lvl2","url":"/turbulence-and-sensible-heat-flux#instructions","position":4},{"hierarchy":{"lvl1":"Turbulent exchange of heat and water vapour","lvl2":"Instructions"},"content":"Read carefully all the text and follow the instructions.\n\nOnce each section is read, run the jupyter code cell underneath (marked as In []) by clicking the icon Run, or pressing the keys SHIFT+ENTER of your keyboard. A graphical interface will then display, which allows you to interact with and perform the assigned tasks.\n\nTo start, please run the following cell to import all the packages required for this notebook. Once you run the cell below, an acknowledgement message, stating all libraries were correctly imported, should be printed on screen.\n\nfrom ipywidgets import interactive, fixed\nfrom IPython.display import display\nimport functions.tseb_and_resistances as fn\n\n","type":"content","url":"/turbulence-and-sensible-heat-flux#instructions","position":5},{"hierarchy":{"lvl1":"Turbulent exchange of heat and water vapour","lvl2":"Basic equations"},"type":"lvl2","url":"/turbulence-and-sensible-heat-flux#basic-equations","position":6},{"hierarchy":{"lvl1":"Turbulent exchange of heat and water vapour","lvl2":"Basic equations"},"content":"As a reminder, the estimation of evapotranspiration (ET), or latent heat flux (\\lambda E) in terms of energy, can be obtained from the energy balance equation:\\lambda E \\approx R_n - G - H\n\nIn the previous exercise, we have already seen the theory and processes related to net radiation (R_n) and soil heat flux (G). Now, we will focus on the sensible heat flux (H) to finally get \\lambda E or ET.\n\nThe effective transport of sensible heat can be computed as:H = \\rho_{air} C_p \\frac{T_0 - T_a}{r_a}\n\n\\rho_{air} and \n\nC_p are the density of air and its specific heat respectively, and they can be assumed to be practically constant.\n\nT_0 (K) is the aerodynamic temperature.\n\nAttention\n\nDo not confuse this temperature with the radiometric surface temperature that is estimated with thermal infrared sensors\n\nT_a (K) is the air temperature measured at a height above ground z_T, and significantly above the canopy height (h_c)\n\nr_a is the aerodynamic resistance to heat transport (s/m), a reciprocal of which is the aerodynamic conductance.\n\nAttention\n\nDo not confuse this aerodynamic conductance with the leaf stomatal conductance\n\nThis fundamental equation can be interpreted in a way that the heat exchange between the land surface and the atmosphere (H) is driven by a gradient of temperatures between the surface and the nearest layers of air above the canopy. This transport or exchange of heat is modulated by the aerodynamic resistance, which includes a series of complex mechanical and convective processes that enhance or impede the transport of heat between the surface and the air:r_{a}=\\frac{\\left[\\ln\\left(\\frac{z_{T}-d}{z_{0H}}\\right)+\\Psi_{H}\\right] \\left[\\ln\\left(\\frac{z_{U}-d}{z_{0M}}\\right)+\\Psi'_{M}\\right]}{k^2\\,U}\n\nU is the wind speed (m/s) measured at a height above ground z_U, and significantly above the canopy height (h_c).\n\nz_{T} is the height (m) at which air temperature is measured or modelled.\n\nz_{U} is the height (m) at which wind speed is measured or modelled.\n\nd and z_{0M} are the zero-plane displacement height and surface roughness length for momentum transport, respectively. Usually these two variables can be estimated using a simplified formula based on canopy/obstacle height (h_c)z_{0M} &= 0.125 h_c\\\\\nd_{0} &= 2/3 h_c\n\nz_{0H} is the roughness length for heat transport. Likewise, its estimation is usually computed as a fraction of  z_{0M} (e.g. z_{0H} = 0.1 z_{0M}\n\n for dense vegetation)\n\nk=0.41 is von Kàrman constant.\n\n\\Psi'_{H} and \\Psi'_{M} are semi-empirical functions that modulate the aerodynamic resistance and the vertical wind attenuation as function of atmospheric stability.\n\nSee Also\n\nIf you want to know more details about their calculation, you can check the \n\npyTSEB GitGub source code for \\Psi'_{H}  and \n\nfor \\Psi'_{M}.\n\nFrom the equation above we can arithmetically deduce that the aerodynamic resistance to heat and vapour transport decreases with wind speed and with the surface aerodynamic roughness.\n\nIn the following tasks, we are going to disentangle all those processes step by step, allowing us to better understand and estimate r_a.","type":"content","url":"/turbulence-and-sensible-heat-flux#basic-equations","position":7},{"hierarchy":{"lvl1":"Turbulent exchange of heat and water vapour","lvl2":"The wind profile"},"type":"lvl2","url":"/turbulence-and-sensible-heat-flux#the-wind-profile","position":8},{"hierarchy":{"lvl1":"Turbulent exchange of heat and water vapour","lvl2":"The wind profile"},"content":"The wind speed profile with respect to the height above the ground can be estimated according to a logarithmic function. Ignoring in this first step the effects of convective turbulence, and thus considering a neutral atmospheric stability:u\\left(z\\right) =\\frac{u_*}{k}\\left[\\log\\left(\\frac{z - d}{z_{0M}}\\right)\\right]\n\nNote\n\nThis logarithmic wind attenuation is closely related to the aerodynamic resistance.\n\nSee Also\n\nYou can also check the \n\npyTSEB GitHub source code.\n\nThe wind attenuation will be stronger for a larger surface roughness, expressed by the variables z_{0M} and d_{0}.\n\nu_{*} is the friction velocity. Likewise, simplifying and neglecting the effects of atmospheric stability, u_{*} is computed as:u_* = \\frac{k\\,U} {\\log\\left(\\frac{z_u - d_0}{z_{0M}}\\right))}\n\nSee Also\n\nYou can also check the \n\npyTSEB GitHub source code.\n\nTherefore, based on wind speed measurement at a given height, we could extrapolate the wind profile to estimate the wind speed right above the canopy (h_c):u_C =\\frac{u_*}{k}\\left[\\log\\left(\\frac{h_c - d}{z_{0M}}\\right)\\right]","type":"content","url":"/turbulence-and-sensible-heat-flux#the-wind-profile","position":9},{"hierarchy":{"lvl1":"Turbulent exchange of heat and water vapour","lvl3":"The wind profile within the canopy","lvl2":"The wind profile"},"type":"lvl3","url":"/turbulence-and-sensible-heat-flux#the-wind-profile-within-the-canopy","position":10},{"hierarchy":{"lvl1":"Turbulent exchange of heat and water vapour","lvl3":"The wind profile within the canopy","lvl2":"The wind profile"},"content":"As the wind passes through the canopy, it is mainly attenuated by the presence of foliage. This attenuation within the canopy and towards the ground can have implications on the heat and vapour exchange between the canopy and the ground.\n\nUsually this attenuation is formulated assuming that the canopy is horizontally and vertically homogeneous. However most canopies, and in particular woody vegetation, show a foliar density that varies with height: plants usually have a stem from which branches diverge, starting at a certain height above ground, resulting in canopies with a more or less irregular shape.\n\nIn the following interactive plot, we are going to simulate the wind attenuation above and below the canopy, and how this profile diverges according to the canopy structure. We are going to compare a profile for both a vertically heterogeneous (based on \n\nMassman et al., 2017 mode) and homogeneous canopy (based on \n\nGoudriaan, 1977 model). In addition, we are going to see the standard wind profile as estimated in the reference ET method proposed by FAO. For this task, we are keeping a constant wind speed (U=5 m/s) measured 10m above ground (z_U=10 m), and assuming a neutral atmospheric stability.\n\nSee Also\n\nYou can check the GitHub source code for both the \n\nGoudriaan and for the \n\nMassman models\n\nIn order to characterize our canopy, we are going to need:\n\nLeaf Area Index (LAI) and canopy height (h_c), these two parameters are common for the homogeneous and heterogeneous canopy.\n\nThe height above ground in which the foliage begins (h_{bottom}), expressed as the ratio to the canopy height\n\nNote\n\nBy default this value is set at 0.5, meaning that the foliage starts at a height of 0.5 h_c m.\n\nThe height at which the maximum foliage density is located (h_{max}), expressed as a ratio of the canopy length (i.e the difference between h_c and h_{bottom}).\n\nIn the graph below, the left-panel plot shows the relative foliage density of the simulated canopy.\n\nThe right-panel plot shows the wind speed attenuation from 10m to the ground (0m) for both the vertical heterogeneous (solid blue line) and homogeneous (dashed blue line) cases. A blue star indicates the wind speed right above the canopy, and the dashed black line shows the standard profile for the reference ET crop in FAO method (a homogeneous grass layer with h_c=0.12 m and LAI\\approx3).\n\nw_wind = interactive(fn.wind_profile_heterogeneous, lai=fn.w_lai, zol=fixed(0.), h_c=fn.w_hc, \n                     hb_ratio=fn.w_hb_ratio, h_c_max=fn.w_h_c_max)\ndisplay(w_wind)\n\nSee how different the wind profile can be compared to the FAO reference crop profile. This is particularly evident when h_c is significantly larger than 0.12 m. In addition, with higher canopies, there will be clearer differences between a profile for a vertically homogenous crop compared to a heterogenous one.\n\nAs a rule of thumb, the stronger the attenuation is, the more turbulent the exchange of heat and vapour will be. This turbulence will produce more eddies and a more efficient transport of heat and vapour between the soil, the plant and the atmosphere, since eddies move the parcels of (warm and humid) air in contact with the land surface towards the atmosphere.\n\nSee Also\n\n\n\nThis is a YouTube video showing a simulation of eddies while surface roughness in increased. In this case it corresponds to an airfoil\n\nSee also that with higher leaf density (expressed in terms of LAI), the wind attenuation within the canopy will be stronger. This results in distinct heat and water exchange between the canopy and the ground.\n\nFinally, see that the strongest attenuation within the canopy occurs around the height of maximum foliage density. This is due to the fact that the wind is encountering a larger amount of obstacles (leaves) and, thus, looses kinetic energy and, hence, speed. On the contrary, in areas closer to the ground, where the foliage density is minimal, the wind is less attenuated.","type":"content","url":"/turbulence-and-sensible-heat-flux#the-wind-profile-within-the-canopy","position":11},{"hierarchy":{"lvl1":"Turbulent exchange of heat and water vapour","lvl3":"Effect on the aerodynamic resistance","lvl2":"The wind profile"},"type":"lvl3","url":"/turbulence-and-sensible-heat-flux#effect-on-the-aerodynamic-resistance","position":12},{"hierarchy":{"lvl1":"Turbulent exchange of heat and water vapour","lvl3":"Effect on the aerodynamic resistance","lvl2":"The wind profile"},"content":"In this task, you will explore how the aerodynamic resistance varies with surface roughness (characterized by canopy height), wind speed and atmospheric stability.","type":"content","url":"/turbulence-and-sensible-heat-flux#effect-on-the-aerodynamic-resistance","position":13},{"hierarchy":{"lvl1":"Turbulent exchange of heat and water vapour","lvl4":"The atmospheric stability and convective turbulence","lvl3":"Effect on the aerodynamic resistance","lvl2":"The wind profile"},"type":"lvl4","url":"/turbulence-and-sensible-heat-flux#the-atmospheric-stability-and-convective-turbulence","position":14},{"hierarchy":{"lvl1":"Turbulent exchange of heat and water vapour","lvl4":"The atmospheric stability and convective turbulence","lvl3":"Effect on the aerodynamic resistance","lvl2":"The wind profile"},"content":"So far, we saw that arithmetically the aerodynamic resistance to heat and vapour transport decreases with wind speed and roughness. In other words, the exchange of heat and vapour between the surface and the atmosphere becomes more efficient with stronger winds and rougher surfaces.\n\nNow, we are going to evaluate that with more unstable atmospheres, due to convection, the turbulence is enhanced and, thus, the heat exchange will be more efficient.\n\nThe atmospheric stability can be expressed in relative terms as a ratio between aerodynamic roughness length (z_{0m}) and the Monin-Obukhov length (\\xi=z_{0m}/L), the latter of which also depends on the sensible heat flux (H).\n\nSee Also\n\nYou can also check the \n\npyTSEB GigHub source code for the Monin-Obukhov length\n\nThe more negative this \\xi coefficient is, the more unstable the atmosphere is and, thus, the more efficient the transport of heat and vapour would be due to the convection of warm air upwards the cooler atmosphere.\n\nNote\n\nAs a reminder, the density of warm air is less than that of cool air, resulting in a vertical (and turbulent) transport of air upwards.\n\n\nSee a video of this phenomenon\n\nImportant\n\nAt daytime, the land surface is absorbing heat (mainly due to sun irradiance) and, therefore, unstable conditions usually occur (\\xi < 0) during the daytime. By contrast, at nighttime, the land surface can be cooler than the air and, thus, thermal inversion phenomena and atmospheric stability can occur (\\xi > 0).\n\nThe next interactive plot will let you evaluate the joint effect of atmospheric stability, wind speed and canopy height/roughness on the characterization of aerodynamic resistance.\n\nw_ra = interactive(fn.plot_aerodynamic_resistance, zol=fn.w_zol, h_c=fn.w_hc)\ndisplay(w_ra)\n\nNote\n\nAll parameters for all the plots used in this notebook are synchronized: any parameter change in one of the interactive plots is as well changed for the other plots, with all the graphs updated accordingly. This allows a quick intercomparison between graphs and simulations.\n\nSee how the aerodynamic resistance reduces exponentially with wind speed, but also with surface roughness/canopy height. This issue can have crucial implications when interpreting the gradient of temperature between the surface and the air.\n\nWarning\n\nThe same temperature gradient can indicate different levels, or lack thereof, of water stress, depending on the surface roughness and the actual meteorological conditions.\n\nNow change the stability coefficient and see how r_a changes. The aerodynamic resistance is reduced with more negative xi values for a given wind speed and surface roughness. By contrast, with stable conditions (xi > 0) the vertical transport of heat and vapour is reduced (larger values of r_a).","type":"content","url":"/turbulence-and-sensible-heat-flux#the-atmospheric-stability-and-convective-turbulence","position":15},{"hierarchy":{"lvl1":"Turbulent exchange of heat and water vapour","lvl2":"The evapotranspiration and the sensible heat flux"},"type":"lvl2","url":"/turbulence-and-sensible-heat-flux#the-evapotranspiration-and-the-sensible-heat-flux","position":16},{"hierarchy":{"lvl1":"Turbulent exchange of heat and water vapour","lvl2":"The evapotranspiration and the sensible heat flux"},"content":"In this second part of the exercise, we are going to integrate everything we have learnt so far to evaluate their joint effect on evapotranspiration and the land surface temperature. As mentioned before, we will use two popular energy combination models to perform our simulations.\n\nThe main advantage of \n\nPenman-Monteith model is its relative simplicity (this is the model used to estimate FAO’s reference ET), while its main disadvantage is that it is not fully able to partition fluxes between soil and canopy (e.g. separation of soil evaporation and canopy transpiration). This issue has important implications when modelling ET over sparse vegetation or row crops.\n\n\n\nFigure 2:Resistances layout in the \n\nPenman-Monteith model\n\nNote\n\nThe most well known application of Penman-Monteith model is the calculation of reference ET, e.g. \n\nFAO 56 or \n\nASCE, which estimates the evapotranspiration for a well watered crop used as reference. This reference crop for FAO 56 is defined as a perfectly homogeneous grass layer clipped at 12cm height.\n\nOn the other hand, the \n\nShuttleworth-Wallace model is more adapted to sparse vegetation conditions and is able to partition fluxes between soil and canopy, allowing thus the separation between soil evaporation and canopy transpiration. However, this model is more complex than Penman-Monteith and, thus, requires additional inputs.\n\n\n\nFigure 2:Resistances layout in the \n\nShuttleworth-Wallace model\n\nAdditional variables which are required by the Shuttleworth-Wallace model include the soil resistance of vapour transport (R_{ss}), which is related to the topsoil moisture content.\n\nTip\n\nR_{ss} values closer to 0 would indicate topsoil saturated or even flooded with water, whereas larger values will indicate a drier soil surface.","type":"content","url":"/turbulence-and-sensible-heat-flux#the-evapotranspiration-and-the-sensible-heat-flux","position":17},{"hierarchy":{"lvl1":"Turbulent exchange of heat and water vapour","lvl3":"The effect of stomatal conductance","lvl2":"The evapotranspiration and the sensible heat flux"},"type":"lvl3","url":"/turbulence-and-sensible-heat-flux#the-effect-of-stomatal-conductance","position":18},{"hierarchy":{"lvl1":"Turbulent exchange of heat and water vapour","lvl3":"The effect of stomatal conductance","lvl2":"The evapotranspiration and the sensible heat flux"},"content":"The leaf stomatal conductance or its reciprocal the leaf stomatal resistance (g_s = 1 / r_{st}) in an indicator of crop water stress. g_s usually show values around a 0.4-0.5 mmol m^{-2} s^{-1} when the crop is well watered.\n\nNote\n\nAccording to FAO guidelines, the stomatal resistance of the reference well-watered crop is 100 s/m, which is equivalent to a stomatal conductance of 0.415 mmol m^{-2} s^{-1} (at standard atmospheric conditions of 25ºC at sea level).\n\nWhen a soil water deficit at the root-zone occurs, the typical physiological response of plants is to close partially or totally their stomata, with the aim of avoiding significant losses of water. This closure has the consequence of a lower CO_2 assimilation through the stomata and, therefore, a reduction in the plants’ productivity. This physiological stomatal closure is mathematically reflected in a decrease (increase) of stomata conductance (resistance).","type":"content","url":"/turbulence-and-sensible-heat-flux#the-effect-of-stomatal-conductance","position":19},{"hierarchy":{"lvl1":"Turbulent exchange of heat and water vapour","lvl3":"Flux interaction between ground and the canopy","lvl2":"The evapotranspiration and the sensible heat flux"},"type":"lvl3","url":"/turbulence-and-sensible-heat-flux#flux-interaction-between-ground-and-the-canopy","position":20},{"hierarchy":{"lvl1":"Turbulent exchange of heat and water vapour","lvl3":"Flux interaction between ground and the canopy","lvl2":"The evapotranspiration and the sensible heat flux"},"content":"Any exchange of heat and vapour between the ground, vegetation and the atmosphere is produced under a turbulent transport. Therefore, if the ground surface is dry and receives enough radiation it will heat up and, thus, will enhance the transport of dry and hot air towards the canopy. This would enhance the evaporative demand of the canopy (warming and drying the air around the leaves). Inversely, a dense and well irrigated canopy can provide cool and moist air towards the ground environment, decreasing its evaporative demand.\n\nThe following interactive plot will run simulations of \n\nPenman-Monteith and \n\nShuttleworth-Wallace models for a range of LAIs, given the following standard meteorological forcing:\n\nSolar irradiance of 300 W m^{-2}.\n\nAir temperature of 25ºC (298K).\n\n50% relative humidity, which is equivalent to a vapour pressure deficit of VPD\\approx 15mb.\n\nWind speed of 5 m s^{-1}$ measured at 10m above ground.\n\n... and fixed surface albedo of 0.23 as defined for FAO’s reference ET.\n\nSee Also\n\nYou can check the PyTSEB GitHub source codes for the \n\nPenman-Monteith model, for the \n\nShutlelworth-Wallace model, the \n\nFAO56 reference ET, and the \n\nASCE reference ET\n\nThe upper panel of the plot shows the simulated daily ET for the \n\nShuttleworth-Wallace (blue line) and \n\nPenman-Monteith (red line) models. In addition, it shows the FAO reference ET value with a black star.\n\nThe middle panel shows the ET partitioning between soil evaporation (yellow line) and canopy transpiration (green line) as simulated by Shuttleworth-Wallace.\n\nThe lower panel shows the \n\nShuttleworth-Wallace simulated soil (yellow line), canopy (green) and aerodynamic temperatures (black line), expressed as their respective differences from the air temperature.\n\nw_et = interactive(fn.fluxes_and_resistances, r_ss=fn.w_r_ss, g_st=fn.w_g_st, h_c=fn.w_hc)\ndisplay(w_et)\n\nObserve how the graphs change with R_{ss} (e.g. the topsoil moisture). See how the total ET in Shuttleworth-Wallace changes as opposed to the Penman-Monteith that can not directly consider the topsoil moisture. Observe how ET increases with LAI for the given parameters, since surface resistance decreases with LAI (R_c = r_{st}/LAI).\n\nWarning\n\nRemember that R_{ss} represents the topsoil moisture condition. Indeed, it is possible (more often than one could expect) to have a dry soil surface (R_{ss} >> 1000 s m^{-1}) while having a well-watered canopy (g_{st} >> 0 mmol m^{-2} s^{-1}$), since plants extract water deeper in the soil, where water is still stored.\n\nSee in the middle panel how transpiration dominates total ET at larger LAI values. In the previous exercise, we showed that, at larger LAI values, the canopy will intercept and absorb more energy, and thus will have a larger evaporative capacity.\n\nLook now at the ET values for LAI\\rightarrow0 when R_{ss}\\rightarrow0. Penman-Monteith, since it is a “big-leaf” model and does not directly incorporate the transport of water from the soil surface, is not able to simulate the soil surface evaporation. On the other hand, with R_{ss} values above 5000 s/m both models yield very similar values of ET.\n\nObserve in the lower panel how temperatures decrease with LAI: a dense canopy dissipates the heat more efficiently than a less dense canopy, even under the same water stress conditions.\n\nCheck also how soil temperature increases with R_{ss}.\n\nTip\n\nYou could even perceive how the leaf temperature changes slightly with R_{ss}, especially at lower LAI values. This is related to the flux interaction between ground and canopy that we mentioned before: a dry and warm (moist and cool) soil transports air towards the canopy, which can increase (decrease) the evaporative demand and, thus, decrease (increase) the canopy temperature.\n\nKeep a value of R_{ss}=5000 fixed (dry soil surface) and check now how ET changes with decreasing values of stomatal conductance, and thus simulating more severe crop water stress conditions. The ET for both Penman-Monteith and Shuttleworth-Wallace decreases and deviates further from FAO’s reference ET value (optimal water conditions). In addition, the more stressed the plant (i.e. at lower g_{st} values), the lower the transpiration, with no transpiration for g_s=0 mmol m^{-2} s^{-1}. Finally, observe that the lower g_{st}, the hotter the leaf and aerodynamic temperatures.\n\nTip\n\nYou could even perceive how the soil temperature slightly changes with g_{st}, especially at larger LAI values. This is again related to the flux interaction between ground and canopy that we mentioned before: a dry and warm (moist and cool) canopy transports air towards the ground, which can increase (decrease) the evaporative demand and thus decrease (increase) the soil temperature.\n\nSee now the effect of canopy height/roughness. Restore the values of stomatal conductance back to g_s=0.41 mmol m^{-2} s^{-1} and R_{ss}=5000. Increase now the canopy height, from an initial value of 0.12m, and observe how ET and temperature changes with canopy roughness for a given moisture status.","type":"content","url":"/turbulence-and-sensible-heat-flux#flux-interaction-between-ground-and-the-canopy","position":21},{"hierarchy":{"lvl1":"Turbulent exchange of heat and water vapour","lvl2":"About the surface temperature"},"type":"lvl2","url":"/turbulence-and-sensible-heat-flux#about-the-surface-temperature","position":22},{"hierarchy":{"lvl1":"Turbulent exchange of heat and water vapour","lvl2":"About the surface temperature"},"content":"We already mentioned that the aerodynamic temperature (T_0), which is the temperature that holds valid the sensible heat flux equation, is different to the radiometric surface temperature (LST) estimated with Earth observation remote sensing. It is therefore important to be aware of such difference and to be able to correctly interpret LST when estimating sensible heat flux and/or ET.\n\nNote\n\nIndeed, the different remote sensing ET models mainly differ on how they use the LST in order to retrieve H and/or \\lambda E.\n\nFirstly, since heat is exchanged less efficiently than momentum, we need to correctly define the aerodynamic roughness length for heat transport (z_0H), and, indeed, the relationship z_{0H} \\approx 0.1 z_{0M} might not be valid for all types of surfaces.\n\nSecondly, the radiometric surface temperature can significantly change depending on the observation viewing angle. This is particularly relevant for Earth observation sensors with a wide field of view or wide swath, such as Sentinel-3 SLSTR, with view zenith angles ranging from nadir (VZA = 0º) up to VZAs of 50º or 60º. This is important since the sensor might see a different proportion of (cool) vegetation and (warm) soil. Indeed, we saw in the previous exercise that the canopy transmittance depends on the canopy density, the leaf angle distribution, and the incidence/illumination angle. This effect is perfectly reciprocal when we deal with the sensor geometry instead of the solar geometry.\n\nThe interactive plot below demonstrates this effect. You can define the sensor’s view zenith angle as well as the dominant leaf inclination angle. According to the soil and canopy temperatures estimated in the \n\nprevious simulation, and after setting as well the soil and leaf emissivity, the graph will display the estimated LST for a range of LAIs.\n\nTip\n\nYou can modify the simulation parameters \n\nhere and the changes will be reflected in the simulated LST.\n\nThe plot shows two different methods of estimating the radiometric land surface temperature:\n\nA detailed calculation based on the 4SAIL model that includes thermal emission and multiple thermal scattering between soil and vegetation.\n\nSee Also\n\nYou can check the \n\nPython version of 4SAIL model\n\nA simplified method which considers a weighted average based on the fraction of vegetation observed by the sensor, which is the one implemented in TSEB:LST^4=f_c\\left(\\theta\\right)T_{C}^4+\\left[1-f_{c}\\left(\\theta\\right)\\right]T_{S}^4\n\nSee Also\n\nYou can check the \n\npyTSEB GitHub source code\n\nw_fveg = interactive(fn.get_land_surface_temperature,\n                     vza=fn.w_vza, leaf_angle=fn.w_leaf_angle, temperatures=fixed(w_et), \n                     e_v=fn.w_ev, e_s=fn.w_es)\ndisplay(w_fveg)\n\nNotice that with increasing VZA, the LST is decreasing, with this decrease being more significant at higher VZAs (VZA > 35º) and for intermediate values of LAI.\n\nThere might be significant differences between the aerodynamic temperature and the LST, in particular for less developed and sparse canopies (LAI < 2).\n\n","type":"content","url":"/turbulence-and-sensible-heat-flux#about-the-surface-temperature","position":23},{"hierarchy":{"lvl1":"Turbulent exchange of heat and water vapour","lvl2":"Conclusions"},"type":"lvl2","url":"/turbulence-and-sensible-heat-flux#conclusions","position":24},{"hierarchy":{"lvl1":"Turbulent exchange of heat and water vapour","lvl2":"Conclusions"},"content":"In this exercise, we have seen that exchange of heat and vapour between ground, vegetation and the atmosphere depend on:\n\nThe topsoil moisture content, which drives the soil evaporation.\n\nThe root-zone soil moisture content, which drives the canopy transpiration and its photosynthetic capacity.\n\nThe canopy structure, which drives how efficiently the canopy dissipates the heat and vapour towards the atmosphere.\n\nThe radiometric land surface temperature is a key factor in order to evaluate the crop water stress and crop evapotranspiration.\n\nNote\n\nPlease feel free comment any thoughts.","type":"content","url":"/turbulence-and-sensible-heat-flux#conclusions","position":25},{"hierarchy":{"lvl1":"How TSEB works?"},"type":"lvl1","url":"/tseb-introduction","position":0},{"hierarchy":{"lvl1":"How TSEB works?"},"content":"","type":"content","url":"/tseb-introduction","position":1},{"hierarchy":{"lvl1":"How TSEB works?","lvl2":"Summary"},"type":"lvl2","url":"/tseb-introduction#summary","position":2},{"hierarchy":{"lvl1":"How TSEB works?","lvl2":"Summary"},"content":"This interactive Jupyter Notebook has the objective of showing the implemenation of TSEB-PT model in the \n\npyTSEB package.\n\n","type":"content","url":"/tseb-introduction#summary","position":3},{"hierarchy":{"lvl1":"How TSEB works?","lvl2":"Instructions"},"type":"lvl2","url":"/tseb-introduction#instructions","position":4},{"hierarchy":{"lvl1":"How TSEB works?","lvl2":"Instructions"},"content":"Read carefully all the text and follow the instructions.\n\nOnce each section is read, run the jupyter code cell underneath (marked as In []) by clicking the icon Run, or pressing the keys SHIFT+ENTER of your keyboard. A graphical interface will then display, which allows you to interact with and perform the assigned tasks.\n\nTo start, please run the following cell to import all the packages required for this notebook. Once you run the cell below, an acknowledgement message, stating all libraries were correctly imported, should be printed on screen.\n\n%matplotlib inline\nfrom pathlib import Path\nfrom ipywidgets import interact, interactive, fixed, widgets\nfrom IPython.display import display\nimport numpy as np\nfrom pyTSEB import TSEB\nprint(\"Libraries imported!\")\n\n","type":"content","url":"/tseb-introduction#instructions","position":5},{"hierarchy":{"lvl1":"How TSEB works?","lvl2":"The TSEB model"},"type":"lvl2","url":"/tseb-introduction#the-tseb-model","position":6},{"hierarchy":{"lvl1":"How TSEB works?","lvl2":"The TSEB model"},"content":"The Two-Source Energy Balance (TSEB) model \n\nNorman et al. (1995) was specifically designed to account for directionality of radiometric temperature measurements and to avoid the use of any empirical “excess” resistance terms in the model. TO achieve this, both the heat and water fluxes are separated into a soil and canopy layer, with a set of resistances set in series.\n\nNote\n\nIn \n\nNorman et al. (1995) the original resistance scheme was in parallel\n\n\n\nFigure 1:Schematic diagram of the TSEB model resistance network for sensible heat flux and the basic set of equations used to obtain an iterative solution. Source: \n\nKustas et al. (2018).\n\nEnergy fluxes are therefore split into soil and canopy, considering the conservation of energy:R_{n} & \\approx H + \\lambda E + G\\\\\n  R_{n,C} & \\approx H_{C} + \\lambda E_{C}  R_{n,C} & \\approx H_{C} + \\lambda E_{C}\n\nwith R_n being the net radiation, H the sensible heat flux, \\lambda E the latent heat flux or evapotranspiration, and G the soil heat flux (all fluxes are expressed in W m^{-2}. The approximation in Eq. \\ref{eq:Energy_Balance} reflects additional components of the energy balance that are usually neglected, such as heat advection, storage of energy in the canopy layer or energy for the fixation of CO_2, which are not computed by the model.\n\nRemote sensing Energy Balance Models, REBMs, rely on the ability of the radiometric information to estimate, net radiation, soil heat flux and sensible heat flux \n\n(Norman et al., 1995). To see how pyTSEB works we will run several pieces of code to estimate each of the components of the energy balance.\n\n","type":"content","url":"/tseb-introduction#the-tseb-model","position":7},{"hierarchy":{"lvl1":"How TSEB works?","lvl2":"Implementation with actual data in pyTSEB"},"type":"lvl2","url":"/tseb-introduction#implementation-with-actual-data-in-pytseb","position":8},{"hierarchy":{"lvl1":"How TSEB works?","lvl2":"Implementation with actual data in pyTSEB"},"content":"We have several GRAPEX sites with micrometeorological measurements that we will use in this and in future exercises. By running TSEB at hourly timesteps we could get a better overview of its behaviour, challenges and limitations.\n\nNote\n\nRunning pyTSEB over an image follows exactly the same procedure as all the pixels, or dates in the case of tabulated timeseries, are converted to a vectorized array for computing efficiency.\n\nTable 1:Description of GRAPEX sites\n\nSite\n\nLatitude\n\nLongitude\n\nElevation (m)\n\nRow direction (deg.)\n\nRow spacing (m)\n\nMin. height (m)\n\nMax. height (m)\n\nMin. width (m)\n\nMax. width (m)\n\nTA height (m)\n\nWS height (m)\n\nRipperdan 720-1\n\n36.849\n\n-120.176\n\n61\n\n90\n\n3.35\n\n1.2\n\n2.2\n\n0.5\n\n2.25\n\n4\n\n4\n\nRipperdan 720-2\n\n36.849\n\n-120.174\n\n61\n\n90\n\n3.35\n\n1.2\n\n2.2\n\n0.5\n\n2.25\n\n4\n\n4\n\nRipperdan 720-3\n\n36.848\n\n-120.176\n\n61\n\n90\n\n3.35\n\n1.2\n\n2.2\n\n0.5\n\n2.25\n\n4\n\n4\n\nRipperdan 720-4\n\n36.848\n\n-120.174\n\n61\n\n90\n\n3.35\n\n1.2\n\n2.2\n\n0.5\n\n2.25\n\n4\n\n4\n\nBarrelli_007\n\n38.753\n\n-122.98\n\n113\n\n135\n\n3.35\n\n1.25\n\n2.3\n\n0.5\n\n1.8\n\n4\n\n4\n\nBarrelli_012\n\n38.751369\n\n-122.974658\n\n112\n\n45\n\n3.35\n\n1.25\n\n2.3\n\n0.5\n\n1.8\n\n4.4\n\n4.4\n\nSierra Loma-north\n\n38.289338\n\n-121.117764\n\n38\n\n90\n\n3.35\n\n1.42\n\n2.25\n\n0.5\n\n2.6\n\n5\n\n5\n\nSierra Loma-south\n\n38.280488\n\n-121.117597\n\n37\n\n90\n\n3.35\n\n1-42\n\n2.25\n\n0.5\n\n2\n\n5\n\n5\n\nRipperdan 760\n\n36.839025\n\n-120.21014\n\n58\n\n90\n\n2.74\n\n1.2\n\n2.5\n\n0.5\n\n1.8\n\n5.5\n\n5\n\nBarrelli_016\n\n38.747\n\n-122.963\n\n112\n\n135\n\n3.35\n\n1.25\n\n2.3\n\n0.5\n\n1.8\n\n4\n\n4\n\nIn future exercises you could have the chance to process all sites, or those of interest for you. However, for this first exercise and to keep things simpler we will stick to Ripperdam 720-4, since some deficit irrigation events happened in some years \n\n(see Nieto et al., 2022)\n\nSee Also\n\nThis is a full description of the EC column fields:\n\n\n\n","type":"content","url":"/tseb-introduction#implementation-with-actual-data-in-pytseb","position":9},{"hierarchy":{"lvl1":"How TSEB works?","lvl3":"Read the LAI and Micrometeorology data","lvl2":"Implementation with actual data in pyTSEB"},"type":"lvl3","url":"/tseb-introduction#read-the-lai-and-micrometeorology-data","position":10},{"hierarchy":{"lvl1":"How TSEB works?","lvl3":"Read the LAI and Micrometeorology data","lvl2":"Implementation with actual data in pyTSEB"},"content":"We will read and merge the \n\ninput micrometeorology and \n\ninput LAI ASCII files.\n\nSee Also\n\nA detailed description of the Eddy Covariance measurements and their post-\nprocessing is described by \n\nAlfieri et al. (2019b).\n\nEstimates of daily LAI were obtained from training MODIS LAI (MCD15A3H) product and Landsat surface\nreflectance using the reference based approach by \n\nGao et al. (2012) and adapted for vineyards by \n\nKang et al. (2022)\n\n# Set the site shortname to be processed\nsite = \"rip720_4\"\n\n# Import Python libraries\nfrom pathlib import Path\nimport pandas as pd\n\n# Set the LAI and readiation folders\ninput_dir = Path().absolute() / \"input\"\nlai_dir = input_dir / \"canopy\"\nec_dir = input_dir / \"meteo\"\n# Set the input files based on the chosen site\nlai_filename = lai_dir / f\"FLX_US-{site}_FLUXNET2015_AUXCANOPY_DD.csv\"\nec_filename = ec_dir / f\"FLX_US-{site}_FLUXNET2015_SUBSET_HR.csv\"\nprint(f\"LAI file path is {lai_filename}\")\nprint(f\"EC file path is {ec_filename}\")\n\n# Read the LAI and radiation tables\nlai = pd.read_csv(lai_filename, sep=\";\", na_values=-9999)\nec = pd.read_csv(ec_filename, sep=\";\", na_values=-9999)\n\n# Merge both tables by date\nec[\"TIMESTAMP\"] = pd.to_datetime(ec[\"TIMESTAMP\"], format=\"%Y%m%d%H%M\")\nlai[\"DATE\"] = pd.to_datetime(lai[\"TIMESTAMP\"], format=\"%Y%m%d\").dt.date\nlai = lai.drop(labels=[\"TIMESTAMP\"], axis=1)\nec[\"DATE\"] = ec[\"TIMESTAMP\"].dt.date\nec = ec.merge(lai, on=\"DATE\")\n\n# We discard all cases at night (SW_IN <=0)\nec = ec[ec[\"SW_IN\"] > 0]\n\n# Convert Celsius to Kelvin\nec[\"TA\"] = ec[\"TA\"] + 273.15\n# Convert kPa to hPa\nec[\"PA\"] = 10 * ec[\"PA\"]\n\n# Evaluate different energy balance closure corrections\nec[\"H_RES\"] = ec[\"NETRAD\"] - ec[\"G\"] - ec[\"LE\"]\nec['LE_RES'] = ec['NETRAD'] - ec['G'] - ec['H']\nec[\"LE_BR\"], ec[\"H_BR\"] = TSEB.met.bowen_ratio_closure(ec[\"NETRAD\"], ec[\"G\"],\n                                                       ec[\"H\"], ec[\"LE\"])\n# Mean of uncorrected, ressidual and Bowen Ratio\nec[\"H_ENS\"] = np.nanmean([ec[\"H_RES\"], ec[\"H_BR\"], ec['H']], axis=0)\nec[\"LE_ENS\"] = np.nanmean([ec[\"LE_RES\"], ec[\"LE_BR\"], ec['LE']], axis=0)\n\n","type":"content","url":"/tseb-introduction#read-the-lai-and-micrometeorology-data","position":11},{"hierarchy":{"lvl1":"How TSEB works?","lvl3":"Net shortwave radiation","lvl2":"Implementation with actual data in pyTSEB"},"type":"lvl3","url":"/tseb-introduction#net-shortwave-radiation","position":12},{"hierarchy":{"lvl1":"How TSEB works?","lvl3":"Net shortwave radiation","lvl2":"Implementation with actual data in pyTSEB"},"content":"To compute the net shortwave radiation and its partitioning between the canopy and the soil we are using the model of \n\nCampbell and Norman, 1998, Chapter 15. The key aspect of this model is the calculation of the trasmitted shortwave radiation throught the canopy (\\Tau_C)\n\nSee Also\n\nThe full description of the radiation model can be found in \n\nCampbell and Norman, 1998, Chapter 15\n\nThe transmittance of shortwave radiation through the canopy depends on the wavelength due to vegetation absorbing a greater portion of the photosynthetically active radiation (PAR, 400–700 nm spectrum) than near-infrared radiation (NIR, 700–2500 nm spectrum) wavelengths. (\\Tau_C is partitioned into two components (direct/diffse) and in two spectral band (PAR/NIR)\n\nNote\n\nWe could include more spectral bands, such as (PAR/NIR/SWIR), with a slight increase of computational cost.\n\nThe direct-beam spectral (transmittance (\\tau_{C,DIR,\\lambda}) at a given solar zenith angle (\\theta_S) is calculated following the equations of Campbell and Norman (1998) for a single layer crop:\\tau_{C,DIR,\\lambda}\\left(\\theta_S\\right)=\\frac{\\left(\\rho_{C,\\lambda}^*\\left(\\theta_S\\right)^2 - 1\\right)\\exp \\left( -\\sqrt{\\zeta_\\lambda} \\kappa_{b}\\left(theta_S\\right)LAI\\right)}{\\left(\\rho_{C,\\lambda}^*\\rho_{S,\\lambda} - 1\\right) + \\rho_{C,\\lambda}^*\\left(\\psi\\right)\\left(\\rho_{C\\lambda}^*\\left(\\theta_S\\right) - \\rho_{S,\\lambda}\\right)\\exp \\left( -2\\sqrt {\\zeta_\\lambda \\kappa_{b}\\left(\\theta_S\\right)LAI} \\right)}\n\nwith (\\lambda) being either the PAR or NIR. \\rho_{C,\\lambda}^*\\left(\\psi\\right) is the beam spectral reflection coefficient for a deep canopy with non-horizontal leaves (see Eq. \n\n(3)), \\zeta_\\lambda is the leaf absortivity, \\kappa_{b} is the extinction coefficient for direct-beam radiation (per LAI unit), and \\rho_{S,\\lambda} is the soil spectral reflectance. The multiple scattering between the soil and the canopy is accounted for in the \\rho _{C,\\lambda}^* and \\rho_{S,\\lambda} terms.\\rho_{C,\\lambda}^*\\left(\\theta_S\\right)=\\frac{2\\kappa_b\\left(\\theta_S\\right) \\rho_\\lambda^H}{\\kappa_b\\left(\\theta_S\\right)+1}\n\n\\rho_\\lambda^H=\\frac{1 - \\sqrt{\\zeta_\\lambda}}{1+\\sqrt{\\zeta_\\lambda}} is the reflectance factor for a canopy with horizontal leaves.\n\nFinally, the canopy beam extinction \\kappa_b\\left(\\psi\\right) is calculated based on the ellipsoidal LADF of \n\nCampbell (1990)\\kappa_b\\left(\\theta_S\\right)=\\frac{\\sqrt{\\chi^2+ \\tan^2\\theta_S}}{\\chi+1.774\\left(\\chi+1.182\\right)^{-0.733}}\n\nDiffuse spectral transmittance (\\tau_{C,DIF,\\lambda}) is calculated by numerically integrating \\kappa_b over the hemisphere\\kappa_d =2 \\int_0^\\pi\\kappa_b\\left(\\psi\\right) \\sin\\psi \\cos\\psi d\\psi\n\nand replacing \\kappa_b by \\kappa_d in Eq. \n\n(2)\n\nSimilarly the canopy direct spectral albedo is computed as:\\rho_{C,DIR,\\lambda}\\left(\\theta_S\\right)=\\frac{\\rho_{C,\\lambda}^*\\left(\\theta_S\\right) + \\left[\\frac{\\rho_{C,\\lambda}^*\\left(\\theta_S\\right) - \\rho_{S,\\lambda}}{\\rho_{C,\\lambda}^*\\left(\\theta_S\\right)\\rho_{s,\\lambda} -1}\\right] \\exp\\left(-2\\sqrt{\\zeta_\\lambda}\\kappa_b\\left(\\theta_S\\right)LAI\\right)}{1 + \\rho_{C,\\lambda}^*\\left(\\theta_S\\right) + \\left[\\frac{\\rho_{C,\\lambda}^*\\left(\\theta_S\\right) - \\rho_{s,\\lambda}}{\\rho_{C,\\lambda}^*\\left(\\theta_S\\right)\\rho_{S,\\lambda} -1}\\right] \\exp\\left(-2\\sqrt{\\zeta_\\lambda}\\kappa_b\\left(\\theta_S\\right)LAI\\right)}\n\nand the diffuse canopy albedo (\\rho_{C,DIF,\\lambda}) by replacing \\kappa_b\\left(\\theta_S\\right) by \\kappa_d\n\nTherefore as inputs for computin net shortwave radiation we need to provide as input forcing the solar irradiance, direct and diffuse in the PAR and NIR, and then as main input the LAI, followed by soil and leaf spectra and \n\nCampbell (1990) LIDF parameter (\\chi).\n\nIn this example we will simplify things and assume that the canopy is horizontally homogeneous and thus no clumping index will be compute\n\nNote\n\nwe will get into more details on this topic in the \n\nTSEB in row crops notebook\n\nSee Also\n\nThe code for estimating the diffuse and bean radiation is based on {Weiss and Norman (1985}(\n\nWeiss & Norman (1985)) and can be found at the \n\npyTSEB GitHub repository\n\nThe code for running the Cambpell and Norman (1998)[] model can be found at the pyTSEB GitHub repository: \n\ncanopy spectral properties and \n\nestimation of net shortwave radiation\n\n# Site location\nlat = 36.848\nlon = -120.174\n\n# The time zone is PST, which corresponds to -120 deg, time longitude\nstdlon = -120\n\n# Set the leaf and soil spectra\nrho_leaf_vis = 0.054\nrho_leaf_nir = 0.262\ntau_leaf_vis = 0.038\ntau_leaf_nir = 0.333\nrho_soil_vis = 0.07\nrho_soil_nir = 0.32\n\n# Set the Cambpell chi LIDF parameter [default=1, spherical LIDF]\nx_lad = 1\n\n# The ASCII table is missing the solar angles, so we will use the calc_sun_angles function of TSEB to compute the angles based on site location and timestamp\ntheta, saa = TSEB.met.calc_sun_angles(\n    np.full_like(ec['LAI'].values, lat),\n    np.full_like(ec[\"LAI\"].values, lon),\n    np.full_like(ec[\"LAI\"].values, stdlon),\n    ec['TIMESTAMP'].dt.dayofyear.values,\n    ec['TIMESTAMP'].dt.hour.values + ec['TIMESTAMP'].dt.minute.values / 60.)\n\n\n# In order to esimate Estimates the direct and diffuse solar radiation based on the Weiss and Norman model\ndifvis, difnir, fvis, fnir = TSEB.rad.calc_difuse_ratio(ec[\"SW_IN\"].values,\n                                                        theta,\n                                                        press=np.full_like(theta, 1013.15))\npar_dir = fvis * (1. - difvis) * ec[\"SW_IN\"].values\nnir_dir = fnir * (1. - difnir) * ec[\"SW_IN\"].values\npar_dif = fvis * difvis * ec[\"SW_IN\"].values\nnir_dif = fnir * difnir * ec[\"SW_IN\"].values\n\n# Vectorize the input scalar variables\nx_lad = np.full_like(ec[\"LAI\"].values, x_lad)\nrho_leaf_vis = np.full_like(ec[\"LAI\"].values, rho_leaf_vis)\nrho_leaf_nir = np.full_like(ec[\"LAI\"].values, rho_leaf_nir)\ntau_leaf_vis = np.full_like(ec[\"LAI\"].values, tau_leaf_vis)\ntau_leaf_nir = np.full_like(ec[\"LAI\"].values, tau_leaf_nir)\nrho_soil_vis = np.full_like(ec[\"LAI\"].values, rho_soil_vis)\nrho_soil_nir = np.full_like(ec[\"LAI\"].values, rho_soil_nir)\n\n# We append the VIS and PAR spectrum to be computationally more efficient in Numpy\nrho_leaf = np.array((rho_leaf_vis, rho_leaf_nir))\ntau_leaf = np.array((tau_leaf_vis, tau_leaf_nir))\nrho_soil = np.array((rho_soil_vis, rho_soil_nir))\n\n# calculate aborprtivity\namean = 1.0 - rho_leaf - tau_leaf\namean_sqrt = np.sqrt(amean)\n\n# Calculate canopy beam extinction coefficient\nlai_eff = np.asarray(ec[\"LAI\"].values)  # So far we are assuming a homogenous canopy so the effective LAI of a clumped canopy does not vary\n\n# D I F F U S E   C O M P O N E N T S\n# Integrate to get the diffuse transmitance\n\ntaud = 0\nfor angle in range(0, 90, 5):\n    angle = np.radians(angle)\n    akd = (np.sqrt(x_lad**2 + np.tan(theta)**2) / (x_lad + 1.774 * (x_lad + 1.182)**-0.733))  # Eq. 15.4\n    taub = np.exp(-akd * ec[\"LAI\"].values)\n    taud += taub * np.cos(angle) * np.sin(angle) * np.radians(5)\n\ntaud = 2.0 * taud\n\n# Diffuse light canopy reflection coefficients  for a deep canopy\nakd = -np.log(taud) / ec[\"LAI\"].values\nrcpy= (1.0 - amean_sqrt) / (1.0 + amean_sqrt)  # Eq 15.7\nrdcpy = 2.0 * akd * rcpy / (akd + 1.0)  # Eq 15.8\n\n# Diffuse canopy transmission and albedo coeff for a generic canopy (visible)\nexpfac = amean_sqrt * akd * ec[\"LAI\"].values\nneg_exp, d_neg_exp = np.exp(-expfac), np.exp(-2.0 * expfac)\nxnum = (rdcpy * rdcpy - 1.0) * neg_exp\nxden = (rdcpy * rho_soil - 1.0) + rdcpy * (rdcpy - rho_soil) * d_neg_exp\ntaudt = xnum / xden  # Eq 15.11\nfact = ((rdcpy - rho_soil) / (rdcpy * rho_soil - 1.0)) * d_neg_exp\nalbd = (rdcpy + fact) / (1.0 + rdcpy * fact)  # Eq 15.9\n\n# B E A M   C O M P O N E N T S\n# Direct beam extinction coeff (spher. LAD)\nakb = (np.sqrt(x_lad**2 + np.tan(theta)**2) / (x_lad + 1.774 * (x_lad + 1.182)**-0.733))  # Eq. 15.4\n\n# Direct beam canopy reflection coefficients for a deep canopy\nrbcpy = 2.0 * akb * rcpy / (akb + 1.0)  # Eq 15.8\n# Beam canopy transmission and albedo coeff for a generic canopy (visible)\nexpfac = amean_sqrt * akb * lai_eff\nneg_exp, d_neg_exp = np.exp(-expfac), np.exp(-2.0 * expfac)\nxnum = (rbcpy * rbcpy - 1.0) * neg_exp\nxden = (rbcpy * rho_soil - 1.0) + rbcpy * (rbcpy - rho_soil) * d_neg_exp\ntaubt = xnum / xden  # Eq 15.11\nfact = ((rbcpy - rho_soil) / (rbcpy * rho_soil - 1.0)) * d_neg_exp\nalbb = (rbcpy + fact) / (1.0 + rbcpy * fact)  # Eq 15.9\n\ntaubt, taudt, albb, albd, rho_soil = map(np.array,\n                                         [taubt, taudt, albb, albd, rho_soil])\n\ntaubt[np.isnan(taubt)] = 1\ntaudt[np.isnan(taudt)] = 1\nalbb[np.isnan(albb)] = rho_soil[np.isnan(albb)]\nalbd[np.isnan(albd)] = rho_soil[np.isnan(albd)]\n\n# Compute the canopy and soil net radiation using Cambpell RTM\nsn_c = ((1.0 - taubt[0]) * (1.0- albb[0]) * par_dir\n            + (1.0 - taubt[1]) * (1.0- albb[1]) * nir_dir\n            + (1.0 - taudt[0]) * (1.0- albd[0]) * par_dif\n            + (1.0 - taudt[1]) * (1.0- albd[1]) * nir_dif)\n\nsn_s = (taubt[0] * (1.0 - rho_soil_vis) * par_dir\n            + taubt[1] * (1.0 - rho_soil_nir) * nir_dir\n            + taudt[0] * (1.0 - rho_soil_vis) * par_dif\n            + taudt[1] * (1.0 - rho_soil_nir) * nir_dif)\n\nprint(\"Finished the computation of net shortwave radiation\")\n\n","type":"content","url":"/tseb-introduction#net-shortwave-radiation","position":13},{"hierarchy":{"lvl1":"How TSEB works?","lvl4":"Evaluate net shortwave radiation","lvl3":"Net shortwave radiation","lvl2":"Implementation with actual data in pyTSEB"},"type":"lvl4","url":"/tseb-introduction#evaluate-net-shortwave-radiation","position":14},{"hierarchy":{"lvl1":"How TSEB works?","lvl4":"Evaluate net shortwave radiation","lvl3":"Net shortwave radiation","lvl2":"Implementation with actual data in pyTSEB"},"content":"\n\nfrom plotly.subplots import make_subplots\nimport plotly.graph_objects as go\ndaytime = ec[\"SW_IN\"] > 100\n\nsn_model = sn_c + sn_s\nsn_obs = ec[\"SW_IN\"].values - ec[\"SW_OUT\"].values\n\nfig = go.Figure()\nfig.add_trace(go.Scatter(x=sn_model[daytime], y=sn_obs[daytime], \n                         name=\"Sn\", mode=\"markers\"))\nfig.add_trace(go.Scatter(x=[0, 1000], y=[0, 1000], mode=\"lines\", name=\"1:1 line\", line={\"color\": \"black\", \"dash\": \"dash\"}))\nfig.update_layout(title_text=f\"Observed vs. Estimated net shortwave radiation at {site}\",\n                  yaxis_range=[0, 1000], xaxis_range=[0, 1000],\n                  xaxis_title=\"Estimated (W m-2)\", yaxis_title=\"Observed (W m-2)\")\n\n","type":"content","url":"/tseb-introduction#evaluate-net-shortwave-radiation","position":15},{"hierarchy":{"lvl1":"How TSEB works?","lvl3":"Net longwave radiation","lvl2":"Implementation with actual data in pyTSEB"},"type":"lvl3","url":"/tseb-introduction#net-longwave-radiation","position":16},{"hierarchy":{"lvl1":"How TSEB works?","lvl3":"Net longwave radiation","lvl2":"Implementation with actual data in pyTSEB"},"content":"The net longwave radiation a priori is much simpler as we assume that all emitted and indident longwave radiation is diffuse. In pyTSEB we follow a similar approach as the one described in \n\nKustas and Norman (1999) for partially vegetated surfaces, which also partitions net longwave radiation into the soil (L_{n,S}) and the canopy components (L_{n,C}). The only difference between pyTSEB and the formulation of \n\nKustas and Norman (1999) is that we incorporate longwave scattering between the soil and the canopy:L_{n,S} &= \\epsilon_S \\kappa_l LAI L_{sky} + \\epsilon_S \\left(1.0 - \\kappa_l LAI * L_{sky} \\right) L_C - L_S\\\\\nL_{n,C} &= \\epsilon_C \\left(1.0 - \\kappa_l LAI * L_{sky}\\right) \\left(L_{sky} + L_S\\right) - 2.0 \\left(1.0 - \\kappa_l LAI\\right) L_C\n\nwhere L_{sky} is the downwelling atmospheric longwave irradiance, L_S and L_C are the longwave emission of respectively soil and canopy layers, \\kappa_l is analogous to the shortwave diffuse transmittance (\\kappa_d) and thus it can be calculated from Eq. \n\n(5), \\epsilon_S is soil emisivity and \\epsilon_C can be derived from Eq. \n\n(6) (\\epsilon_C = 1 - \\rho_{C,DIF,l}) and leaf emissivity.\n\nNote\n\nEven we use a modified version of \n\nKustas and Norman (1999), the pyTSEB package also includes the original formulation \n\nhere\n\nHowever, L_S and L_C depend respectively on soil and canopy temperature, which at this stage is an unknown. For that reason the application of this equation is done internaly when deriving the component temperature and sensible heat fluxes (see the upcoming Section \n\nSensible heat flux)\n\ndef calc_L_n_Campbell(T_C, T_S, L_dn, lai, emisVeg, emisGrd, x_LAD=1):\n    ''' Net longwave radiation for soil and canopy layers\n\n    Estimates the net longwave radiation for soil and canopy layers unisg based on equation 2a\n    from [Kustas1999]_ and incorporated the effect of the Leaf Angle Distribution based on [Campbell1998]_\n\n    Parameters\n    ----------\n    T_C : float\n        Canopy temperature (K).\n    T_S : float\n        Soil temperature (K).\n    L_dn : float\n        Downwelling atmospheric longwave radiation (w m-2).\n    lai : float\n        Effective Leaf (Plant) Area Index.\n    emisVeg : float\n        Broadband emissivity of vegetation cover.\n    emisGrd : float\n        Broadband emissivity of soil.\n    x_LAD: float, optional\n        x parameter for the ellipsoidal Leaf Angle Distribution function,\n        use x_LAD=1 for a spherical LAD.\n\n    Returns\n    -------\n    L_nC : float\n        Net longwave radiation of canopy (W m-2).\n    L_nS : float\n        Net longwave radiation of soil (W m-2).\n\n    References\n    ----------\n    .. [Kustas1999] Kustas and Norman (1999) Evaluation of soil and vegetation heat\n        flux predictions using a simple two-source model with radiometric temperatures for\n        partial canopy cover, Agricultural and Forest Meteorology, Volume 94, Issue 1,\n        Pages 13-29, http://dx.doi.org/10.1016/S0168-1923(99)00005-2.\n    '''\n\n    # calculate long wave emissions from canopy, soil and sky\n    L_C = emisVeg * met.calc_stephan_boltzmann(T_C)\n    L_C[np.isnan(L_C)] = 0\n    L_S = emisGrd * met.calc_stephan_boltzmann(T_S)\n    L_S[np.isnan(L_S)] = 0\n    # Calculate the canopy spectral properties\n    _, albl, _, taudl = calc_spectra_Cambpell(lai,\n                                              np.zeros(emisVeg.shape),\n                                              1.0 - emisVeg,\n                                              np.zeros(emisVeg.shape),\n                                              1.0 - emisGrd,\n                                              x_lad=x_LAD,\n                                              lai_eff=None)\n\n    # calculate net longwave radiation divergence of the soil\n    L_nS = emisGrd * taudl * L_dn + emisGrd * (1.0 - taudl) * L_C - L_S\n    L_nC = (1 - albl) * (1.0 - taudl) * (L_dn + L_S) - 2.0 * (1.0 - taudl) * L_C\n    L_nC[np.isnan(L_nC)] = 0\n    L_nS[np.isnan(L_nS)] = 0\n    return np.asarray(L_nC), np.asarray(L_nS)\n\n","type":"content","url":"/tseb-introduction#net-longwave-radiation","position":17},{"hierarchy":{"lvl1":"How TSEB works?","lvl3":"Soil heat flux","lvl2":"Implementation with actual data in pyTSEB"},"type":"lvl3","url":"/tseb-introduction#soil-heat-flux","position":18},{"hierarchy":{"lvl1":"How TSEB works?","lvl3":"Soil heat flux","lvl2":"Implementation with actual data in pyTSEB"},"content":"Soil heat flux is usually estimated as a fraction of the soil net radiation R_{n,S}. Such fraction can be assumed constant along the day (e.g. G=0.35 R_{n,S}) or can change along the day, such as the sinusoidal function proposed by \n\nSantanello and Friedl, 2003.\n\nSince the computation of net longwave radiation is dependant of getting estimates of T_C and T_S and thus is computed internally in the TSEB modules during the iteration that will be discussed in the next section, G is also computed within the TSEB function, being iteratevely recomputed every time a new T_C and T_S is obtained. The different TSEB versions in pyTSEB accept computing G in four different ways:\n\nAs a constant ratio of R_{n,S} \n\nfunction calc_G_ratio\n\nAs time dependent ratio of R_{n,S} according to a sinusoidal function \n\nfunction calc_G_time_diff\n\nAs time dependent ratio of R_{n,S} according to a double assymetric sigmoid function \n\npyTSEB/TSEB.py\n\nAs precomputed/prescribed values\n\nNote\n\nThis last option can be chosen to force the use of measured G when running TSEB, which sometimes can be useful when testing and evaluating new (sub)modules into TSEB.\n\n","type":"content","url":"/tseb-introduction#soil-heat-flux","position":19},{"hierarchy":{"lvl1":"How TSEB works?","lvl3":"Surface roughness","lvl2":"Implementation with actual data in pyTSEB"},"type":"lvl3","url":"/tseb-introduction#surface-roughness","position":20},{"hierarchy":{"lvl1":"How TSEB works?","lvl3":"Surface roughness","lvl2":"Implementation with actual data in pyTSEB"},"content":"In addition, REBMs need additional ancillary inputs, such as air temperature, wind speed and canopy height or roughness. The latter accounts for the efficiency in the turbulent transport of heat and water between the land surface and the overlying air \n\nRaupach (1994)\n\nAlfieri et al. 2019 (you can revisity the  \n\n102​-Turbulence​_and​_sensible​_heat​_flux notebook). Specifically for pyTSEB, vegetation structure and density are also important for estimating wind and radiation extinction through the canopy layer affecting the radiation partitioning \n\nParry et al. (2019) and turbulent transport of  momentum, heat  and water vapour in the canopy air space \n\nNieto et al. (2019).\n\nIn pyTSEB, depending on the plant functional trait, roughness can be estimated using different methods. For short and herbaceous crops, the typical ratio of canopy height (h_c) is applied:d_0 &= 2/3 h_c\nz_{0m} & = 1/8 h_c\n\nwhere d_0 is the zero-plane displacement height and z_{0m} is the roughness length for momentum.\n\nFor tall and woody canopies, in which leaf density and coverage can play a more importan role, pyTSEB can adopt the formulation of \n\nSchaudt and Dickinson (2000), which at the same time it relies on the model by [Raupach (1994))(\n\nRaupach (1994))\n\nSince vineyards can be considered as open shrublands or short decidous broadleaved canopies, we will compute roughness based on \n\nSchaudt and Dickinson (2000). As inputs we need not only the canopy height (h_c), but alos the LAI, the fractional cover and the width-to-height canopy ratio (w_c)","type":"content","url":"/tseb-introduction#surface-roughness","position":21},{"hierarchy":{"lvl1":"How TSEB works?","lvl4":"Estimate the structural variables based on Earth Observation LAI timeseries","lvl3":"Surface roughness","lvl2":"Implementation with actual data in pyTSEB"},"type":"lvl4","url":"/tseb-introduction#estimate-the-structural-variables-based-on-earth-observation-lai-timeseries","position":22},{"hierarchy":{"lvl1":"How TSEB works?","lvl4":"Estimate the structural variables based on Earth Observation LAI timeseries","lvl3":"Surface roughness","lvl2":"Implementation with actual data in pyTSEB"},"content":"These canopy structural variables could be retrieved using empirical equations derived in \n\nNieto et al. (2019. These were estimated from the daily LAI using empirical curves (\n\nFigure 2 fit with measured in situ values during four Intensive Observation Periods in 2015 in Sierra Loma. The empirical fits were constrained by the following boundary conditions:\n\nh_c should tend to the height of the vine trellis when LAI tends to zero, as this is where the branches with sprouts are located:\n\ncanopy width (w_c) should tend to the width of the vine trellis when LAI tends to zero, as the branches with sprouts follows a “T” pattern:\n\nthe height of the bottom of the canopy tends to h_c when LAI tends to zero. In other words, the ratio of bottom-to-top of the canopy (h_b/h_c) tends to 1 when LAI tends to zero.\n\n\n\nFigure 2:Empirical models relating canopy height , canopy width and the bottom of the canopy with the fused STARFM LAI. Solid dots represent in situ measured values\n\nThese empirical equations are coded in Python as:\n\nimport numpy as np\n\n################################################################################\n# Empirical equations to generate canopy structural parameters from LAI\n################################################################################\ndef lai_2_hc(lai, hc_min):\n    slope = 0.42\n    hc = hc_min + slope * lai\n    return hc\n\n\ndef lai_2_hbratio(lai, hc_min):\n    hb_ratio_mean = 0.4848388065\n    hb_ratio = np.zeros(lai.shape)\n\n    hb_ratio[lai < hc_min] = 1. + ((hb_ratio_mean - 1.) / hc_min) * lai[\n        lai < hc_min]\n    hb_ratio[lai >= hc_min] = hb_ratio_mean\n\n    return hb_ratio\n\n\ndef lai_2_width(lai, wc_min, wc_max):\n    beta = 6.96560056\n    offset = 1.70825736\n\n    width = wc_min + (wc_max - wc_min) / (1.0 + np.exp(-beta * (lai - offset)))\n\n    return width\n\n\ndef lai_2_fcover(lai, fc_min, fc_max):\n    beta = 7.0\n    offset = 1.70\n\n    fcover = fc_min + (fc_max - fc_min) / (1.0 + np.exp(-beta * (lai - offset)))\n\n    return fcover\n\n\ndef lai_2_canopy(lai, hc_min, fc_min, fc_max):\n    hc = lai_2_hc(lai, hc_min)\n    hb_ratio = lai_2_hbratio(lai, hc_min)\n    fcover = lai_2_fcover(lai, fc_min, fc_max)\n\n    return hc, hb_ratio, fcover\n\nAnd when applied to the vine characteristics of Ripperdam 720-4 we can run this\n\n# Structural characterisctos of the site\nhc_min = 1.2\nhc_max = 2.2\nwc_min = 0.5\nwc_max = 2.25\ninterrow = 3.35  # Interrow width (used to compute the fractional cover as w_c / interrow\n\n# Compute the expected minimum and maximum canopy cover based on mininum and maximum canopy width\nfc_min = wc_min / interrow\nfc_max = wc_max / interrow\nh_c, hb_ratio, f_c = lai_2_canopy(ec[\"LAI\"].values,\n                                  hc_min,\n                                  fc_min,\n                                  fc_max)\n\n# Ensure that both canopy height and cover are within the limits\nh_c = np.clip(h_c, hc_min, hc_max)\nf_c = np.clip(f_c, 0, 1)\n\n# canopy width\nw_c = f_c * interrow\n# Canopy width to height ratio\nw_c_ratio = w_c / (h_c - hb_ratio * h_c)\n\nNow, with the structural parameters define we can now compute the zero-plane displacement height and roughness length for momentum\n\n# Set the site landcover type\nlandcover = TSEB.res.BROADLEAVED_D  # We coded different functional types based on the IGBP nomenclature\n\n# Convert input scalars to numpy arrays\nlai, h_c, w_c, landcover = map(np.asarray, (ec[\"LAI\"].values, h_c, w_c, landcover))\n\n# Initialize fractional cover and horizontal area index\nlambda_ = np.zeros(ec[\"LAI\"].values.shape)\n\n# Needleleaf canopies\nmask = np.logical_or(landcover == TSEB.res.CONIFER_E, landcover == TSEB.res.CONIFER_D)\nlambda_[mask] = (2. / np.pi) * f_c[mask] * w_c[mask]\n\n# Broadleaved canopies\nmask = np.logical_or.reduce((landcover == TSEB.res.BROADLEAVED_E, landcover == TSEB.res.BROADLEAVED_D,\n                             landcover == TSEB.res.FOREST_MIXED, landcover == TSEB.res.SAVANNA_WOODY))\n\nlambda_[mask] = f_c[mask] * w_c[mask]\n\n# Shrublands\nmask = np.logical_or(landcover == TSEB.res.SHRUB_O, landcover == TSEB.res.SHRUB_C)\nlambda_[mask] = f_c[mask] * w_c[mask]\n\n############################################\n# Calculation of the Raupach (1994) formulae\n############################################\n# Convert input scalar to numpy array\nlambda_ = np.asarray(lambda_)\nz_0m_factor = np.zeros(lambda_.shape)\nd_factor = np.asarray(np.zeros(lambda_.shape) + 0.65)\n\n# Calculation of the Raupach (1994) formulae\n# if lambda_ > 0.152:\ni = lambda_ > 0.152\nz_0m_factor[i] = ((0.0537 / (lambda_[i]**0.510))\n                 * (1. - np.exp(-10.9 * lambda_[i]**0.874)) + 0.00368)\n# else:\nz_0m_factor[~i] = 5.86 * np.exp(-10.9 * lambda_[~i]**1.12) * lambda_[~i]**1.33 + 0.000860\n# if lambda_ > 0:\ni = lambda_ > 0\nd_factor[i] = 1. - (1. - np.exp(-np.sqrt(15.0 * lambda_[i]))) / np.sqrt(15.0 * lambda_[i])\n\n##########################################\n# Calculation of correction factors from  Lindroth\nfz = np.asarray(0.3299 * ec[\"LAI\"].values**1.5 + 2.1713)\nfd = np.asarray(1. - 0.3991 * np.exp(-0.1779 * ec[\"LAI\"].values))\n\n# LAI <= 0\nfz[ec[\"LAI\"].values <= 0] = 1.0\nfd[ec[\"LAI\"].values <= 0] = 1.0\n\n# LAI >= 0.8775:\nfz[ec[\"LAI\"].values >= 0.8775] = 1.6771 * np.exp(-0.1717 * ec[\"LAI\"].values[ec[\"LAI\"].values >= 0.8775]) + 1.\nfd[ec[\"LAI\"].values >= 0.8775] = 1. - 0.3991 * np.exp(-0.1779 * ec[\"LAI\"].values[ec[\"LAI\"].values >= 0.8775])\n\n# Application of the correction factors to roughness and displacement\n# height\nz_0m_factor = np.asarray(z_0m_factor * fz)\nd_factor = np.asarray(d_factor * fd)\n\n# For crops and grass we use a fixed ratio of canopy height\nmask = np.logical_or.reduce((landcover == TSEB.res.CROP, landcover == TSEB.res.GRASS,\n                             landcover == TSEB.res.SAVANNA, landcover == TSEB.res.CROP_MOSAIC))\nz_0m_factor[mask] = 1. / 8.\nd_factor[mask] = 0.65\n\n# Calculation of rouhgness length\nz_0m = np.asarray(z_0m_factor * h_c)\n\n# Calculation of zero plane displacement height\nd_0 = np.asarray(d_factor * h_c)\n\n# For barren surfaces (bare soil, water, etc.)\nmask = np.logical_or.reduce((landcover == TSEB.res.WATER, landcover == TSEB.res.URBAN,\n                             landcover == TSEB.res.SNOW, landcover == TSEB.res.BARREN))\nz_0m[mask] = 0.01\nd_0[mask] = 0\n\nSee Also\n\nYou can check the code implementation in pyTSEB \n\nhere\n\n","type":"content","url":"/tseb-introduction#estimate-the-structural-variables-based-on-earth-observation-lai-timeseries","position":23},{"hierarchy":{"lvl1":"How TSEB works?","lvl3":"Sensible heat flux","lvl2":"Implementation with actual data in pyTSEB"},"type":"lvl3","url":"/tseb-introduction#sec-h","position":24},{"hierarchy":{"lvl1":"How TSEB works?","lvl3":"Sensible heat flux","lvl2":"Implementation with actual data in pyTSEB"},"content":"The key in TSEB models is the partition of sensible heat flux into the soil and canopy layers, which depends on the soil and canopy temperatures (T_S and T_C respectively, left side of Fig. \n\n). Given the difficulty of obtaining the pure component temperatures, even with very high resolution data due to canopy gaps,\n\nNorman et al (1995) found a solution to retrieve T_S and T_C using a single observation of the directional radiometric temperature T_{rad}\\left(\\theta\\right) as this is the case for most of the remote sensing systems. Eq. \n\n(9) decomposes the composite T_{rad}\\left(\\theta\\right) temperature between its components T_S and T_C, assuming blackbody emission of thermal radiance:\\sigma T_{rad}^4\\left(\\theta\\right)=f_c\\left(\\theta\\right)\\sigma\\,T_{C}^4+\\left[1-f_{c}\\left(\\theta\\right)\\right]\\sigma\\,T_{S}^4\n\nwhere f_c\\left(\\phi\\right) is the fraction of vegetation observed by the sensor. Since \n\n(9) consists of two unknowns and only one equation, an iterative process to find H_S, T_S, H_C and T_C is defined based upon an initial guess of potential canopy transpiration, and under the assumption that during daytime hours condensation for the soil/substrate should not occur. The initial canopy latent and sensible heat fluxes are estimated based on the \n\nPriestley and Taylor (1972) formulation for potential transpiration (Eq. \n\n(10)) and Eq. \n\n(1).\\lambda E_C &= \\alpha_{PT} \\, f_g \\frac{\\Delta}{\\Delta + \\gamma}R_{n,C}\\\\\nH_C &= R_{n,C} - \\lambda E_C\n\nwhere \\alpha_{PT} is the Priestley-Taylor coefficient, initially set to 1.26, f_g is the fraction of vegetation that is green and hence capable of transpiring, \\Delta is the slope of the saturation vapour pressure versus temperature, \\gamma is the psychrometric constant. T_{C} is then computed by inverting the equation for turbulent transport of heat between the surface and the reference height above the surface)\n\nWith a first estimate of T_{C}, soil temperature is computed from Eq. \n\n(9) and then soil sensible and latent heat fluxes. At this stage, if soil latent heat flux results to be non-negative, a solution is found, otherwise the Priestley-Taylor coefficient is reduced incrementally , reducing hence the canopy transpiration, in order to avoid negative soil latent heat flux, until a realistic solution is found (no condensation occurring neither in the soil nor in the canopy in daytime).\n\nSee Also\n\nFor more details the reader is addressed to the works of \n\nNorman et al (1995) or \n\nKustas and Norman (1999)\n\nThe full code of TSEB-PT is displayed below. Note that there are two main steps:\n\nA first step that prepares all ancillary variables, such as air density, heat capacity of air..., and initializes a priori values of T_C, T_S, Ln, and G: Until line 83 in the code below.\n\nA second iterative step that consists on two nested loops:\n\nan outer loop that searches for convergence in the friction velocity and Monin-Obukhov lenght and serves to recalculate the aerodynamic resistances: From line 84 to line 234\n\nan inner loop that starts with the potential Priestley-Taylor coefficient and interatively starts being reduced for each case individually until non-negative turbulent fluxes are obtained for both canopy and soil: From line 108 to line 225\n\nNote\n\nThe outer loop regarding the recalculation of atmospheric stability factors tends to converge pretty fast under daytime/unstable conditions, but on the other hand it has difficulties in converging under stable/nighttime conditions. Therefore in pyTSEB it is set a number of maximum iterations for this loop reflectein the \n\nITERATIONS constantdef TSEB_PT(Tr_K,\n            vza,\n            T_A_K,\n            u,\n            ea,\n            p,\n            Sn_C,\n            Sn_S,\n            L_dn,\n            LAI,\n            h_C,\n            emis_C,\n            emis_S,\n            z_0M,\n            d_0,\n            z_u,\n            z_T,\n            leaf_width=0.1,\n            z0_soil=0.01,\n            alpha_PT=1.26,\n            x_LAD=1,\n            f_c=1.0,\n            f_g=1.0,\n            w_C=1.0,\n            resistance_form=None,\n            calcG_params=None,\n            const_L=None,\n            kB=KB_1_DEFAULT,\n            massman_profile=None,\n            verbose=True):\n\n    # Convert input float scalars to arrays and parameters size\n    if calcG_params is None:\n        calcG_params = [[1], 0.35]\n    if resistance_form is None:\n        resistance_form = [0, {}]\n    if massman_profile is None:\n        massman_profile = [0, []]\n\n    res_params = resistance_form[1]\n    resistance_form = resistance_form[0]\n    # calcG_params[1] = None\n    # Create the output variables\n    [Ln_S, Ln_C, H, LE, LE_C, H_C, LE_S, H_S, G, R_S, R_x, R_A, delta_Rn,\n     Rn_S, iterations] = [np.zeros(Tr_K.shape, np.float32)+np.NaN for i in range(15)]\n\n    # iteration of the Monin-Obukhov length\n    if const_L is None:\n        # Initially assume stable atmospheric conditions and set variables for\n        L = np.zeros(Tr_K.shape) + np.inf\n        max_iterations = ITERATIONS\n    else:  # We force Monin-Obukhov lenght to the provided array/value\n        L = np.ones(Tr_K.shape) * const_L\n        max_iterations = 1  # No iteration\n    # Calculate the general parameters\n    rho = met.calc_rho(p, ea, T_A_K)  # Air density\n    c_p = met.calc_c_p(p, ea)  # Heat capacity of air\n    z_0H = res.calc_z_0H(z_0M, kB=kB)  # Roughness length for heat transport\n\n    # Calculate LAI dependent parameters for dataset where LAI > 0\n    omega0 = CI.calc_omega0_Kustas(LAI, f_c, x_LAD=x_LAD, isLAIeff=True)\n    F = np.asarray(LAI / f_c, dtype=np.float32)  # Real LAI\n    # Fraction of vegetation observed by the sensor\n    f_theta = calc_F_theta_campbell(vza, F, w_C=w_C, Omega0=omega0, x_LAD=x_LAD)\n    del vza, ea\n    # Initially assume stable atmospheric conditions and set variables for\n    # iteration of the Monin-Obukhov length\n    u_friction = MO.calc_u_star(u, z_u, L, d_0, z_0M)\n    u_friction = np.asarray(np.maximum(U_FRICTION_MIN, u_friction), dtype=np.float32)\n    L_queue = deque([np.array(L, np.float32)], 6)\n    L_converged = np.zeros(Tr_K.shape, bool)\n    L_diff_max = np.inf\n\n    # First assume that canopy temperature equals the minumum of Air or\n    # radiometric T\n    T_C = np.asarray(np.minimum(Tr_K, T_A_K), dtype=np.float32)\n    flag, T_S = calc_T_S(Tr_K, T_C, f_theta)\n    T_AC = T_A_K.copy()\n\n    # Outer loop for estimating stability.\n    # Stops when difference in consecutives L is below a given threshold\n    start_time = time.time()\n    loop_time = time.time()\n    for n_iterations in range(max_iterations):\n        i = flag != F_INVALID\n        if np.all(L_converged[i]):\n            if verbose:\n                if L_converged[i].size == 0:\n                    print(\"Finished iterations with no valid solution\")\n                else:\n                    print(f\"Finished interations with a max. L diff: {L_diff_max}\")\n            break\n        current_time = time.time()\n        loop_duration = current_time - loop_time\n        loop_time = current_time\n        total_duration = loop_time - start_time\n        if verbose:\n            print(\"Iteration: %d, non-converged pixels: %d, max L diff: %f, total time: %f, loop time: %f\" %\n                  (n_iterations, np.sum(~L_converged[i]), L_diff_max, total_duration, loop_duration))\n        iterations[np.logical_and(~L_converged, flag != F_INVALID)] = n_iterations\n\n        # Inner loop to iterativelly reduce alpha_PT in case latent heat flux\n        # from the soil is negative. The initial assumption is of potential\n        # canopy transpiration.\n        flag[np.logical_and(~L_converged, flag != F_INVALID)] = F_ALL_FLUXES\n        LE_S[np.logical_and(~L_converged, flag != F_INVALID)] = -1\n        alpha_PT_rec = np.asarray(alpha_PT + 0.1, dtype=np.float32)\n        while np.any(LE_S[i] < 0):\n            i = np.logical_and.reduce((LE_S < 0, ~L_converged, flag != F_INVALID))\n\n            alpha_PT_rec[i] -= 0.1\n\n            # There cannot be negative transpiration from the vegetation\n            alpha_PT_rec[alpha_PT_rec <= 0.0] = 0.0\n            flag[np.logical_and(i, alpha_PT_rec == 0.0)] = F_ZERO_LE\n\n            flag[np.logical_and.reduce((i, alpha_PT_rec < alpha_PT, alpha_PT_rec > 0.0))] =\\\n                F_ZERO_LE_S\n\n            # Calculate aerodynamic resistances\n            R_A[i], R_x[i], R_S[i] = calc_resistances(\n                      resistance_form,\n                      {\"R_A\": {\"z_T\": z_T[i], \"u_friction\": u_friction[i], \"L\": L[i],\n                               \"d_0\": d_0[i], \"z_0H\": z_0H[i]},\n                       \"R_x\": {\"u_friction\": u_friction[i], \"h_C\": h_C[i],\n                               \"d_0\": d_0[i],\n                               \"z_0M\": z_0M[i], \"L\": L[i], \"F\": F[i], \"LAI\": LAI[i],\n                               \"leaf_width\": leaf_width[i],\n                               \"z0_soil\": z0_soil[i],\n                               \"massman_profile\": massman_profile,\n                               \"res_params\": {k: res_params[k][i] for k in res_params.keys()}},\n                       \"R_S\": {\"u_friction\": u_friction[i], \"h_C\": h_C[i],\n                               \"d_0\": d_0[i],\n                               \"z_0M\": z_0M[i], \"L\": L[i], \"F\": F[i], \"omega0\": omega0[i],\n                               \"LAI\": LAI[i], \"leaf_width\": leaf_width[i],\n                               \"z0_soil\": z0_soil[i], \"z_u\": z_u[i],\n                               \"deltaT\": T_S[i] - T_AC[i], 'u': u[i], 'rho': rho[i],\n                               \"c_p\": c_p[i], \"f_cover\": f_c[i], \"w_C\": w_C[i],\n                               \"massman_profile\": massman_profile,\n                               \"res_params\": {k: res_params[k][i] for k in res_params.keys()}}\n                       }\n            )\n\n            # Calculate net longwave radiation with current values of T_C and T_S\n            Ln_C[i], Ln_S[i] = rad.calc_L_n_Campbell(\n                T_C[i], T_S[i], L_dn[i], LAI[i], emis_C[i], emis_S[i], x_LAD=x_LAD[i])\n            delta_Rn[i] = Sn_C[i] + Ln_C[i]\n            Rn_S[i] = Sn_S[i] + Ln_S[i]\n\n            # Calculate the canopy and soil temperatures using the Priestley\n            # Taylor appoach\n            H_C[i] = calc_H_C_PT(\n                delta_Rn[i],\n                f_g[i],\n                T_A_K[i],\n                p[i],\n                c_p[i],\n                alpha_PT_rec[i])\n            T_C[i] = calc_T_C_series(Tr_K[i], T_A_K[i], R_A[i], R_x[i], R_S[i],\n                                     f_theta[i], H_C[i], rho[i], c_p[i])\n\n            # Calculate soil temperature\n            flag_t = np.zeros(flag.shape) + F_ALL_FLUXES\n            flag_t[i], T_S[i] = calc_T_S(Tr_K[i], T_C[i], f_theta[i])\n            flag[flag_t == F_INVALID] = F_INVALID\n            LE_S[flag_t == F_INVALID] = 0\n\n            # Recalculate soil resistance using new soil temperature\n            _, _, R_S[i] = calc_resistances(\n                    resistance_form,\n                    {\"R_S\": {\"u_friction\": u_friction[i], \"h_C\": h_C[i], \"d_0\": d_0[i],\n                             \"z_0M\": z_0M[i], \"L\": L[i], \"F\": F[i], \"omega0\": omega0[i],\n                             \"LAI\": LAI[i], \"leaf_width\": leaf_width[i],\n                             \"z0_soil\": z0_soil[i],  \"z_u\": z_u[i],\n                             \"deltaT\": T_S[i] - T_AC[i], \"u\": u[i], \"rho\": rho[i],\n                             \"c_p\": c_p[i], \"f_cover\": f_c[i], \"w_C\": w_C[i],\n                             \"massman_profile\": massman_profile,\n                             \"res_params\": {k: res_params[k][i] for k in res_params.keys()}}\n                     }\n            )\n\n            i = np.logical_and.reduce((LE_S < 0, ~L_converged, flag != F_INVALID))\n\n            # Get air temperature at canopy interface\n            T_AC[i] = ((T_A_K[i] / R_A[i] + T_S[i] / R_S[i] + T_C[i] / R_x[i])\n                       / (1.0 / R_A[i] + 1.0 / R_S[i] + 1.0 / R_x[i]))\n\n            # Calculate soil fluxes\n            H_S[i] = rho[i] * c_p[i] * (T_S[i] - T_AC[i]) / R_S[i]\n\n            # Compute Soil Heat Flux Ratio\n            G[i] = calc_G([calcG_params[0], calcG_array], Rn_S, i)\n\n            # Estimate latent heat fluxes as residual of energy balance at the\n            # soil and the canopy\n            LE_S[i] = Rn_S[i] - G[i] - H_S[i]\n            LE_C[i] = delta_Rn[i] - H_C[i]\n\n            # Special case if there is no transpiration from vegetation.\n            # In that case, there should also be no evaporation from the soil\n            # and the energy at the soil should be conserved.\n            # See end of appendix A1 in Guzinski et al. (2015).\n            noT = np.logical_and(i, LE_C == 0)\n            H_S[noT] = np.minimum(H_S[noT], Rn_S[noT] - G[noT])\n            G[noT] = np.maximum(G[noT], Rn_S[noT] - H_S[noT])\n            LE_S[noT] = 0\n\n            # Calculate total fluxes\n            H[i] = np.asarray(H_C[i] + H_S[i], dtype=np.float32)\n            LE[i] = np.asarray(LE_C[i] + LE_S[i], dtype=np.float32)\n            # Now L can be recalculated and the difference between iterations\n            # derived\n            if const_L is None:\n                L[i] = MO.calc_L(\n                    u_friction[i],\n                    T_A_K[i],\n                    rho[i],\n                    c_p[i],\n                    H[i],\n                    LE[i])\n                # Calculate again the friction velocity with the new stability\n                # correctios\n                u_friction[i] = MO.calc_u_star(\n                    u[i], z_u[i], L[i], d_0[i], z_0M[i])\n                u_friction[i] = np.asarray(np.maximum(U_FRICTION_MIN, u_friction[i]), dtype=np.float32)\n\n        if const_L is None:\n            # We check convergence against the value of L from previous iteration but as well\n            # against values from 2 or 3 iterations back. This is to catch situations (not\n            # infrequent) where L oscillates between 2 or 3 steady state values.\n            i, L_queue, L_converged, L_diff_max = monin_obukhov_convergence(L,\n                                                                            L_queue,\n                                                                            L_converged,\n                                                                            flag)\n\n    (flag,\n     T_S,\n     T_C,\n     T_AC,\n     L_nS,\n     L_nC,\n     LE_C,\n     H_C,\n     LE_S,\n     H_S,\n     G,\n     R_S,\n     R_x,\n     R_A,\n     u_friction,\n     L,\n     n_iterations) = map(np.asarray,\n                         (flag,\n                          T_S,\n                          T_C,\n                          T_AC,\n                          Ln_S,\n                          Ln_C,\n                          LE_C,\n                          H_C,\n                          LE_S,\n                          H_S,\n                          G,\n                          R_S,\n                          R_x,\n                          R_A,\n                          u_friction,\n                          L,\n                          iterations))\n\n    return (flag, T_S, T_C, T_AC, L_nS, L_nC, LE_C, H_C, LE_S, H_S, G, R_S, R_x, R_A, u_friction,\n            L, n_iterations)\n\nNote\n\nAlso look that the net longwave radiation is iteratively recalculated everytime in line 145, and the soil heat flux in line 192, everytime that new soil and canopy temperature are recalculated within the inner loop\n\nAdditional (optional parameters) can be set up in TSEB-PT, which are mostly related to the calulation of the different aerodynamic resistances (see lines 18, 19, and 25)\n\nWe can specify these values since we have some knowledge of the vineyard characteristics:\n\n# Initial Priestley-Taylor coefficient\nalpha_PT_0 = 1.26\n\n# Grapevine leaf width\nleaf_width = 0.10\n\n# Roughness for bare soil\nz0_soil = 0.15\n\n# Kustas and Norman boundary layer resistance parameters\nroil_resistance_c_param = 0.0038\nroil_resistance_b_param = 0.012\nroil_resistance_cprime_param = 90.\n\n# Thermal spectra\ne_v = 0.99  # Leaf emissivity\ne_s = 0.94  # Soil emissivity\n\n","type":"content","url":"/tseb-introduction#sec-h","position":25},{"hierarchy":{"lvl1":"How TSEB works?","lvl3":"run TSEB-PT","lvl2":"Implementation with actual data in pyTSEB"},"type":"lvl3","url":"/tseb-introduction#run-tseb-pt","position":26},{"hierarchy":{"lvl1":"How TSEB works?","lvl3":"run TSEB-PT","lvl2":"Implementation with actual data in pyTSEB"},"content":"Now we are almost ready to run TSEB-PT, but before we need to retrieve the most important input variable in the model, the radiometric surface temperature. We will derive a radiometric temperture at hourly timesteps using the radiance recorded by the pyrgeometer:\n\n# Surface emissivity\ne_surf = f_c * e_v + (1. - f_c) * e_s\n\n# LST from longwave radiometers\nlst = ((ec['LW_OUT'].values - (1. - e_surf) * ec['LW_IN'].values) / (\n        TSEB.rad.SB * e_surf)) ** 0.25\n\n# And it is assuming that the radiometer is looking at nadir\nvza = np.zeros_like(lst)\n\n...and we also need to especify the height of measurements of both the wind speed (z_u) and air temperature (z_t), since these to parameters are key to correctly estimate the aerodynamic roughness. These values can be obtained from the site characteristics in \n\nSite Description\n\nWarning\n\nIf you recall from the Eq. 3 of the \n\n102​-Turbulence​_and​_sensible​_heat​_flux notebook,z_u and  z_t are within a logarithmic function and thus these values should never be lower than the canopy height, with the risk otherwise to generate arithmetic errors and produce no valid data. In case of tall canopies combined with data from agrometeorological stations (usually with sensors at 2m) it is recommended to drive these values to be above the canopy.\n\n# Measurement height of wind speed\nz_u = 4  # Ripperdam 720-4\n\n# Measurement height of air temperature\nz_t = 4  # Ripperdam 720-4\n\nNow we are ready to run TSEB-PT!\n\nresistance_flag = [0, {\"KN_c\": np.full_like(lst, roil_resistance_c_param),\n                       \"KN_b\": np.full_like(lst, roil_resistance_b_param),\n                       \"KN_C_dash\": np.full_like(lst, roil_resistance_cprime_param)}]\n\n# Run TSEB-PT\n[flag_pt, ts_pt, tc_pt, t_ac_pt, ln_s_pt, ln_c_pt, le_c_pt, h_c_pt, le_s_pt, h_s_pt, g_pt,\n r_s_pt, r_x_pt, r_a_pt, u_friction_pt, lmo_pt, n_iterations_pt] = TSEB.TSEB_PT(                                                     \n     lst,\n     vza,\n     ec[\"TA\"].values,\n     ec[\"WS\"].values,\n     ec[\"EA\"].values,\n     ec[\"PA\"].values,\n     sn_c,\n     sn_s,\n     ec[\"LW_IN\"].values,\n     ec[\"LAI\"].values,\n     h_c,\n     e_v,\n     e_s,\n     z_0m,\n     d_0,\n     z_u,\n     z_t,\n     x_LAD=np.ones_like(lst),\n     f_c=f_c,\n     f_g=np.ones_like(lst),\n     w_C=w_c_ratio,\n     leaf_width=leaf_width,\n     z0_soil=z0_soil,\n     alpha_PT=alpha_PT_0,\n     resistance_form=resistance_flag,\n     calcG_params=[[1], 0.35])\n\n# ... and we compute the bulk fluxes\nle_pt = le_c_pt + le_s_pt\nh_pt = h_c_pt + h_s_pt\nnetrad_pt = sn_c + sn_s + ln_c_pt + ln_s_pt\n\n:class:dropdown\nThe codes for the different versions of TSEB are stored in the TSEB.py module of the pyTSEB GitHub repository:\n\nTSEB-PT\n\nDTD\n\nTSEB-2T\n\nTSEB-PM\n\nTSEB-SW\n\n","type":"content","url":"/tseb-introduction#run-tseb-pt","position":27},{"hierarchy":{"lvl1":"How TSEB works?","lvl2":"To finalize we compare the different retrievals"},"type":"lvl2","url":"/tseb-introduction#to-finalize-we-compare-the-different-retrievals","position":28},{"hierarchy":{"lvl1":"How TSEB works?","lvl2":"To finalize we compare the different retrievals"},"content":"Select which method of EB correction you want to apply during the validation:\n\nw_ebc = widgets.Dropdown(\n    options=[('No EB correction', (\"LE\", \"H\")), \n             ('Residual to LE', (\"LE_RES\", \"H\")), \n             ('Residual to H', (\"LE_RES\", \"H\")), \n             ('Bowen Ratio', (\"LE_BR\", \"H_BR\")),\n             ('Ensemble correction', (\"LE_ENS\", \"H_ENS\"))],\n    value=(\"LE_ENS\", \"H_ENS\"),\n    description='EBC method:',\n)\ndisplay(w_ebc)\n\nfrom model_evaluation import double_collocation as dc\nfrom tabulate import tabulate\nLE_OBS, H_OBS = w_ebc.value\nprint(f\"Using {LE_OBS} and {H_OBS} fields for validating respectively  LE and H\")\n\nle_marker = {\"color\": \"blue\", \"size\": 3}\nh_marker = {\"color\": \"red\", \"size\": 3}\ng_marker = {\"color\": \"green\", \"size\": 3}\nrn_marker = {\"color\": \"black\", \"size\": 3}\n\nfig = go.Figure()\n\nvalid_pt = np.logical_and(flag_pt < 5, daytime)\n\n\nfig.add_trace(go.Scattergl(x=netrad_pt[valid_pt], y=ec.loc[valid_pt, \"NETRAD\"], \n                         name=\"Rn TSEB-PT\", mode=\"markers\", marker=rn_marker),)\n\n\nfig.add_trace(go.Scattergl(x=g_pt[valid_pt], y=ec.loc[valid_pt, \"G\"], \n                         name=\"G TSEB-PT\", mode=\"markers\", marker=g_marker))\n\nfig.add_trace(go.Scattergl(x=le_pt[valid_pt], y=ec.loc[valid_pt, LE_OBS], \n                         name=\"LE TSEB-PT\", mode=\"markers\", marker=le_marker))\n\n\nfig.add_trace(go.Scattergl(x=h_pt[valid_pt], y=ec.loc[valid_pt, H_OBS], \n                         name=\"H TSEB-PT\", mode=\"markers\", marker=h_marker))\n\nfig.add_trace(go.Scatter(x=[-200, 800], y=[-200, 800], mode=\"lines\", name=\"1:1 line\", line={\"color\": \"black\", \"dash\": \"dash\"}))\n\nfig.update_layout(title_text=f\"Observed vs. Estimated fluxes at {site}\",\n                  yaxis_range=[-200, 800], xaxis_range=[-200, 800], \n                  xaxis_title=\"Estimated (W m-2)\", yaxis_title=\"Observed (W m-2)\")\n\n\n","type":"content","url":"/tseb-introduction#to-finalize-we-compare-the-different-retrievals","position":29},{"hierarchy":{"lvl1":"How TSEB works?","lvl4":"Evaluate the errors in H and LE","lvl2":"To finalize we compare the different retrievals"},"type":"lvl4","url":"/tseb-introduction#evaluate-the-errors-in-h-and-le","position":30},{"hierarchy":{"lvl1":"How TSEB works?","lvl4":"Evaluate the errors in H and LE","lvl2":"To finalize we compare the different retrievals"},"content":"In this last step you can evaluate the error metric for the run we just made\n\nh_pt_bias, h_pt_mae, h_pt_rmse = dc.error_metrics(ec.loc[valid_pt, H_OBS].values, h_pt[valid_pt])\nle_pt_bias, le_pt_mae, le_pt_rmse = dc.error_metrics(ec.loc[valid_pt, LE_OBS].values,le_pt[valid_pt])\n\nh_pt_cor, h_pt_p_value, h_pt_slope, h_pt_intercept, h_pt_d = dc.agreement_metrics(ec.loc[valid_pt, H_OBS].values, \n                                                                                  h_pt[valid_pt])\nle_pt_cor, le_pt_p_value, le_pt_slope, le_pt_intercept, le_pt_d = dc.agreement_metrics(ec.loc[valid_pt, LE_OBS].values, \n                                                                                       le_pt[valid_pt])\n\ntable_h = [[\"bias\", h_pt_bias, le_pt_bias],\n         [\"RMSE\", h_pt_rmse, le_pt_rmse],\n         [\"MAE\", h_pt_mae, le_pt_mae],\n         [\"Pearson\", h_pt_cor, le_pt_cor],\n         [\"Willmot's d\", h_pt_d, le_pt_d]]\nprint(\"Error metrics for TSEB-PT\")\nprint(tabulate(table_h, headers=[\"Metric\", \"H\", \"LE\"]))\n\n\n\n","type":"content","url":"/tseb-introduction#evaluate-the-errors-in-h-and-le","position":31},{"hierarchy":{"lvl1":"How TSEB works?","lvl3":"Save the results to an ASCII table","lvl2":"To finalize we compare the different retrievals"},"type":"lvl3","url":"/tseb-introduction#save-the-results-to-an-ascii-table","position":32},{"hierarchy":{"lvl1":"How TSEB works?","lvl3":"Save the results to an ASCII table","lvl2":"To finalize we compare the different retrievals"},"content":"We use again pandas as tool to easily save our outputs to a csv table\n\n# Define the output filename\nout_dir = Path().absolute() / \"output\"\noutfile = out_dir / f\"FLX_US-{site}_FLUXNET2015_TSEB-PT_HR.csv\"\n\n# Create the output folder in case it does not exist\nif not out_dir.exists():\n    out_dir.mkdir(parents=True)\n\n# Convert the outputs to a Python dictionary\noutdict = {\"TIMESTAMP\": ec[\"TIMESTAMP\"].dt.strftime(\"%Y%m%d%H%M\"),\n           \"FLAG_TSEBPT\": flag_pt, \"LE_TSEBPT\": le_pt, \"H_TSEBPT\": h_pt, \"NETRAD_TSEBPT\": netrad_pt, \"G_TSEBPT\": g_pt, \n           \"T_S_TSEBPT\": ts_pt, \"T_C_TSEBPT\": tc_pt, \"T_AC_TSEBPT\": t_ac_pt, \"LN_S_TSEBPT\": ln_s_pt, \"LN_C_TSEBPT\": ln_c_pt, \n           \"LE_C_TSEBPT\": le_c_pt, \"H_C_TSEBPT\": h_c_pt, \"LE_S_TSEBPT\": le_s_pt, \"H_S_TSEBPT\": h_s_pt, \"R_S_TSEBPT\": r_s_pt, \n           \"R_X_TSEBPT\": r_x_pt, \"R_A_TSEBPT\": r_a_pt, \"USTAR_TSEBPT\": u_friction_pt, \"L_MO_TSEBPT\":lmo_pt, \n           \"ITERATIONS_TSEBPT\": n_iterations_pt}\n\n# Crete the output dataframe and save it to csv\npd.DataFrame(outdict).to_csv(outfile, sep=\";\", na_rep=-9999, index=False)\nprint(f\"Saved to {outfile}\")\n\n","type":"content","url":"/tseb-introduction#save-the-results-to-an-ascii-table","position":33},{"hierarchy":{"lvl1":"How TSEB works?","lvl2":"Conclusions"},"type":"lvl2","url":"/tseb-introduction#conclusions","position":34},{"hierarchy":{"lvl1":"How TSEB works?","lvl2":"Conclusions"},"content":"In this notebook we learn the basics of the low level code of pyTSEB to run TSEB-PT using as input an ASCII tabulated table\n\nA very similar approach would be done for runnint TSEB-PT with an image, instead of using pandas to read a table we could use GDAL or rasterio to read the image(s) into a numpy array and parse it directly to the low level code of TSEB.\n\n[...]\n\nNote\n\nPlease feel free comment any thoughts. This is work in progress!!!\n\n\n","type":"content","url":"/tseb-introduction#conclusions","position":35},{"hierarchy":{"lvl1":"How 3SEB works?"},"type":"lvl1","url":"/seb-introduction","position":0},{"hierarchy":{"lvl1":"How 3SEB works?"},"content":"","type":"content","url":"/seb-introduction","position":1},{"hierarchy":{"lvl1":"How 3SEB works?","lvl2":"Summary"},"type":"lvl2","url":"/seb-introduction#summary","position":2},{"hierarchy":{"lvl1":"How 3SEB works?","lvl2":"Summary"},"content":"This interactive Jupyter Notebook has the objective of showing the implemenation of 3SEB-PT model in the \n\npy3SEB package.\n\n","type":"content","url":"/seb-introduction#summary","position":3},{"hierarchy":{"lvl1":"How 3SEB works?","lvl2":"Instructions"},"type":"lvl2","url":"/seb-introduction#instructions","position":4},{"hierarchy":{"lvl1":"How 3SEB works?","lvl2":"Instructions"},"content":"Read carefully all the text and follow the instructions.\n\nOnce each section is read, run the jupyter code cell underneath (marked as In []) by clicking the icon Run, or pressing the keys SHIFT+ENTER of your keyboard. A graphical interface will then display, which allows you to interact with and perform the assigned tasks.\n\nTo start, please run the following cell to import all the packages required for this notebook. Once you run the cell below, an acknowledgement message, stating all libraries were correctly imported, should be printed on screen.\n\nfrom pathlib import Path\nfrom ipywidgets import interact, interactive, fixed, widgets\nfrom IPython.display import display\nimport numpy as np\nfrom pyTSEB import TSEB\nfrom py3seb import py3seb\n\nprint('libraries imported correctly')\n\n","type":"content","url":"/seb-introduction#instructions","position":5},{"hierarchy":{"lvl1":"How 3SEB works?","lvl2":"The 3SEB model"},"type":"lvl2","url":"/seb-introduction#the-3seb-model","position":6},{"hierarchy":{"lvl1":"How 3SEB works?","lvl2":"The 3SEB model"},"content":"The 3SEB model (\n\nBurchard-Levine et al. 2022) is an adapted version of the TSEB model \n\nNorman et al. (1995), where an additional vegetation source is incorporated into TSEB to better characterize agro-ecosystems with multiple vegetation layers that have distinct structural and physiological features. This adaptation was initially envisioned for savanna-like ecosystems which are characterized by the co-existence of trees and herbaceous species with very different structural and phenological dynamics.\n\nHowever, the 3SEB model structure is also well adapted for perennial tree crops that have cover crops in the interrow, such as vineyards, olive orchards, almonds etc. In principle, the 3SEB model is more suited to represent the complex interactions between a clumped vegetation source planted in rows with an additional herbaceous vegetation source located in the interrows.\n\n\n\nFigure 1:Three-Source energy balance scheme for transport sensible heat (H). From \n\nBurchard-Levine et al. 2022\n\nIn 3SEB, the energy balance is therefore separated between the vegetation overstory (ov), vegetation understory (un) and soil (s) sources as:R_{n} & \\approx H + \\lambda E + G\\\\\n  R_{n,ov} & \\approx H_{ov} + \\lambda E_{ov}\\\\\n  R_{n,un} & \\approx H_{un} + \\lambda E_{un}\\\\\n  R_{n,s} & \\approx H_{s} + \\lambda E_{s} + G\n\nThe energy balance equations are simplified as they neglect additional components of the energy balance that are usually neglected, such as heat advection, storage of energy in the canopy layer or energy for the fixation of CO2, which are not computed by the model.\n\nAs such, Remote sensing-based Energy Balance Models rely on the ability of the radiometric information to estimate, net radiation, soil heat flux and sensible heat flux to estiamte LE or ET as the residual of the energy balance.\n\nTo see how py3SEB works we will run several pieces of code to estimate each of the components of the energy balance.\n\n","type":"content","url":"/seb-introduction#the-3seb-model","position":7},{"hierarchy":{"lvl1":"How 3SEB works?","lvl2":"Summary"},"type":"lvl2","url":"/seb-introduction#summary-1","position":8},{"hierarchy":{"lvl1":"How 3SEB works?","lvl2":"Summary"},"content":"This notebook will introduce users on how to run the three-source energy balance (3SEB) model in a vineyard site with the presence of cover crops in the interrow. The 3SEB model is more suited to represent the complex interactions between a clumped vegetation source planted in rows with an additional herbaceous vegetation source located in the interrows.\n\n\n\nFigure 2:Source elements in a vineyard with cover crop. Similar structure can be found in other perennial crops such as olive orchards, almonods, pistachio, as well as agroforestry systems and savannas.\n\nThis exercise will use the 3SEB Python implementation (\n\npy3SEB), which essentially adds an aditional vegetation source to the well-known TSEB model. The code is largely based on \n\npyTSEB.\n\nThis exercise will make use of data acquired in the context of the GRAPEX project and will replicate some of the results of the analysis performed in \n\nBurchard-Levine et al. 2022 published in Irrigation Science.\n\nFor additional information on the 3SEB model, please refer to \n\nBurchard-Levine et al. 2022, published in Global Change Biology, which introduced this model.\n\n","type":"content","url":"/seb-introduction#summary-1","position":9},{"hierarchy":{"lvl1":"How 3SEB works?","lvl2":"Running py3SEB"},"type":"lvl2","url":"/seb-introduction#running-py3seb","position":10},{"hierarchy":{"lvl1":"How 3SEB works?","lvl2":"Running py3SEB"},"content":"The first step is to open all relevant files with the necesary data and information to run 3SEB. Basically 3SEB requires the same input forcing as TSEB, and can found in \n\n./input/meteo/ folder. In addition we will also use the same time series of the daily LAI product, stored in  \n\n./input/canopy/.\n\nImportant\n\nIn the article \n\nBurchard-Levine et al. 2022, the study concentrated on the Ripperdan 720 sites. It should be noted that only Ripperdan 720-3 and 720-4 had the presence of cover crops during years 2019 and 2020\n\nTable 1:Description of GRAPEX sites\n\nSite\n\nLatitude\n\nLongitude\n\nElevation (m)\n\nRow direction (deg.)\n\nRow spacing (m)\n\nMin. height (m)\n\nMax. height (m)\n\nMin. width (m)\n\nMax. width (m)\n\nTA height (m)\n\nWS height (m)\n\nRipperdan 720-1\n\n36.849\n\n-120.176\n\n61\n\n90\n\n3.35\n\n1.2\n\n2.2\n\n0.5\n\n2.25\n\n4\n\n4\n\nRipperdan 720-2\n\n36.849\n\n-120.174\n\n61\n\n90\n\n3.35\n\n1.2\n\n2.2\n\n0.5\n\n2.25\n\n4\n\n4\n\nRipperdan 720-3\n\n36.848\n\n-120.176\n\n61\n\n90\n\n3.35\n\n1.2\n\n2.2\n\n0.5\n\n2.25\n\n4\n\n4\n\nRipperdan 720-4\n\n36.848\n\n-120.174\n\n61\n\n90\n\n3.35\n\n1.2\n\n2.2\n\n0.5\n\n2.25\n\n4\n\n4\n\nBarrelli_007\n\n38.753\n\n-122.98\n\n113\n\n135\n\n3.35\n\n1.25\n\n2.3\n\n0.5\n\n1.8\n\n4\n\n4\n\nBarrelli_012\n\n38.751369\n\n-122.974658\n\n112\n\n45\n\n3.35\n\n1.25\n\n2.3\n\n0.5\n\n1.8\n\n4.4\n\n4.4\n\nSierra Loma-north\n\n38.289338\n\n-121.117764\n\n38\n\n90\n\n3.35\n\n1.42\n\n2.25\n\n0.5\n\n2.6\n\n5\n\n5\n\nSierra Loma-south\n\n38.280488\n\n-121.117597\n\n37\n\n90\n\n3.35\n\n1-42\n\n2.25\n\n0.5\n\n2\n\n5\n\n5\n\nRipperdan 760\n\n36.839025\n\n-120.21014\n\n58\n\n90\n\n2.74\n\n1.2\n\n2.5\n\n0.5\n\n1.8\n\n5.5\n\n5\n\nBarrelli_016\n\n38.747\n\n-122.963\n\n112\n\n135\n\n3.35\n\n1.25\n\n2.3\n\n0.5\n\n1.8\n\n4\n\n4","type":"content","url":"/seb-introduction#running-py3seb","position":11},{"hierarchy":{"lvl1":"How 3SEB works?","lvl3":"Select a site","lvl2":"Running py3SEB"},"type":"lvl3","url":"/seb-introduction#select-a-site","position":12},{"hierarchy":{"lvl1":"How 3SEB works?","lvl3":"Select a site","lvl2":"Running py3SEB"},"content":"As an example, we suggest to work with data collected over Block 3 of the Ripperdam site from 2019, as this site had a cover crop present during this year. But you can select any other site for comparison.\n\nw_site = widgets.Dropdown(\n    options=[('Sierra Loma N', \"slmN\"), ('Sierra Loma S', \"slmS\"), \n             ('Barrelli 007', \"bar007\"), ('Barrelli 012', \"bar012\"),\n             ('Ripperdan 760', \"rip760\"), \n             ('Ripperdan 720-1', \"rip720_1\"),  ('Ripperdan 720-2', \"rip720_2\"),  ('Ripperdan 720-3', \"rip720_3\"),  ('Ripperdan 720-4', \"rip720_4\")],\n    value=\"rip720_3\",\n    description='Site:',\n)\ndisplay(w_site)\n\n","type":"content","url":"/seb-introduction#select-a-site","position":13},{"hierarchy":{"lvl1":"How 3SEB works?","lvl3":"We read and merge the micrometeorology and LAI tables","lvl2":"Running py3SEB"},"type":"lvl3","url":"/seb-introduction#we-read-and-merge-the-micrometeorology-and-lai-tables","position":14},{"hierarchy":{"lvl1":"How 3SEB works?","lvl3":"We read and merge the micrometeorology and LAI tables","lvl2":"Running py3SEB"},"content":"\n\n# Import Python libraries\nfrom pathlib import Path\nimport pandas as pd\n\n# Set the LAI and readiation folders\ninput_dir = Path().absolute() / \"input\"\nlai_dir = input_dir / \"canopy\"\nec_dir = input_dir / \"meteo\"\n# Set the input files based on the chosen site\nlai_filename = lai_dir / f\"FLX_US-{w_site.value}_FLUXNET2015_AUXCANOPY_DD.csv\"\nec_filename = ec_dir / f\"FLX_US-{w_site.value}_FLUXNET2015_SUBSET_HR.csv\"\nprint(f\"LAI file path is {lai_filename}\")\nprint(f\"EC file path is {ec_filename}\")\n\n# Read the LAI and radiation tables\nlai = pd.read_csv(lai_filename, sep=\";\", na_values=-9999)\nec = pd.read_csv(ec_filename, sep=\";\", na_values=-9999)\n\n# Merge both tables by date\nec[\"TIMESTAMP\"] = pd.to_datetime(ec[\"TIMESTAMP\"], format=\"%Y%m%d%H%M\")\nlai[\"DATE\"] = pd.to_datetime(lai[\"TIMESTAMP\"], format=\"%Y%m%d\").dt.date\nlai = lai.drop(labels=[\"TIMESTAMP\"], axis=1)\nec[\"DATE\"] = ec[\"TIMESTAMP\"].dt.date\nec = ec.merge(lai, on=\"DATE\")\n\n# We discard all cases at night (SW_IN <=0)\nec = ec[ec[\"SW_IN\"] > 0]\n\n# Convert Celsius to Kelvin\nec[\"TA\"] = ec[\"TA\"] + 273.15\n# Convert kPa to hPa\nec[\"PA\"] = 10 * ec[\"PA\"]\n\n# Evaluate different energy balance closure corrections\nec[\"H_RES\"] = ec[\"NETRAD\"] - ec[\"G\"] - ec[\"LE\"]\nec['LE_RES'] = ec['NETRAD'] - ec['G'] - ec['H']\nec[\"LE_BR\"], ec[\"H_BR\"] = TSEB.met.bowen_ratio_closure(ec[\"NETRAD\"], ec[\"G\"],\n                                                       ec[\"H\"], ec[\"LE\"])\n# Mean of uncorrected, ressidual and Bowen Ratio\nec[\"H_ENS\"] = np.nanmean([ec[\"H_RES\"], ec[\"H_BR\"], ec['H']], axis=0)\nec[\"LE_ENS\"] = np.nanmean([ec[\"LE_RES\"], ec[\"LE_BR\"], ec['LE']], axis=0)\n\n","type":"content","url":"/seb-introduction#we-read-and-merge-the-micrometeorology-and-lai-tables","position":15},{"hierarchy":{"lvl1":"How 3SEB works?","lvl3":"Site Description","lvl2":"Running py3SEB"},"type":"lvl3","url":"/seb-introduction#site-description","position":16},{"hierarchy":{"lvl1":"How 3SEB works?","lvl3":"Site Description","lvl2":"Running py3SEB"},"content":"Here we initialize relevant information related to the site characteristics including geographical position (lat/lon) and vineyard row direction/dimensions\n\nimport yaml\nyaml_file = input_dir / \"site_description.yaml\"\nsite_dict = yaml.safe_load(yaml_file.read_text())\nlat = float(site_dict[\"lat\"][w_site.value])\nlon = float(site_dict[\"lon\"][w_site.value])\nelev = float(site_dict[\"elev\"][w_site.value])\nrow_direction = float(site_dict[\"row_direction\"][w_site.value])\ninterrow = float(site_dict[\"interrow\"][w_site.value])\nhc_min = float(site_dict[\"hc_min\"][w_site.value])\nhc_max = float(site_dict[\"hc_max\"][w_site.value])\nwc_min = float(site_dict[\"wc_min\"][w_site.value])\nwc_max = float(site_dict[\"wc_max\"][w_site.value])\nzh = float(site_dict[\"zh\"][w_site.value])\nzm = float(site_dict[\"zm\"][w_site.value])\n\nprint(f\"{w_site.label} has the following site characteristics:\\n\"\n      f\"\\t Latitude: {lat} deg. \\n\"\n      f\"\\t Longitude: {lon} deg. \\n\"\n      f\"\\t Elevation: {elev} m \\n\"\n      f\"\\t Row direction: {row_direction} deg. \\n\"\n      f\"\\t Row spacing: {interrow} m \\n\"\n      f\"\\t Min. canopy height: {hc_min} m \\n\"\n      f\"\\t Max. canopy height: {hc_max} m \\n\"\n      f\"\\t Min. canopy width: {wc_min} m \\n\"\n      f\"\\t Max. canopy width: {wc_max} m \\n\"\n      f\"\\t Air temperature measurement height: {zh} m \\n\"\n      f\"\\t Wind speed temperature measurement height: {zh} m\")\n\n","type":"content","url":"/seb-introduction#site-description","position":17},{"hierarchy":{"lvl1":"How 3SEB works?","lvl3":"Estimate vegetation traits","lvl2":"Running py3SEB"},"type":"lvl3","url":"/seb-introduction#estimate-vegetation-traits","position":18},{"hierarchy":{"lvl1":"How 3SEB works?","lvl3":"Estimate vegetation traits","lvl2":"Running py3SEB"},"content":"","type":"content","url":"/seb-introduction#estimate-vegetation-traits","position":19},{"hierarchy":{"lvl1":"How 3SEB works?","lvl4":"Separation of grapevine and cover crop LAI","lvl3":"Estimate vegetation traits","lvl2":"Running py3SEB"},"type":"lvl4","url":"/seb-introduction#separation-of-grapevine-and-cover-crop-lai","position":20},{"hierarchy":{"lvl1":"How 3SEB works?","lvl4":"Separation of grapevine and cover crop LAI","lvl3":"Estimate vegetation traits","lvl2":"Running py3SEB"},"content":"3SEB has very similar data requirements to TSEB but a key distinction is the need to separate biophsyical properties for the two vegetation sources, in this case the grapevine and cover crop. There is no general formula to separate or unmix LAI from the different vegetation sources, there are potentially many differnt methods that can be used.\n\nIn this exercise, we will exploit the fact the grapevines and cover crops have different phenological dynamics and we will use this to separate the total LAI values into each component as described in \n\nBurchard-Levine et al. 2022\n\nThe daily ecosystem LAI were acquired over each tower footprint at 30 m resolution by merging satellite data from the Harmonized Landsat and Sentinel-2 (HLS) surface reflectance and MODIS LAI data product together with in situ LAI measurements \n\nKang et al. 2022. The LAI over each tower footprint was extracted from 3 × 3 30 m pixels, thus including vine and cover crop (CC) contributions.\n\nThe CC normally has a growing phase during early spring and then is mowed in early summer becoming senescent stubble during the main grapevine growing period between May and August. Therefore, the CC LAI (LAI_{cc}) was assumed to contribute completely to the total ecosystem LAI (LAI_{eco}) before the vine bud-break (~spring) and after vine leaf-off during the fall. The LAI_{cc} was simulated to exponentially decay from spring until the peak summer period and then exponentially re-grow during the fall period after the vine leaf-off from \n\nFigure 3.\n\n\n\nFigure 3:Time series of ecosystem LAI (LAIeco) from satellite imagery (Kang et al., 2022) from block 3 of 2019 decomposed into vine (LAIvine) and cover crop (LAIcc) LAI based on seasonal dynamics. Source: \n\nBurchard-Levine et al. (2022)\n\nSeasonal transitions dates were corroborated with in situ phenocam data. Subsequently, LAIcc was subtracted from the ecosystem LAI to obtain vine LAI (LAIvine)LAI_{vine} = LAI_{eco} - LAI_{cc}\n\nFor simplicity, we use DOY = 117 (end of April) for the bud break date each site and years  but the phenological dates will likely differ for each year and site.","type":"content","url":"/seb-introduction#separation-of-grapevine-and-cover-crop-lai","position":21},{"hierarchy":{"lvl1":"How 3SEB works?","lvl4":"Set key seasonal transition dates","lvl3":"Estimate vegetation traits","lvl2":"Running py3SEB"},"type":"lvl4","url":"/seb-introduction#set-key-seasonal-transition-dates","position":22},{"hierarchy":{"lvl1":"How 3SEB works?","lvl4":"Set key seasonal transition dates","lvl3":"Estimate vegetation traits","lvl2":"Running py3SEB"},"content":"\n\n# Set key seasonal transitions (DOY) obtained from phenocam\nbud_break = 117\nspring_start = 121\nsummer_end = 330\n# set a minimum of cover crop LAI \nlai_cc_min = 0.2  # do not set to 0 or very low values. This will make model unstable due to equations that use LAI in denominator i.e. Rx\n\n# get day of year array\ndoy = ec['TIMESTAMP'].dt.dayofyear\n\nmid_summer = int((spring_start + summer_end) / 2)\ncc_senescence = int((spring_start + mid_summer) / 2)\ncc_regrowth = int((mid_summer + summer_end) / 2)\n\n\n","type":"content","url":"/seb-introduction#set-key-seasonal-transition-dates","position":23},{"hierarchy":{"lvl1":"How 3SEB works?","lvl4":"Simulate growth and decay of cover crop during seasonal transitions periods","lvl3":"Estimate vegetation traits","lvl2":"Running py3SEB"},"type":"lvl4","url":"/seb-introduction#simulate-growth-and-decay-of-cover-crop-during-seasonal-transitions-periods","position":24},{"hierarchy":{"lvl1":"How 3SEB works?","lvl4":"Simulate growth and decay of cover crop during seasonal transitions periods","lvl3":"Estimate vegetation traits","lvl2":"Running py3SEB"},"content":"Using the aproximate DOYs of the seasonal transition periods, we will simulate the senescence of the cover crop as the summer begins (i.e. between start of summer and end of summer)using a logarithmic decay function for both LAI and green fraction. The same will be done for the autumn regrowth period for each year.\n\n# =======================================\n# Simulate growth/decay of cover crop\n# =======================================\n\n#initialize LAI/fg vine and LAI/fg CC\nlai_cc = np.full_like(ec['LAI'].values, lai_cc_min)\nfg_cc = np.ones_like(ec['LAI'].values)\n\n# --- before vine bud-break\n# before bud-break all LAI is atributed to cover crop (CC)\nlai_cc[doy <= bud_break] = ec['LAI'].values[doy <= bud_break]\n\n# --- cover crop decay\n# When vine bud breaks, exponential decay until mid summer period\n# mid summer period cover crop is as minimum\n\n# do it for each year \nfor year in np.unique(ec['TIMESTAMP'].dt.year):\n    bud_break = bud_break_dict[year]\n    year_mask = ec['TIMESTAMP'].dt.year == year\n    doy_year = doy[year_mask]\n    lai_cc_year = lai_cc[year_mask]\n    fg_cc_year = fg_cc[year_mask]\n    lai_year = ec['LAI'].values[year_mask]\n\n    ### get doy array associated with cover crop decay\n    decay_mask = np.logical_and(doy_year > bud_break, doy_year < mid_summer)\n    doy_decay = doy_year[decay_mask]\n    ## simulate exponetnial decay during senescence\n    if year == 2018:\n        lai_cc_decay = np.logspace(np.log(lai_year[doy_year == doy_year.values[0]][0]), np.log(lai_cc_min),doy_decay.size, base=np.exp(1))\n    else:\n        lai_cc_decay = np.logspace(np.log(lai_cc_year[doy_year == bud_break][0]), np.log(lai_cc_min),doy_decay.size, base=np.exp(1))\n        \n    lai_cc_year[decay_mask] = lai_cc_decay\n    \n    # do same for green fraction \n    fg_cc_decay = np.logspace(np.log(1), np.log(0.01), doy_decay.size, base=np.exp(1))\n    fg_cc_year[decay_mask] = fg_cc_decay\n    \n    # --- autumn regrowth\n    \n    #autumn regrowth (and vine leaf off)\n    regrow_mask = np.logical_and(doy_year > cc_regrowth, doy_year <= summer_end)\n    doy_regrow = doy_year[regrow_mask]\n    # simulate exponential growth during autumn regrowth\n    lai_cc_regrow = np.logspace(np.log(lai_cc_year[doy_year == cc_regrowth][0]), np.log(lai_year[doy_year==summer_end][0]),doy_regrow.size, base=np.exp(1))\n    lai_cc_year[regrow_mask] = lai_cc_regrow\n    \n    # same for green fraction \n    \n    fg_cc_regrow = np.logspace(np.log(0.01), np.log(1), doy_regrow.size, base=np.exp(1))\n    fg_cc_year[regrow_mask] = fg_cc_regrow\n    fg_cc_year[np.logical_and(doy_year >= mid_summer, doy_year <= cc_regrowth)] = 0.01\n    \n    # ---post-autumn/winter\n    \n    # all LAI is CC after summer\n    lai_cc_year[doy_year>summer_end] = lai_year[doy_year>summer_end]\n\n    # now save yearly time series to full time series\n    lai_cc[year_mask] = lai_cc_year\n    fg_cc[year_mask] = fg_cc_year\n    \nprint('Done!')\n\n","type":"content","url":"/seb-introduction#simulate-growth-and-decay-of-cover-crop-during-seasonal-transitions-periods","position":25},{"hierarchy":{"lvl1":"How 3SEB works?","lvl4":"Grapevine LAI","lvl3":"Estimate vegetation traits","lvl2":"Running py3SEB"},"type":"lvl4","url":"/seb-introduction#grapevine-lai","position":26},{"hierarchy":{"lvl1":"How 3SEB works?","lvl4":"Grapevine LAI","lvl3":"Estimate vegetation traits","lvl2":"Running py3SEB"},"content":"We then obtain grapvine LAI as the difference between ecosystem-level LAI (i.e. Satellite data from the Harmonized Landsat and Sentinel-2 (HLS) surface reflectance and MODIS LAI data product) and the cover crop LAI simulated above. Here we assume the grapevine green fraction maintains at 1 throughout the seasonal period.\n\n# =======================================\n# Get grapevine LAI/fg\n# =======================================\n\n#get LAI vine but suctracting LAIcc from LAI\nlai_vine = ec['LAI'].values - lai_cc\n# set minimum of LAI to 0.4 (taking into account branches/trunk effect)\nlai_vine[lai_vine<0.4] = 0.4\nfg_vine = np.full_like(lai_vine, 1)\nprint('Done!')\n\n","type":"content","url":"/seb-introduction#grapevine-lai","position":27},{"hierarchy":{"lvl1":"How 3SEB works?","lvl5":"Visualize LAI partitioning","lvl4":"Grapevine LAI","lvl3":"Estimate vegetation traits","lvl2":"Running py3SEB"},"type":"lvl5","url":"/seb-introduction#visualize-lai-partitioning","position":28},{"hierarchy":{"lvl1":"How 3SEB works?","lvl5":"Visualize LAI partitioning","lvl4":"Grapevine LAI","lvl3":"Estimate vegetation traits","lvl2":"Running py3SEB"},"content":"\n\nfrom plotly.subplots import make_subplots\nimport plotly.graph_objects as go\nfig = make_subplots(specs=[[{\"secondary_y\": True}]])\nfig.add_trace(go.Scatter(x=ec[\"TIMESTAMP\"].values, y=ec['LAI'].values, \n                         name=\"Total LAI\", mode=\"lines\", line={\"color\": \"black\"}))\n\nfig.add_trace(go.Scatter(x=ec[\"TIMESTAMP\"].values, y=lai_cc, \n                         name=\"Cover crop LAI\", mode=\"lines\", line={\"color\": \"green\"}))\nfig.add_trace(go.Scatter(x=ec[\"TIMESTAMP\"].values, y=lai_vine, \n                         name=\"Grapevine LAI\", mode=\"lines\", line={\"color\": \"red\"}))\nfig.add_trace(go.Scatter(x=ec[\"TIMESTAMP\"].values, y=fg_cc, \n                         name=\"Cover crop green fraction\", mode=\"lines\", line={\"color\": \"green\", \"dash\": \"dot\"}),\n              secondary_y=True)\nfig.update_layout(title_text=f\"LAI partition at {w_site.label}\",\n                  xaxis_title=\"Date\", yaxis_title=\"LAI\")\n\n","type":"content","url":"/seb-introduction#visualize-lai-partitioning","position":29},{"hierarchy":{"lvl1":"How 3SEB works?","lvl3":"Estimate the structural variables based on Earth Observation LAI timeseries","lvl2":"Running py3SEB"},"type":"lvl3","url":"/seb-introduction#estimate-the-structural-variables-based-on-earth-observation-lai-timeseries","position":30},{"hierarchy":{"lvl1":"How 3SEB works?","lvl3":"Estimate the structural variables based on Earth Observation LAI timeseries","lvl2":"Running py3SEB"},"content":"The structural traits for the vineyard, such as canopy height (hc) and fractional cover (fc), are estimated from empirical equations developed for this site as described in \n\nNieto et al. (2018). For canopy height and fractional cover, we used the same empirical equations as in previous exercises.\n\n\n\nFigure 2:Empirical models relating canopy height , canopy width and the bottom of the canopy with the fused STARFM LAI. Solid dots represent in situ measured values\n\nNote\n\nStructural traits could also be prescribed based on a land cover map or, even better with LiDAR/PhoDAR information\n\n################################################################################\n# Empirical equations to generate canopy structural parameters from LAI\n################################################################################\ndef lai_2_hc(lai, hc_min):\n    slope = 0.42\n    hc = hc_min + slope * lai\n    return hc\n\n\ndef lai_2_hbratio(lai, hc_min):\n    hb_ratio_mean = 0.4848388065\n    hb_ratio = np.zeros(lai.shape)\n\n    hb_ratio[lai < hc_min] = 1. + ((hb_ratio_mean - 1.) / hc_min) * lai[\n        lai < hc_min]\n    hb_ratio[lai >= hc_min] = hb_ratio_mean\n\n    return hb_ratio\n\n\ndef lai_2_width(lai, wc_min, wc_max):\n    beta = 6.96560056\n    offset = 1.70825736\n\n    width = wc_min + (wc_max - wc_min) / (1.0 + np.exp(-beta * (lai - offset)))\n\n    return width\n\n\ndef lai_2_fcover(lai, fc_min, fc_max):\n    beta = 7.0\n    offset = 1.70\n\n    fcover = fc_min + (fc_max - fc_min) / (1.0 + np.exp(-beta * (lai - offset)))\n\n    return fcover\n\n\ndef lai_2_canopy(lai, hc_min, fc_min, fc_max):\n    hc = lai_2_hc(lai, hc_min)\n    hb_ratio = lai_2_hbratio(lai, hc_min)\n    fcover = lai_2_fcover(lai, fc_min, fc_max)\n\n    return hc, hb_ratio, fcover\n\n\n# Grapevine height\nh_c_vine, hb_ratio_vine, f_c_vine = lai_2_canopy(lai_vine, hc_min, wc_min / interrow, wc_max / interrow)\n# clip to maximum and minimum possible\nh_c_vine = np.clip(h_c_vine, hc_min, hc_max)\nf_c_vine = np.clip(f_c_vine, 0, 1)\n\nand for the herbaceous cover crop we assume a constant canopy height and full coverage\n\n# Crop height\nh_c_cc = 0.35\nh_c_cc = np.full_like(h_c_vine, h_c_cc)\n# Crop coverage\nf_c_cc = np.ones_like(h_c_vine)\n# Crop width to height ratio\nw_c_cc = np.ones_like(h_c_vine)\nw_c_ratio_cc = np.ones_like(h_c_vine)\n\n","type":"content","url":"/seb-introduction#estimate-the-structural-variables-based-on-earth-observation-lai-timeseries","position":31},{"hierarchy":{"lvl1":"How 3SEB works?","lvl3":"Estimate vegetation clumping index","lvl2":"Running py3SEB"},"type":"lvl3","url":"/seb-introduction#estimate-vegetation-clumping-index","position":32},{"hierarchy":{"lvl1":"How 3SEB works?","lvl3":"Estimate vegetation clumping index","lvl2":"Running py3SEB"},"content":"Since grapevine canopies are highly clumped and have unique row structures, we will take into account row structure and orientation to calculate the clumping index, which is important when modelling the radiation transmission through the canopy.\n\n# =======================================\n# Grapevine width\nw_c_vine = f_c_vine * interrow\n# Grapevine width to height ratio\nw_c_ratio_vine = w_c_vine / (h_c_vine - hb_ratio_vine * h_c_vine)\n# Grapevine Local LAI\nF_vine = lai_vine / f_c_vine\n\n# The time zone is PST, which corresponds to -120 deg, time longitude\nstdlon = -120\n# Call calc_sun_angles based on site coordinates and timestamp\nsza, saa = TSEB.met.calc_sun_angles(\n    np.full_like(ec['LAI'].values, lat),\n    np.full_like(ec[\"LAI\"].values, lon),\n    np.full_like(ec[\"LAI\"].values, stdlon),\n    ec['TIMESTAMP'].dt.dayofyear.values,\n    ec['TIMESTAMP'].dt.hour.values + ec['TIMESTAMP'].dt.minute.values / 60.)\n\n# Compute the relative sun-row azimuth angle\npsi = row_direction - saa\n# Compute the clumping index for row crops\nomega_vine = TSEB.CI.calc_omega_rows(lai_vine, f_c_vine, theta=sza, psi=psi, w_c=w_c_ratio_vine, x_lad=1)\n# effective lai\nlai_eff_vine = F_vine * omega_vine\n\nOn the other hand, for the cover crop we can assume that it is horizontally homogeneous and non-clumped\n\n","type":"content","url":"/seb-introduction#estimate-vegetation-clumping-index","position":33},{"hierarchy":{"lvl1":"How 3SEB works?","lvl3":"Estimate net radiation transfer through the three sources","lvl2":"Running py3SEB"},"type":"lvl3","url":"/seb-introduction#estimate-net-radiation-transfer-through-the-three-sources","position":34},{"hierarchy":{"lvl1":"How 3SEB works?","lvl3":"Estimate net radiation transfer through the three sources","lvl2":"Running py3SEB"},"content":"We use a beer-lambert (-type) modeling scheme to simulate the radiation transmission through the multiple vegetation canopies adapted from the model described in \n\nChapter 15 of Campbell and Norman (1998).\n\nSee Also\n\nThe full description of the radiation model can be found in \n\nCampbell and Norman, 1998, Chapter 15 and the deatils regarding the adaption to three sources is found in the supplementary information in \n\nBurchard-Levine et al. 2022\n\nfrom py3seb import py3seb\n\n# We need to define the leaf spectral properties for grapevine and cover crop. For simplicity we can just replicate the same values for both\nrho_leaf_vis_vine = 0.054\nrho_leaf_vis_cc = 0.054\nrho_leaf_nir_vine = 0.262\nrho_leaf_nir_cc = 0.262\ntau_leaf_vis_vine = 0.038\ntau_leaf_vis_cc = 0.038\ntau_leaf_nir_vine = 0.333\ntau_leaf_nir_cc = 0.333\nrho_soil_vis = 0.07\nrho_soil_nir = 0.32\n\n# Thermal spectra\ne_vine = 0.99  # Leaf emissivity\ne_cc = 0.99  # Leaf emissivity\ne_s = 0.94  # Soil emissivity\n\n# Estimates the direct and diffuse solar radiation\ndifvis, difnir, fvis, fnir = TSEB.rad.calc_difuse_ratio(ec[\"SW_IN\"].values,\n                                                        sza,\n                                                        press=np.full_like(sza, 1013.15))\npar_dir = fvis * (1. - difvis) * ec[\"SW_IN\"].values\nnir_dir = fnir * (1. - difnir) * ec[\"SW_IN\"].values\npar_dif = fvis * difvis * ec[\"SW_IN\"].values\nnir_dif = fnir * difnir * ec[\"SW_IN\"].values\n\n# net radiation transmission through the three sources\nsn_vine_3seb, sn_s_3seb, sn_cc_3seb = py3seb.calc_Sn_Campbell(lai_vine, \n                                                              lai_cc, \n                                                              sza, \n                                                              par_dir + nir_dir, \n                                                              par_dif + nir_dif, \n                                                              fvis, \n                                                              fnir,\n                                                              np.full_like(lai_vine, rho_leaf_vis_vine),\n                                                              np.full_like(lai_cc, rho_leaf_vis_cc),\n                                                              np.full_like(lai_vine, tau_leaf_vis_vine),\n                                                              np.full_like(lai_cc, tau_leaf_vis_cc),\n                                                              np.full_like(lai_vine, rho_leaf_nir_vine),\n                                                              np.full_like(lai_cc, rho_leaf_nir_cc),\n                                                              np.full_like(lai_vine, tau_leaf_nir_vine),\n                                                              np.full_like(lai_vine, tau_leaf_nir_cc),\n                                                              np.full_like(lai_vine, rho_soil_vis),\n                                                              np.full_like(lai_vine, rho_soil_nir), \n                                                              h_c_vine, \n                                                              h_c_vine * hb_ratio_vine, \n                                                              w_c_vine, \n                                                              f_c_vine,\n                                                              x_LAD=1, \n                                                              x_LAD_sub=1, \n                                                              LAI_eff=lai_eff_vine,\n                                                              LAI_eff_sub=lai_cc)\n\nsn_vine_3seb[~np.isfinite(sn_vine_3seb)] = 0\nsn_s_3seb[~np.isfinite(sn_s_3seb)] = 0\nsn_cc_3seb[~np.isfinite(sn_cc_3seb)] = 0\nprint('Done!')\n\n","type":"content","url":"/seb-introduction#estimate-net-radiation-transfer-through-the-three-sources","position":35},{"hierarchy":{"lvl1":"How 3SEB works?","lvl4":"Evaluate net shortwave radiation","lvl3":"Estimate net radiation transfer through the three sources","lvl2":"Running py3SEB"},"type":"lvl4","url":"/seb-introduction#evaluate-net-shortwave-radiation","position":36},{"hierarchy":{"lvl1":"How 3SEB works?","lvl4":"Evaluate net shortwave radiation","lvl3":"Estimate net radiation transfer through the three sources","lvl2":"Running py3SEB"},"content":"\n\nfrom model_evaluation import double_collocation as dc\ndaytime = ec[\"SW_IN\"] > 100\n\nsn_3seb = sn_vine_3seb + sn_s_3seb + sn_cc_3seb\nsn_obs = ec[\"SW_IN\"].values - ec[\"SW_OUT\"].values\n\nfig = go.Figure()\nfig.add_trace(go.Scattergl(x=sn_3seb[daytime], y=sn_obs[daytime], \n                         name=\"Sn for row crops\", mode=\"markers\"))\nfig.add_trace(go.Scatter(x=[0, 1000], y=[0, 1000], mode=\"lines\", name=\"1:1 line\", line={\"color\": \"black\", \"dash\": \"dash\"}))\nfig.update_layout(title_text=f\"Observed vs. Estimated below net radiation at {w_site.label}\",\n                  yaxis_range=[0, 1000], xaxis_range=[0, 1000],\n                  xaxis_title=\"Estimated (W m-2)\", yaxis_title=\"Observed (W m-2)\")\n\n","type":"content","url":"/seb-introduction#evaluate-net-shortwave-radiation","position":37},{"hierarchy":{"lvl1":"How 3SEB works?","lvl3":"Estimate surface roughness","lvl2":"Running py3SEB"},"type":"lvl3","url":"/seb-introduction#estimate-surface-roughness","position":38},{"hierarchy":{"lvl1":"How 3SEB works?","lvl3":"Estimate surface roughness","lvl2":"Running py3SEB"},"content":"We estimate surface roughness using the same frameworks as implemented in TSEB (see ./103-TSEB_introduction.ipynb).\n\nFor tall and woody canopies, in which leaf density and coverage can play a more importan role, pyTSEB can adopt the formulation of Schaudt and Dickinson (2000), which at the same time it relies on the model by [Raupach (1994))(\n\nRaupach (1994))\n\nSince vineyards can be considered as open shrublands or short decidous broadleaved canopies, we will compute roughness based on Schaudt and Dickinson (2000). As inputs we need not only the canopy height, but also the LAI, the fractional cover and the width-to-height canopy ratio\n\nIn the case of 3SEB, we need to estimate the roughness for the overstory vegetation (i.e. grapevine) and the understory vegetation (i.e. cover crop). For the cover crop, we assume herbecaous conditions so we simple use canophy height ratio approach.\n\n# Roughness for bare soil\nz0_soil = 0.15\n\n# grapevine\n# =========\nz_0m_vine, d_0_vine = TSEB.res.calc_roughness(lai_vine, h_c_vine, w_c_ratio_vine,\n                                              np.ones(lai_vine.shape) * TSEB.res.BROADLEAVED_D,\n                                              f_c=f_c_vine)\n# Ensure realistic values\nd_0_vine[d_0_vine < 0] = 0\nz_0m_vine[np.isnan(z_0m_vine)] = z0_soil\nz_0m_vine[z_0m_vine < z0_soil] = z0_soil\n\n# cover crop\n# ==========\nz_0m_cc, d_0_cc = TSEB.res.calc_roughness(lai_cc, h_c_cc, w_c_ratio_cc,\n                                          np.ones(lai_cc.shape) * TSEB.res.GRASS,\n                                          f_c=f_c_cc)\n\n# Ensure realistic values\nd_0_cc[d_0_cc < 0] = 0\nz_0m_cc[np.isnan(z_0m_cc)] = z0_soil\nz_0m_cc[z_0m_cc < z0_soil] = z0_soil\nprint('Done!')\n\n","type":"content","url":"/seb-introduction#estimate-surface-roughness","position":39},{"hierarchy":{"lvl1":"How 3SEB works?","lvl3":"TSEB/3SEB processing options and model parameters","lvl2":"Running py3SEB"},"type":"lvl3","url":"/seb-introduction#tseb-3seb-processing-options-and-model-parameters","position":40},{"hierarchy":{"lvl1":"How 3SEB works?","lvl3":"TSEB/3SEB processing options and model parameters","lvl2":"Running py3SEB"},"content":"In this section, we set-up some processing options related to how we want to run 3SEB, including assigning some values to constant ancillary parameters. These are the same as those set-up to run pyTSEB but again we need to specify the parameters for each vegetaion layer.\n\nalpha_PT_0 = 1.26\n\n# Grapevine and cover crop leaf width (m)\nleaf_width_vine = 0.10\nleaf_width_cc = 0.01\n\n# Kustas and Norman boundary layer resistance parameters\nroil_resistance_c_param = 0.0038\nroil_resistance_b_param = 0.012\nroil_resistance_cprime_param = 90.\n\n# Thermal spectra\ne_v = 0.99  # Leaf vine emissivity\ne_cc = 0.99   # Leaf crop emissivity\ne_s = 0.94  # Soil emissivity\n\n","type":"content","url":"/seb-introduction#tseb-3seb-processing-options-and-model-parameters","position":41},{"hierarchy":{"lvl1":"How 3SEB works?","lvl3":"We derive the half-hourly LST based on pyrgeomters on the EC tower","lvl2":"Running py3SEB"},"type":"lvl3","url":"/seb-introduction#we-derive-the-half-hourly-lst-based-on-pyrgeomters-on-the-ec-tower","position":42},{"hierarchy":{"lvl1":"How 3SEB works?","lvl3":"We derive the half-hourly LST based on pyrgeomters on the EC tower","lvl2":"Running py3SEB"},"content":"\n\n# Surface emissivity\ne_surf = f_c_vine * e_v + (1. - f_c_vine) * e_s\n\n# LST from longwave radiometers\nlst = ((ec['LW_OUT'].values - (1. - e_surf) * ec['LW_IN'].values) / (\n        TSEB.rad.SB * e_surf)) ** 0.25\n\n# And it is assuming that the radiometer is looking at nadir\nvza = np.zeros_like(lst)\n\n","type":"content","url":"/seb-introduction#we-derive-the-half-hourly-lst-based-on-pyrgeomters-on-the-ec-tower","position":43},{"hierarchy":{"lvl1":"How 3SEB works?","lvl2":"Computing Sensible heat flux with 3SEB"},"type":"lvl2","url":"/seb-introduction#computing-sensible-heat-flux-with-3seb","position":44},{"hierarchy":{"lvl1":"How 3SEB works?","lvl2":"Computing Sensible heat flux with 3SEB"},"content":"The key distinction of 3SEB is that we need to separate sensible heat fluxes between vegetation overstory, understory and soil layers. All this, using the the radiometric land surface temperature (LST) derived from remote sensing as the key boundary condition. It is assumed that the singular LST observation is the combination of signals stemming from all three sources such as :LST =(f_{ov}\\left(\\theta\\right)T_{ov}^4+\\left[1-f_{ov}\\left(\\theta\\right)\\right]T_{sub}^4)^{1/4}\\\\\n\n\\\\T_{sub} =(f_{un}\\left(\\theta\\right)T_{un}^4+\\left[1-f_{un}\\left(\\theta\\right)\\right]T_{s}^4)^{1/4}\\\\\n\nwhere f_c\\left(\\theta\\right) is the fraction of vegetation observed by the sensor (either for understory (un) and overstory (ov)). Since the above equations consists of three unknowns and only two equations, an iterative process is conducted using to initial guesses of potential canopy transpiration for both vegetation sources, and under the assumption that during daytime hours condensation for the soil/substrate should not occur. The initial canopy latent and sensible heat fluxes are estimated based on the \n\nPriestley and Taylor (1972) formulation for potential transpiration (Eq. \n\n(10)) and Eq. \n\n(1).\n\nIn 3SEB, resistance framework is first treated as a parallel (i.e., uncoupled) tree-substrate system to obtain tree canopy sensible heat flux (H_C) and substrate (understory vegetation+soil) (H_{sub}) using the heat transport equations:H_C &= \\rho C_p \\frac{T_C - T_{a}} {R_A}\\\\\nH_{sub} &= \\rho C_p \\frac{T_{sub} - T_{a}} {R_A+R_{sub}}\n\nSubsequently, the substrate fluxes and temperatures are further separated incorporating a series (i.e. coupled) approach:H_{C,sub} &= \\rho C_p \\frac{T_{C,sub} - T_{ac}} {R_X}\\\\\nH_s &= \\rho C_p \\frac{T_S - T_{ac}} {R_S}\n\nSince T_C, T_{C,sub} and T_S are unknown apriori, the original 3SEB formulation (3SEB-PT) implements a Priestley-Taylor (PT) formulation, as in \n\nNorman et al. (1995), to compute a first estimate of the canopy LE and H for both overstory and understory.\n\n","type":"content","url":"/seb-introduction#computing-sensible-heat-flux-with-3seb","position":45},{"hierarchy":{"lvl1":"How 3SEB works?","lvl3":"Run 3SEB","lvl2":"Computing Sensible heat flux with 3SEB"},"type":"lvl3","url":"/seb-introduction#run-3seb","position":46},{"hierarchy":{"lvl1":"How 3SEB works?","lvl3":"Run 3SEB","lvl2":"Computing Sensible heat flux with 3SEB"},"content":"We are now finally ready to run 3SEB\n\nSee Also\n\nThe full code for 3SEB model at the \n\n3SEB GitHub repository\n\nresistance_flag = [0, {\"KN_c\": np.full_like(lst, roil_resistance_c_param),\n                       \"KN_b\": np.full_like(lst, roil_resistance_b_param),\n                       \"KN_C_dash\": np.full_like(lst, roil_resistance_cprime_param)}]\n\n# Run 3SEB\n[flag_3seb, t_s_3seb, t_vine_3seb, t_cc_3seb, t_ac_3seb, ln_sub_3seb, ln_vine_3seb, \n ln_cc_3seb, ln_s_3seb, le_vine_3seb, h_vine_3seb, le_cc_3seb, h_cc_3seb,\n le_s_3seb, h_s_3seb, g_3seb, r_s_3seb, r_sub_3seb, r_x_3seb, r_a_3seb, u_friction_3seb, \n l_mo_3seb, n_iterations_3seb] = py3seb.ThreeSEB_PT(lst,\n                                                    vza,\n                                                    ec[\"TA\"].values,\n                                                    ec[\"WS\"].values,\n                                                    ec[\"EA\"].values,\n                                                    ec[\"PA\"].values,\n                                                    sn_vine_3seb,\n                                                    sn_s_3seb,\n                                                    sn_cc_3seb,\n                                                    ec[\"LW_IN\"].values,\n                                                    lai_vine,\n                                                    lai_cc,\n                                                    h_c_vine,\n                                                    h_c_cc,\n                                                    e_vine,\n                                                    e_cc,\n                                                    e_s,\n                                                    z_0m_vine,\n                                                    z_0m_cc,\n                                                    d_0_vine,\n                                                    d_0_cc,\n                                                    zm,\n                                                    zh,\n                                                    leaf_width=leaf_width_vine,\n                                                    leaf_width_sub=leaf_width_cc,\n                                                    f_c=f_c_vine,\n                                                    f_c_sub=f_c_cc,\n                                                    f_g=fg_vine,\n                                                    f_g_sub=fg_cc,\n                                                    calcG_params=[[1], 0.35],\n                                                    resistance_form=resistance_flag)\n\n# ... and finally we compute the bulk fluxes\nle_3seb = le_vine_3seb + le_cc_3seb + le_s_3seb\nh_3seb = h_vine_3seb + h_cc_3seb + h_s_3seb\nnetrad_3seb = sn_vine_3seb + sn_cc_3seb + sn_s_3seb + ln_vine_3seb + ln_cc_3seb + ln_s_3seb\n\n","type":"content","url":"/seb-introduction#run-3seb","position":47},{"hierarchy":{"lvl1":"How 3SEB works?","lvl2":"Run TSEB-PT for comparison"},"type":"lvl2","url":"/seb-introduction#run-tseb-pt-for-comparison","position":48},{"hierarchy":{"lvl1":"How 3SEB works?","lvl2":"Run TSEB-PT for comparison"},"content":"Let us also run TSEB-PT for comparison purposes.\n\n# Compute the canopy and soil net radiation using Cambpell RTM\nsn_c, sn_s = TSEB.rad.calc_Sn_Campbell(ec[\"LAI\"].values,\n                                       sza,\n                                       par_dir + nir_dir,\n                                       par_dif + nir_dif,\n                                       fvis,\n                                       fnir,\n                                       np.full_like(sza, rho_leaf_vis_vine),\n                                       np.full_like(sza, tau_leaf_vis_vine),\n                                       np.full_like(sza, rho_leaf_nir_vine),\n                                       np.full_like(sza, tau_leaf_nir_vine),\n                                       np.full_like(sza, rho_soil_vis),\n                                       np.full_like(sza, rho_soil_nir),\n                                       x_LAD=1,\n                                       LAI_eff=lai_eff_vine)\n\nsn_c[~np.isfinite(sn_c)] = 0\nsn_s[~np.isfinite(sn_s)] = 0\n\n# TSEB-PT\n[flag_pt, ts_pt, tc_pt, t_ac_pt, ln_s_pt, ln_c_pt, le_c_pt, h_c_pt, le_s_pt, h_s_pt, g_pt,\n r_s_pt, r_x_pt, r_a_pt, u_friction_pt, lmo_pt, n_iterations_pt] = TSEB.TSEB_PT(                                                     \n     lst,\n     vza,\n     ec[\"TA\"].values,\n     ec[\"WS\"].values,\n     ec[\"EA\"].values,\n     ec[\"PA\"].values,\n     sn_c,\n     sn_s,\n     ec[\"LW_IN\"].values,\n     ec[\"LAI\"].values,\n     h_c_vine,\n     e_vine,\n     e_s,\n     z_0m_vine,\n     d_0_vine,\n     zm,\n     zh,\n     x_LAD=np.ones_like(lst),\n     f_c=f_c_vine,\n     f_g=fg_vine,\n     w_C=w_c_ratio_vine,\n     leaf_width=leaf_width_vine,\n     z0_soil=z0_soil,\n     alpha_PT=alpha_PT_0,\n     resistance_form=resistance_flag,\n     calcG_params=[[1], 0.35])\n\n# ... and we compute the bulk fluxes\nle_pt = le_c_pt + le_s_pt\nh_pt = h_c_pt + h_s_pt\nnetrad_pt = sn_c + sn_s + ln_c_pt + ln_s_pt\n\n","type":"content","url":"/seb-introduction#run-tseb-pt-for-comparison","position":49},{"hierarchy":{"lvl1":"How 3SEB works?","lvl2":"Model evaluation and visualization"},"type":"lvl2","url":"/seb-introduction#model-evaluation-and-visualization","position":50},{"hierarchy":{"lvl1":"How 3SEB works?","lvl2":"Model evaluation and visualization"},"content":"","type":"content","url":"/seb-introduction#model-evaluation-and-visualization","position":51},{"hierarchy":{"lvl1":"How 3SEB works?","lvl3":"Evaluate model fluxes at half-hourly scale","lvl2":"Model evaluation and visualization"},"type":"lvl3","url":"/seb-introduction#evaluate-model-fluxes-at-half-hourly-scale","position":52},{"hierarchy":{"lvl1":"How 3SEB works?","lvl3":"Evaluate model fluxes at half-hourly scale","lvl2":"Model evaluation and visualization"},"content":"Here, we will first create a scatter plot to evaluate how the modelled fluxes (LE, H, Rn, and G) compare to those measured by the EC tower. We will assess daytime fluxes (i.e. shortwave irradiance > 100 W/m2).\n\nSelect which method of EB correction you want to apply during the validation and which year you want to evaluate (considering that cover crop might not be present in all years):\n\nw_ebc = widgets.Dropdown(\n    options=[('No EB correction', (\"LE\", \"H\")), \n             ('Residual to LE', (\"LE_RES\", \"H\")), \n             ('Residual to H', (\"LE_RES\", \"H\")), \n             ('Bowen Ratio', (\"LE_BR\", \"H_BR\")),\n             ('Ensemble correction', (\"LE_ENS\", \"H_ENS\"))],\n    value=(\"LE_ENS\", \"H_ENS\"),\n    description='EBC method:',\n)\n\nyears = np.unique(ec[\"TIMESTAMP\"].dt.year)\nw_year = widgets.Dropdown(\n    options=years,\n    value=2019,\n    description='Select year:',\n)\n\ndisplay(w_ebc, w_year)\n\nfrom tabulate import tabulate\n\nLE_OBS, H_OBS = w_ebc.value\nprint(f\"Using {LE_OBS} and {H_OBS} fields for validating respectively  LE and H\")\n\ndaytime = ec[\"SW_IN\"] > 100\nvalid_3seb = np.logical_and(flag_3seb < 5, daytime, ec[\"TIMESTAMP\"].dt.year == w_year.value)\nvalid_pt = np.logical_and(flag_pt < 5, daytime)\n\nle_marker = {\"color\": \"blue\", \"size\": 3}\nh_marker = {\"color\": \"red\", \"size\": 3}\ng_marker = {\"color\": \"green\", \"size\": 3}\nrn_marker = {\"color\": \"black\", \"size\": 3}\n\nfig = make_subplots(rows=1, cols=2,\n                    shared_yaxes=True,\n                    horizontal_spacing=0.01,\n                    subplot_titles=[\"3SEB\", \"TSEB-PT\"])\n\nfig.add_trace(go.Scattergl(x=netrad_3seb[valid_3seb], y=ec.loc[valid_3seb, \"NETRAD\"], \n                         name=\"Rn 3SEB\", mode=\"markers\", marker=rn_marker),\n             row=1, col=1)\n\nfig.add_trace(go.Scattergl(x=netrad_pt[valid_pt], y=ec.loc[valid_pt, \"NETRAD\"], \n                         name=\"Rn TSEB-PT\", mode=\"markers\", marker=rn_marker),\n             row=1, col=2)\n\nfig.add_trace(go.Scattergl(x=g_3seb[valid_3seb], y=ec.loc[valid_3seb, \"G\"], \n                         name=\"G 3SEB\", mode=\"markers\", marker=g_marker),\n             row=1, col=1)\n\nfig.add_trace(go.Scattergl(x=g_pt[valid_pt], y=ec.loc[valid_pt, \"G\"], \n                         name=\"G TSEB-PT\", mode=\"markers\", marker=g_marker),\n             row=1, col=2)\n\nfig.add_trace(go.Scattergl(x=le_3seb[valid_3seb], y=ec.loc[valid_3seb, LE_OBS], \n                         name=\"LE 3SEB\", mode=\"markers\", marker=le_marker),\n             row=1, col=1)\n\nfig.add_trace(go.Scattergl(x=le_pt[valid_pt], y=ec.loc[valid_pt, LE_OBS], \n                         name=\"LE TSEB-PT\", mode=\"markers\", marker=le_marker),\n             row=1, col=2)\n\nfig.add_trace(go.Scattergl(x=h_3seb[valid_3seb], y=ec.loc[valid_3seb, H_OBS], \n                         name=\"H 3SEB\", mode=\"markers\", marker=h_marker),\n             row=1, col=1)\n\nfig.add_trace(go.Scattergl(x=h_pt[valid_pt], y=ec.loc[valid_pt, H_OBS], \n                         name=\"H TSEB-PT\", mode=\"markers\", marker=h_marker),\n             row=1, col=2)\n\nfig.add_trace(go.Scatter(x=[-200, 800], y=[-200, 800], mode=\"lines\", name=\"1:1 line\", line={\"color\": \"black\", \"dash\": \"dash\"}),\n             row=1, col=1)\nfig.add_trace(go.Scatter(x=[-200, 800], y=[-200, 800], mode=\"lines\", name=\"1:1 line\", line={\"color\": \"black\", \"dash\": \"dash\"}),\n             row=1, col=2)\n\n\nfig.update_layout(title_text=f\"Observed vs. Estimated hourly turbulent fluxes at {w_site.label}\",\n                  yaxis_range=[-200, 800], xaxis_range=[-200, 800], \n                  xaxis_title=\"Estimated (W m-2)\", yaxis_title=\"Observed (W m-2)\")\nfig.update_xaxes(title_text=\"Estimated (W m-2)\", row=1, col=2)\n\n","type":"content","url":"/seb-introduction#evaluate-model-fluxes-at-half-hourly-scale","position":53},{"hierarchy":{"lvl1":"How 3SEB works?","lvl3":"LE partitioning evaluation","lvl2":"Model evaluation and visualization"},"type":"lvl3","url":"/seb-introduction#le-partitioning-evaluation","position":54},{"hierarchy":{"lvl1":"How 3SEB works?","lvl3":"LE partitioning evaluation","lvl2":"Model evaluation and visualization"},"content":"We will now compare the partitioning of LE from vegetation sources (i.e. transpiration) derived from 3SEB (i.e. LEvine + LEcc) compared to the those measured from the EC flux towers using the ensemble of CEC, REA and FVS approaches [Zahn et al. 2022]https://doi.org/10.1016/j.agrformet.2021.108790.\n\nec[\"LE_C\"] = np.nanmean(ec[[\"LE_C_ECC\", \"LE_C_REA\", \"LE_C_FVS\"]], axis=1)\n\nle_c_3seb = le_vine_3seb + le_cc_3seb\n\nfig = make_subplots(rows=1, cols=2,\n                    shared_yaxes=True,\n                    horizontal_spacing=0.01,\n                   subplot_titles=(\"3SEB\", \"TSEB-PT\"))\n\nfig.add_trace(go.Scattergl(x=le_c_3seb[valid_3seb], y=ec.loc[valid_3seb, \"LE_C\"], \n                         name=\"LE_C 3SEB\", mode=\"markers\", marker=le_marker),\n             row=1, col=1)\n\nfig.add_trace(go.Scattergl(x=le_c_pt[valid_pt], y=ec.loc[valid_pt, \"LE_C\"], \n                         name=\"LE TSEB-PT\", mode=\"markers\", marker=le_marker),\n             row=1, col=2)\n\nfig.add_trace(go.Scatter(x=[-200, 800], y=[-200, 800], mode=\"lines\", name=\"1:1 line\", line={\"color\": \"black\", \"dash\": \"dash\"}),\n             row=1, col=1)\nfig.add_trace(go.Scatter(x=[-200, 800], y=[-200, 800], mode=\"lines\", name=\"1:1 line\", line={\"color\": \"black\", \"dash\": \"dash\"}),\n             row=1, col=2)\n\n\nfig.update_layout(title_text=f\"Observed vs. Estimated hourly canopy latent heat flux {w_site.label}\",\n                  yaxis_range=[-200, 800], xaxis_range=[-200, 800], \n                  xaxis_title=\"Estimated (W m-2)\", yaxis_title=\"Observed (W m-2)\")\n\nfig.update_xaxes(title_text=\"Estimated (W m-2)\", row=1, col=2)\n\n","type":"content","url":"/seb-introduction#le-partitioning-evaluation","position":55},{"hierarchy":{"lvl1":"How 3SEB works?","lvl3":"Save outputs to an ASCII table","lvl2":"Model evaluation and visualization"},"type":"lvl3","url":"/seb-introduction#save-outputs-to-an-ascii-table","position":56},{"hierarchy":{"lvl1":"How 3SEB works?","lvl3":"Save outputs to an ASCII table","lvl2":"Model evaluation and visualization"},"content":"\n\n# Define the output filename\nout_dir = Path().absolute() / \"output\"\noutfile = out_dir / f\"FLX_US-{w_site.value}_FLUXNET2015_3SEB-ROWS_HR.csv\"\n\n# Create the output folder in case it does not exist\nif not out_dir.exists():\n    out_dir.mkdir(parents=True)\n\nle_3seb = le_vine_3seb + le_cc_3seb + le_s_3seb\nh_3seb = h_vine_3seb + h_cc_3seb + h_s_3seb\nnetrad_3seb = sn_vine_3seb + sn_cc_3seb + sn_s_3seb + ln_vine_3seb + ln_cc_3seb + ln_s_3seb\n# Convert the outputs to a Python dictionary\noutdict = {\"TIMESTAMP\": ec[\"TIMESTAMP\"].dt.strftime(\"%Y%m%d%H%M\"),\n           \"FLAG_3SEB\": flag_3seb, \"LE_3SEB\": le_3seb, \"H_3SEB\": h_3seb, \"NETRAD_3SEB\": netrad_3seb, \"G_3SEB\": g_3seb, \n           \"T_S_3SEB\": t_s_3seb, \"T_CC_3SEB\": t_cc_3seb, \"T_VINE_3SEB\": t_vine_3seb, \"T_AC_3SEB\": t_ac_3seb, \n           \"LN_S_3SEB\": ln_s_3seb, \"LN_CC_3SEB\": ln_cc_3seb, \"LN_VINE_3SEB\": ln_vine_3seb, \"LE_CC_3SEB\": le_cc_3seb, \"H_CC_3SEB\": h_cc_3seb, \n           \"LE_S_3SEB\": le_s_3seb, \"H_S_3SEB\": h_s_3seb, \"LE_VINE_3SEB\": le_vine_3seb, \"H_VINE_3SEB\": h_vine_3seb, \n           \"R_S_3SEB\": r_s_3seb, \"R_SUB_3SEB\": r_sub_3seb, \"R_X_3SEB\": r_x_3seb, \"R_A_3SEB\": r_a_3seb, \"USTAR_3SEB\": u_friction_3seb, \n           \"L_MO_3SEB\":l_mo_3seb, \"ITERATIONS_3SEB\": n_iterations_3seb}\n\n# Crete the output dataframe and save it to csv\npd.DataFrame(outdict).to_csv(outfile, sep=\";\", na_rep=-9999, index=False)\nprint(f\"Saved to {outfile}\")\n\noutfile = out_dir / f\"FLX_US-{w_site.value}_FLUXNET2015_TSEB-PT-ROWS_HR.csv\"\n\n# Convert the outputs to a Python dictionary\noutdict = {\"TIMESTAMP\": ec[\"TIMESTAMP\"].dt.strftime(\"%Y%m%d%H%M\"),\n           \"FLAG_TSEBPT\": flag_pt, \"LE_TSEBPT\": le_pt, \"H_TSEBPT\": h_pt, \"NETRAD_TSEBPT\": netrad_pt, \"G_TSEBPT\": g_pt, \n           \"T_S_TSEBPT\": ts_pt, \"T_C_TSEBPT\": tc_pt, \"T_AC_TSEBPT\": t_ac_pt, \"LN_S_TSEBPT\": ln_s_pt, \"LN_C_TSEBPT\": ln_c_pt, \n           \"LE_C_TSEBPT\": le_c_pt, \"H_C_TSEBPT\": h_c_pt, \"LE_S_TSEBPT\": le_s_pt, \"H_S_TSEBPT\": h_s_pt, \"R_S_TSEBPT\": r_s_pt, \n           \"R_X_TSEBPT\": r_x_pt, \"R_A_TSEBPT\": r_a_pt, \"USTAR_TSEBPT\": u_friction_pt, \"L_MO_TSEBPT\":lmo_pt, \n           \"ITERATIONS_TSEBPT\": n_iterations_pt}\n\n# Crete the output dataframe and save it to csv\npd.DataFrame(outdict).to_csv(outfile, sep=\";\", na_rep=-9999, index=False)\nprint(f\"Saved to {outfile}\")\n\n\n","type":"content","url":"/seb-introduction#save-outputs-to-an-ascii-table","position":57},{"hierarchy":{"lvl1":"How 3SEB works?","lvl2":"Annual ET accounting"},"type":"lvl2","url":"/seb-introduction#annual-et-accounting","position":58},{"hierarchy":{"lvl1":"How 3SEB works?","lvl2":"Annual ET accounting"},"content":"One of the advantages of the 3SEB model is the ability to separate the flux contributions of the different vegetation (+soil) sources. In this section, we will check how much each source (vine, cover crop and soil) contribute to the total ET and account for their annual water use.\n\n","type":"content","url":"/seb-introduction#annual-et-accounting","position":59},{"hierarchy":{"lvl1":"How 3SEB works?","lvl3":"Instantaneous to daily","lvl2":"Annual ET accounting"},"type":"lvl3","url":"/seb-introduction#instantaneous-to-daily","position":60},{"hierarchy":{"lvl1":"How 3SEB works?","lvl3":"Instantaneous to daily","lvl2":"Annual ET accounting"},"content":"We will first convert the instantaneous fluxes to daily, instead of aggregating all hourly 3SEB estimates we will upscale a single estimate (assuming it was obtained by a satellite overpass to daily).\n\nWe will use the solar irradiance upscaling method, that assumes that the \\lambda E/ S^\\downarrow ratio is preserved. Therefore, the daily latent heat fluxes are obtained as:\\lambda E_{daily} = S^\\downarrow_{daily} \\frac{\\lambda E_{inst.}}{S^\\downarrow_{inst.}}\n\n# Set the local time of satellie overpass in decimal hours\noverpass = 10.5\n\n\n# Aggregate hourly irradiance and temporature to daily means\nec_daily = ec.groupby(ec[\"TIMESTAMP\"].dt.date)\nec_daily = ec_daily[[\"SW_IN\", \"TA\"]].mean().reset_index()\n# Select only the year of interest\nec_daily[\"TIMESTAMP\"] = pd.to_datetime(ec_daily[\"TIMESTAMP\"])\nec_daily = ec_daily.loc[ec_daily[\"TIMESTAMP\"].dt.year == w_year.value]\n\n# Select only the year of interest and overpass time for instantaneous estimates\nvalid = np.logical_and(ec[\"TIMESTAMP\"].dt.hour + ec[\"TIMESTAMP\"].dt.minute / 60 == overpass,\n                       ec[\"TIMESTAMP\"].dt.year == w_year.value)\n\nle_ratio = le_3seb[valid] / ec.loc[valid, \"SW_IN\"].values\nle_daily = le_ratio * ec_daily[\"SW_IN\"].values\n\nle_vine_ratio = le_vine_3seb[valid] / ec.loc[valid, \"SW_IN\"].values\nle_vine_daily = le_vine_ratio * ec_daily[\"SW_IN\"].values\n\nle_cc_ratio = le_cc_3seb[valid] / ec.loc[valid, \"SW_IN\"].values\nle_cc_daily = le_cc_ratio * ec_daily[\"SW_IN\"].values\n\nle_s_ratio = le_s_3seb[valid] / ec.loc[valid, \"SW_IN\"].values\nle_s_daily = le_s_ratio * ec_daily[\"SW_IN\"].values\n\n# convert to mm/day\net_daily = TSEB.met.flux_2_evaporation(le_daily, time_domain=24, t_k=ec_daily[\"TA\"].values)\net_vine_daily = TSEB.met.flux_2_evaporation(le_vine_daily, time_domain=24, t_k=ec_daily[\"TA\"].values)\net_cc_daily = TSEB.met.flux_2_evaporation(le_cc_daily, time_domain=24, t_k=ec_daily[\"TA\"].values)\net_s_daily = TSEB.met.flux_2_evaporation(le_s_daily, time_domain=24, t_k=ec_daily[\"TA\"].values)\n\n# get annual sums \net_annual = np.nansum(et_daily)\net_vine_annual = np.nansum(et_vine_daily)\net_cc_annual = np.nansum(et_cc_daily)\net_soil_annual = np.nansum(et_s_daily)\n\n%matplotlib inline\nfrom matplotlib import pyplot as plt\n# plot annual bar and pie chart for water accounting of each ET source \nfig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(14, 6), dpi=300)\n# labels\net_sources = ['$ET_{total}$', '$T_{vine}$', '$T_{cc}$', '$E_{soil}$']\n# values\net_values = [et_annual, et_vine_annual, et_cc_annual, et_soil_annual]\n# relative contribution for pie chart\nratios = [et_vine_annual/et_annual, et_cc_annual/et_annual, et_soil_annual/et_annual]\n# colors for each source\ncolors = ['black', 'seagreen', 'steelblue', 'peru']\n# bar chart\nax1.bar(et_sources, et_values, color=colors)\nax1.set_ylabel('ET (mm/day)', fontsize=20)\nax1.set_title('Annual water use (mm/year)', fontsize=22)\n# pie chart\nax2.pie(ratios, labels=et_sources[1:], colors = colors[1:], autopct='%1.1f%%')\nax2.set_title('Relative water use (%)', fontsize=22)\n\nplt.show()\n\n","type":"content","url":"/seb-introduction#instantaneous-to-daily","position":61},{"hierarchy":{"lvl1":"How 3SEB works?","lvl2":"Conclusions"},"type":"lvl2","url":"/seb-introduction#conclusions","position":62},{"hierarchy":{"lvl1":"How 3SEB works?","lvl2":"Conclusions"},"content":"3SEB presents the advantage of partitioning fluxes from two distict coexisting canopies, one sparse overstory and another rather horizontally homogenous understory.\n\nAs compared to TSEB, it requires basically the same inputs plus an estimate of LAI separation between the overstory and the understory. With some knowledge of phenology of both layers, it is doable to make such separation\n\nThe improvement of 3SEB over TSEB is only evident when both layers are coexisting and actively transpiring. Otherwise TSEB could be used instead due to its greater simplicity.\n\n[...]\n\nNote\n\nPlease feel free comment any thoughts. This is work in progress!!!","type":"content","url":"/seb-introduction#conclusions","position":63},{"hierarchy":{"lvl1":"Retrieval of effective Leaf and Soil temperatures with UAV imagery"},"type":"lvl1","url":"/uav-canopy-and-soil-temperatures","position":0},{"hierarchy":{"lvl1":"Retrieval of effective Leaf and Soil temperatures with UAV imagery"},"content":"","type":"content","url":"/uav-canopy-and-soil-temperatures","position":1},{"hierarchy":{"lvl1":"Retrieval of effective Leaf and Soil temperatures with UAV imagery","lvl2":"Summary"},"type":"lvl2","url":"/uav-canopy-and-soil-temperatures#summary","position":2},{"hierarchy":{"lvl1":"Retrieval of effective Leaf and Soil temperatures with UAV imagery","lvl2":"Summary"},"content":"This interactive Jupyter Notebook has the objective of showing one method to extract effective leaf and soil temperatures from UAV imagery, which could be use then to run \n\nTSEB-2T. It is based on \n\nNieto et al. (2018).\n\n","type":"content","url":"/uav-canopy-and-soil-temperatures#summary","position":3},{"hierarchy":{"lvl1":"Retrieval of effective Leaf and Soil temperatures with UAV imagery","lvl2":"Instructions"},"type":"lvl2","url":"/uav-canopy-and-soil-temperatures#instructions","position":4},{"hierarchy":{"lvl1":"Retrieval of effective Leaf and Soil temperatures with UAV imagery","lvl2":"Instructions"},"content":"Read carefully all the text and follow the instructions.\n\nOnce each section is read, run the jupyter code cell underneath (marked as In []) by clicking the icon Run, or pressing the keys SHIFT+ENTER of your keyboard. A graphical interface will then display, which allows you to interact with and perform the assigned tasks.\n\nTo start, please run the following cell to import all the packages required for this notebook. Once you run the cell below, an acknowledgement message, stating all libraries were correctly imported, should be printed on screen.\n\n%matplotlib inline\n%matplotlib widget\nfrom pathlib import Path\nfrom ipywidgets import interact, interactive, fixed, widgets\nfrom IPython.display import display\nimport numpy as np\nprint('libraries imported correctly')\n\n","type":"content","url":"/uav-canopy-and-soil-temperatures#instructions","position":5},{"hierarchy":{"lvl1":"Retrieval of effective Leaf and Soil temperatures with UAV imagery","lvl2":"The leaf and soil temperatures in TSEB"},"type":"lvl2","url":"/uav-canopy-and-soil-temperatures#the-leaf-and-soil-temperatures-in-tseb","position":6},{"hierarchy":{"lvl1":"Retrieval of effective Leaf and Soil temperatures with UAV imagery","lvl2":"The leaf and soil temperatures in TSEB"},"content":"TSEB the evapotranspiration (ET) and energy fluxes from vegetation and soil components providing the capability for estimating soil evaporation (E) and canopy transpiration (T). However, it is crucial for ET partitioning to retrieve reliable estimates of leaf/canopy (T_C) and soil (T_S) temperatures, in order to retrieve soil and canopy sensible heat fluxes:H_C &= \\rho C_p \\frac{T_C - T_{ac}} {R_x}\\\\\nH_S &= \\rho C_p \\frac{T_S - T_{ac}} {R_s}\n\nThe use of very high spatial TIR imagery can be especially relevant in row crops with wide spacing and strongly clumped vegetation such as vineyards and orchards, since it is possible to directly separate these component temperatures and thus avoid the use of the assumptions made in TSEB-PT (or in TSEB-SW) regarding the initialization of potential transpiration.\n\nImportant\n\nDespite UAV technology can provide very high spatial resolution information we have to be aware that TSEB, as most ot the resistance-based energy balance model, must be applied at an adequate spatial domain to comply to the assumptions and the physical formulations inherent in it. Therefore it is not possible to run TSEB at leaf-level scale, as the formulations of radiative transfer and turbulent exchanche that it relies upon, require to run TSEB at a scale in the order of meters.","type":"content","url":"/uav-canopy-and-soil-temperatures#the-leaf-and-soil-temperatures-in-tseb","position":7},{"hierarchy":{"lvl1":"Retrieval of effective Leaf and Soil temperatures with UAV imagery","lvl2":"Separation of T_C and T_S"},"type":"lvl2","url":"/uav-canopy-and-soil-temperatures#separation-of-t-c-and-t-s","position":8},{"hierarchy":{"lvl1":"Retrieval of effective Leaf and Soil temperatures with UAV imagery","lvl2":"Separation of T_C and T_S"},"content":"In this exercise, we will retrieve the effective leaf and soil temperatures by searching for pure vegetation and soil pixels in a contextual spatial domain.","type":"content","url":"/uav-canopy-and-soil-temperatures#separation-of-t-c-and-t-s","position":9},{"hierarchy":{"lvl1":"Retrieval of effective Leaf and Soil temperatures with UAV imagery","lvl3":"Dataset","lvl2":"Separation of T_C and T_S"},"type":"lvl3","url":"/uav-canopy-and-soil-temperatures#dataset","position":10},{"hierarchy":{"lvl1":"Retrieval of effective Leaf and Soil temperatures with UAV imagery","lvl3":"Dataset","lvl2":"Separation of T_C and T_S"},"content":"The UAV data correspons to the same acquisition as the [Running pyTSEB with an image](./.301-pyTSEB_image_configuration_file.ipynb] notebook.\n\nThese data were collected in 2014 during the early August IOP by the Aggie Air Team. The time of acquisition was approximately during the Landsat 7/8 overpass time. The UAV system flew at 450 m agl, resulting in 0.15 m pixel resolution in the visible and near-infrared bands and 0.60 m resolution in the thermal infrared. The visible and near-infrared sensors wavebands are similar to the Landsat blue, green, red, and near-infrared channels.\n\nSee Also\n\nFor more details see the \n\nGRAPEX special issue in Irrigation Science published in 2019 and \n\nTorres-Rua (2017).\n\nWe will use Python GDAL to open both the LST and the NDVI images. Note that the NDVI was resampled to 0.6 in order to match the LST spatial resolution.\n\nSee Also\n\nYou can also open these images in QGIS:\n\nthe LST raster is at \n\n\n\nthe NDVI raster at the 0.15m resolution is at \n\n\n\nthe ressampledNDVI raster at the LST resolution is at \n\n\n\nfrom pathlib import Path\nimport numpy as np\nfrom osgeo import gdal\n\nworkdir = Path()\ninputdir = workdir / \"input\" / \"UAV\"\n\n#inputdir = workdir / \"dataset\" / \"uav_imagery\"\n\n# Set the path to the LST and NDVI images\nlst_file = inputdir / \"SLM_001_002_20140809_1041_TIR.tif\"\nndvi_file = inputdir / \"SLM_001_002_20140809_1041_NDVI.tif\"\n\n#lst_file = inputdir / 'lst_surface_CC_10cm.tif'\n#ndvi_file = inputdir / 'ndvi_surface_CC_10cm.tif'\n\n# Open and read the LST file\nfid = gdal.Open(str(lst_file), gdal.GA_ReadOnly)\nlst = fid.GetRasterBand(1).ReadAsArray() \n# Convert Censius to Kelvin\nlst = lst + 273.15\nlst[lst <= 0] = None\n\n# Get the LST GDAL geotransform and projection\ngt = fid.GetGeoTransform()\nproj = fid.GetProjection()\n# Open and read the NDVI file\nfid = gdal.Open(ndvi_file, gdal.GA_ReadOnly)\nndvi = fid.GetRasterBand(1).ReadAsArray()\nndvi[ndvi <= 0] = None\n\ndel fid\n\n","type":"content","url":"/uav-canopy-and-soil-temperatures#dataset","position":11},{"hierarchy":{"lvl1":"Retrieval of effective Leaf and Soil temperatures with UAV imagery","lvl4":"Browse the input data","lvl3":"Dataset","lvl2":"Separation of T_C and T_S"},"type":"lvl4","url":"/uav-canopy-and-soil-temperatures#browse-the-input-data","position":12},{"hierarchy":{"lvl1":"Retrieval of effective Leaf and Soil temperatures with UAV imagery","lvl4":"Browse the input data","lvl3":"Dataset","lvl2":"Separation of T_C and T_S"},"content":"We can now visualize both images, pay special attention to the least dense rows where it is difficult to find pure vegetation pixels at 0.6m spatial resoocution, as for these areas is where the method can be specially usefull.\n\nfrom bokeh.plotting import *\nfrom bokeh import palettes as pal\nfrom bokeh.models.mappers import LinearColorMapper\nfrom bokeh.io import output_notebook\nfrom bokeh.resources import INLINE\noutput_notebook(resources=INLINE)\n\nrows, cols = int(0.3 * lst.shape[0]), int(0.3 * lst.shape[1])\n# Setup the figure\nmap_lst = LinearColorMapper(palette=pal.RdYlBu11, high=320, low=300)\nmap_ndvi = LinearColorMapper(palette=pal.YlGn9, high=0.3, low=0.7)\ns1 = figure(title=\"LST\", width=cols, height=rows, x_range=[0, cols], y_range=[0, rows])\ns1.axis.visible = False\ns1.image(image=[np.flipud(lst)], x=[0], y=[0], dw=cols, dh=rows, color_mapper=map_lst)\ns2= figure(title=\"NDVI\", width=cols, height=rows, x_range=s1.x_range, y_range=s1.y_range)\ns2.axis.visible = False\ns2.image(image=[np.flipud(ndvi)], x=[0], y=[0], dw=[cols], dh=[rows], color_mapper=map_ndvi)\n\np = gridplot([[s1, s2]], toolbar_location='above')\nshow(p)\n\n","type":"content","url":"/uav-canopy-and-soil-temperatures#browse-the-input-data","position":13},{"hierarchy":{"lvl1":"Retrieval of effective Leaf and Soil temperatures with UAV imagery","lvl3":"Nieto et al. 2022 contextual method","lvl2":"Separation of T_C and T_S"},"type":"lvl3","url":"/uav-canopy-and-soil-temperatures#nieto-et-al-2022-contextual-method","position":14},{"hierarchy":{"lvl1":"Retrieval of effective Leaf and Soil temperatures with UAV imagery","lvl3":"Nieto et al. 2022 contextual method","lvl2":"Separation of T_C and T_S"},"content":"We will obtain T_C and T_S by searching for pure vegetation and soil pixels in a contextual spatial domain (\n\nFigure 1). That is, in a coarse resolution spatial grid, consistent with the TSEB physical assumptions, we will assign for each of its cells the canopy and soil temperatures corresponding to the average temperature for the original LST resoltuion pixels that are considered, respectively, bare soil/ and pure vegetation.\n\nNote\n\nIn this case we assume that TSEB will be run at 3.6 m spatial resolution, as it is spatial domain large enough to include the canopy/interrow system (3.35 m width) in order to be consistent with the radiative transfer modelling in the rows, being as well a multiple of the raw LST spatial resolution of 0.6m. However, some of you could argue that even 3.6m could be a too fine spatial resolution to comply with the assumptions made during the calculation of turbulent exchange between the surface and atmosphere\n\nPure vegetation NDVI (NDVI_{veg}) was set as the mean value of pixels classified as pure vegetation using a support vector machine binary supervised classification of the 0.15 m multispectral imagery (NDVI_{veg}=0.6). Simlarly, bare soil NDVI was set as (NDVI_{soil}=0.3)\n\nWarning\n\nNote that these pure vegetation and soil NDVI values might change due to different spectral cameras and different crop/soil types.","type":"content","url":"/uav-canopy-and-soil-temperatures#nieto-et-al-2022-contextual-method","position":15},{"hierarchy":{"lvl1":"Retrieval of effective Leaf and Soil temperatures with UAV imagery","lvl4":"Set our parameters in Python","lvl3":"Nieto et al. 2022 contextual method","lvl2":"Separation of T_C and T_S"},"type":"lvl4","url":"/uav-canopy-and-soil-temperatures#set-our-parameters-in-python","position":16},{"hierarchy":{"lvl1":"Retrieval of effective Leaf and Soil temperatures with UAV imagery","lvl4":"Set our parameters in Python","lvl3":"Nieto et al. 2022 contextual method","lvl2":"Separation of T_C and T_S"},"content":"\n\n# Set the output spatial domain resolution at 3.6m\nout_res = 3.6\n# Set the NDVI value for bare soil\nndvi_soil = 0.3\n# Set the NDVI value for pure vegetation\nndvi_veg = 0.6\n\nHowever, it may be the case that no pure pixels at the native resolution (0.6 m in our case) are found in the coarse resolution spatial domain (3.6 m in our case), either due to very dense vegetation (e.g., lack of bare soil/substrate pixels) or very sparse vegetation (e.g., lack of pure vegetation pixels). If that is the case, and assuming that there is a linear relationship between NDVI and LST, we extrapolate to the pure vegetation or soil NDVI value the linear fit of the NDVI-LST pairs within the coarse resolution spatial domain mixed-pixel to estimate the extrapolated value for the pure vegetation (or soil) within the the aggregated pixel resolution (\n\nFigure 1).\n\n\n\nFigure 1:Example of contextual NDVI- LST scatterplot used for finding T_C and T_S. Each point corresponds to a pixel NDVI-LST pair within a larger scale spatial domain. From \n\nNieto et al. (2018)\n\nThat is, in a 3.6m grid, we assign for each of these cells the canopy and soil temperatures corresponding to the average temperature for the 0.6 m pixels that are considered, respectively, bare soil/cover crop stubble and pure vegetation. The selection criterion for detecting pure soil NDVI is based on the empirical relationship between NDVI and in situ LAI, with NDVI is the extrapolation of that curve for . On the other hand, pure vegetation NDVI (NDVI) is the mean value of pixels classified as pure vegetation using a support vector machine binary supervised classification of the 0.15 m multispectral imagery. However, it may be the case that no pure pixels at the native resolution (0.6 m) are found in a 3.6 m spatial domain, either due to very dense vegetation (e.g., lack of bare soil/substrate pixels) or very sparse vegetation (e.g., lack of pure vegetation pixels). If that is the case, and assuming that there is a linear relationship between NDVI and , we extrapolate to the pure vegetation or soil NDVI value the linear fit of the NDVI- pairs within the 3.6 m mixed-pixel to estimate the extrapolated value for the pure vegetation (or soil) within the 3.6 m aggregated pixel resolution.\n\n# We calculate the rescaling factor based on the ratio between LST resolution (0.6) and TSEB spatial domain resolution (3.6m)\nf_res = (int(np.round(np.abs(out_res / gt[5]))),\n         int(np.round(np.abs(out_res / gt[1]))))\nprint(f\"We will look for pure vegetation and bare soil pixel in a \"\n      f\"{f_res[0]}x{f_res[0]} pixels spatial window\")\n\nCanopy (soil) temperatures are retrieved first by averaging the values above (below) a pure vegetation (soil) NDVI threshold, which corresponds to the greyed areas in the plot. If no pure pixels are found in those areas, the canopy (soil) temperature is found by extrapolating the linear fit between all NDVI- pairs in the domain to the pure vegetation (soil) NDVI threshold.\n\nLook at the code below that besides of the t_leaf and t_leaf outputs we also create a quality assessment output that consists on the Pearson correlation (cor) between the LST-NDVI pairs at 3.6 m that indicates how robust the extrapolation to pure vegetation/bare soil would be.","type":"content","url":"/uav-canopy-and-soil-temperatures#set-our-parameters-in-python","position":17},{"hierarchy":{"lvl1":"Retrieval of effective Leaf and Soil temperatures with UAV imagery","lvl4":"Run the code to extract the T_C and T_S images","lvl3":"Nieto et al. 2022 contextual method","lvl2":"Separation of T_C and T_S"},"type":"lvl4","url":"/uav-canopy-and-soil-temperatures#run-the-code-to-extract-the-t-c-and-t-s-images","position":18},{"hierarchy":{"lvl1":"Retrieval of effective Leaf and Soil temperatures with UAV imagery","lvl4":"Run the code to extract the T_C and T_S images","lvl3":"Nieto et al. 2022 contextual method","lvl2":"Separation of T_C and T_S"},"content":"Depending on the size of the image this process can take a while, as it needs to loop along all the cells at which TSEB will be run.\n\nfrom scipy import stats as st\n\n# Get the lst size\nnrows, ncols = lst.shape\n\n# Initialize the outputs\nout_shape = int(np.ceil(nrows / f_res[0])), int(np.ceil(ncols / f_res[1]))\nt_leaf = np.full(out_shape, np.nan)\nt_soil = np.full(out_shape, np.nan)\ncor = np.full(out_shape, np.nan)\n\n# Loop along all tiles\nrow_ini = 0\ni = 0\nprint(f\"Processing {out_shape[0] * out_shape[1]} cells, please wait...\")\nwhile row_ini < nrows - 1:\n    row_end = int(np.minimum(row_ini + f_res[0], nrows))\n    col_ini = 0\n    j = 0\n    while col_ini < ncols - 1:\n        col_end = int(np.minimum(col_ini + f_res[1], ncols))\n        # Get the LST values within the spatial domain\n        lst_subset = lst[row_ini:row_end, col_ini:col_end]\n        if ~np.any(np.isfinite(lst_subset)):\n            # Jump to the next tile\n            j += 1\n            col_ini = int(col_end)\n            continue\n        \n        # Get the NDVI values within the spatial domain\n        vnir_subset = ndvi[row_ini:row_end, col_ini:col_end]\n\n        # Find, if any all pure soil and vegetation pixels based on the NDVI thresholds\n        soils = vnir_subset <= ndvi_soil\n        vegs = vnir_subset >= ndvi_veg\n        \n        # Buld the local linear regression between NDVI and LST\n        reg = st.linregress(np.ravel(vnir_subset), np.ravel(lst_subset))\n        # Add the resulting correlation to the quality assessment band\n        cor[i, j] = reg.rvalue\n\n        \n        if np.any(soils): \n            # Bare soil pixels found, computing their mean as T_S\n            t_soil[i, j] = np.nanmean(lst_subset[soils])\n        else:\n            # No Bare soil pixels found, extrapolating using the linear regression\n            t_soil[i, j] = reg.intercept + reg.slope * ndvi_soil\n\n        if np.any(vegs):\n            # Pure vegetation pixels found, computing their mean as T_C\n            t_leaf[i, j] = np.nanmean(lst_subset[vegs])\n        else:\n            # No pure vegetation pixels found, extrapolating using the linear regression\n            t_leaf[i, j] = reg.intercept + reg.slope * ndvi_veg\n\n        # Jump to the next column tile\n        j += 1\n        col_ini = int(col_end)\n\n    # Jump to the next rowntile\n    i += 1\n    row_ini = int(row_end)\n\nprint(\"Done!\")\n\nSee Also\n\nYou can also check the \n\nGitHub source code","type":"content","url":"/uav-canopy-and-soil-temperatures#run-the-code-to-extract-the-t-c-and-t-s-images","position":19},{"hierarchy":{"lvl1":"Retrieval of effective Leaf and Soil temperatures with UAV imagery","lvl4":"We can now visualize the results:","lvl3":"Nieto et al. 2022 contextual method","lvl2":"Separation of T_C and T_S"},"type":"lvl4","url":"/uav-canopy-and-soil-temperatures#we-can-now-visualize-the-results","position":20},{"hierarchy":{"lvl1":"Retrieval of effective Leaf and Soil temperatures with UAV imagery","lvl4":"We can now visualize the results:","lvl3":"Nieto et al. 2022 contextual method","lvl2":"Separation of T_C and T_S"},"content":"\n\n# Setup the figure\nmap_cor = LinearColorMapper(palette=pal.YlGn9, high=0, low=1)\ns1 = figure(title=\"T leaf\", width=cols, height=rows, x_range=[0, cols], y_range=[0, rows])\ns1.axis.visible = False\ns1.image(image=[np.flipud(t_leaf)], x=[0], y=[0], dw=cols, dh=rows, color_mapper=map_lst)\ns2 = figure(title=\"T soil\", width=cols, height=rows, x_range=s1.x_range, y_range=s1.y_range)\ns2.axis.visible = False\ns2.image(image=[np.flipud(t_soil)], x=[0], y=[0], dw=[cols], dh=[rows], color_mapper=map_lst)\ns3 = figure(title=\"Pearson r\", width=cols, height=rows, x_range=s1.x_range, y_range=s1.y_range)\ns3.axis.visible = False\ns3.image(image=[np.flipud(cor)], x=[0], y=[0], dw=[cols], dh=[rows], color_mapper=map_cor)\np = gridplot([[s1, s2, s3]], toolbar_location='above')\nshow(p)\n\n","type":"content","url":"/uav-canopy-and-soil-temperatures#we-can-now-visualize-the-results","position":21},{"hierarchy":{"lvl1":"Retrieval of effective Leaf and Soil temperatures with UAV imagery","lvl3":"Save the output images","lvl2":"Separation of T_C and T_S"},"type":"lvl3","url":"/uav-canopy-and-soil-temperatures#save-the-output-images","position":22},{"hierarchy":{"lvl1":"Retrieval of effective Leaf and Soil temperatures with UAV imagery","lvl3":"Save the output images","lvl2":"Separation of T_C and T_S"},"content":"To conclude we will save our images to a 3-band GeoTIFF file, with bands:\n\nLeaf Temperature (K)\n\nSoil Temperature (K)\n\nLocal correlation between lst and vnir inputs\n\n# Set the output \noutdir = workdir / \"input\" / \"UAV\"\nout_file = outdir / \"SLM_001_002_20140809_1041_TC-TS.tif\"\n\n# The output GDAL geotransform shares the same UL coordinates but with 3.6m resolution \ngt_out = [gt[0], out_res, 0, gt[3], 0, -out_res]\n\ndriver = gdal.GetDriverByName(\"GTiff\")\nfid = driver.Create(str(out_file), t_leaf.shape[1], t_leaf.shape[0], 3,\n                    gdal.GDT_Float32)\nfid.SetProjection(proj)\nfid.SetGeoTransform(gt_out)\nfor i, array in enumerate([t_leaf, t_soil, cor]):\n    fid.GetRasterBand(i + 1).WriteArray(array)\n\ndel fid\n\nprint(f\"Component temperatures save at {out_file}\")\n\n","type":"content","url":"/uav-canopy-and-soil-temperatures#save-the-output-images","position":23},{"hierarchy":{"lvl1":"Retrieval of effective Leaf and Soil temperatures with UAV imagery","lvl2":"Conclusions"},"type":"lvl2","url":"/uav-canopy-and-soil-temperatures#conclusions","position":24},{"hierarchy":{"lvl1":"Retrieval of effective Leaf and Soil temperatures with UAV imagery","lvl2":"Conclusions"},"content":"We showed a simple contextual method to extract the component soil and canopy temperatures required by TSEB models\n\nHowever this contextual method, since it is based on the LST-NDVI pairs, requires a correct corregistration between the shortwave and thermal datasets.\n\nIn the next exercise we will see a tool that can help us to ensure the corregistration between these two products\n\nFinally, we will see in the final exercise how to use these data in TSEB.\n\n[...]\n\nNote\n\nPlease feel free to comment any thoughts. This is work in progress!!!","type":"content","url":"/uav-canopy-and-soil-temperatures#conclusions","position":25},{"hierarchy":{"lvl1":"TSEB running with component Tc and Ts temperatures"},"type":"lvl1","url":"/uav-tseb-2t","position":0},{"hierarchy":{"lvl1":"TSEB running with component Tc and Ts temperatures"},"content":"","type":"content","url":"/uav-tseb-2t","position":1},{"hierarchy":{"lvl1":"TSEB running with component Tc and Ts temperatures","lvl2":"Summary"},"type":"lvl2","url":"/uav-tseb-2t#summary","position":2},{"hierarchy":{"lvl1":"TSEB running with component Tc and Ts temperatures","lvl2":"Summary"},"content":"This interactive Jupyter Notebook has the objective of showing the implemenation of TSEB-2T with UAV imagery, which is based on  \n\nNieto et al. (2018).\n\n","type":"content","url":"/uav-tseb-2t#summary","position":3},{"hierarchy":{"lvl1":"TSEB running with component Tc and Ts temperatures","lvl2":"Instructions"},"type":"lvl2","url":"/uav-tseb-2t#instructions","position":4},{"hierarchy":{"lvl1":"TSEB running with component Tc and Ts temperatures","lvl2":"Instructions"},"content":"Read carefully all the text and follow the instructions.\n\nOnce each section is read, run the jupyter code cell underneath (marked as In []) by clicking the icon Run, or pressing the keys SHIFT+ENTER of your keyboard. A graphical interface will then display, which allows you to interact with and perform the assigned tasks.\n\nTo start, please run the following cell to import all the packages required for this notebook. Once you run the cell below, an acknowledgement message, stating all libraries were correctly imported, should be printed on screen.\n\n%matplotlib inline\nfrom ipywidgets import interact, interactive, fixed, widgets\nfrom IPython.display import display\nimport numpy as np\nprint(\"Libraries imported, you can continue!\")\n\n","type":"content","url":"/uav-tseb-2t#instructions","position":5},{"hierarchy":{"lvl1":"TSEB running with component Tc and Ts temperatures","lvl2":"TSEB-2T"},"type":"lvl2","url":"/uav-tseb-2t#tseb-2t","position":6},{"hierarchy":{"lvl1":"TSEB running with component Tc and Ts temperatures","lvl2":"TSEB-2T"},"content":"The component temperature TSEB-2T \n\nShuttleworth & Wallace, 1985 was specifically designed to run TSEB when having already retrieved the soil (T_S) and canopy (T_C) temeperatures. Therefore, TSEB-2T does not need to realy on an initial guess of potential transpiration and avoids the iterative reduction of canopy transpiration until realistic fluxes are obtained. Instead it computes soil and canopy sensible heat fluxes directly from the soil and canopy temperatures parsed into the model:H_C & = \\rho C_p \\frac{T_C - T_{AC}}{R_x}\\\\\nH_S & = \\rho C_p \\frac{T_S - T_{AC}}{R_s}\n\nwithT_{AC} = \\frac{R_a/T_A + R_x/T_C + R_S/T_S}{1/T_A + 1/T_C + 1 T_S}\n\nSee Also\n\nThe full code for the TSEB-2T is at the \n\npyTSEB GitHub repository\n\n","type":"content","url":"/uav-tseb-2t#tseb-2t","position":7},{"hierarchy":{"lvl1":"TSEB running with component Tc and Ts temperatures","lvl2":"Application with UAV data"},"type":"lvl2","url":"/uav-tseb-2t#application-with-uav-data","position":8},{"hierarchy":{"lvl1":"TSEB running with component Tc and Ts temperatures","lvl2":"Application with UAV data"},"content":"For this exercise we will implmenent a code to run TSEB-2T with UAV imagery. We will use the canopy and soil temperatures that we derived in the \n\n501​-canopy​_and​_soil​_temperatures notebook, which corresponds to the save UAV acquisition stored in the subfolder \n\n./input/pyTSEB\n\nNote\n\nYou will also see that running TSEB with an image is very similar to what we did in previous exercises when running the models with ASCII tables. The only differences will be on the way we read the inputs and save the outputs.\n\nAs with the previous exercices, we will work with the sites of GRAPEX, in this case since the UAV is over Sierra Loma we will use the informatio from that site.\n\nSite characteristics\n\nSite\n\nLatitude\n\nLongitude\n\nElevation (m)\n\nRow direction (deg.)\n\nRow spacing (m)\n\nMin. height (m)\n\nMax. height (m)\n\nMin. width (m)\n\nMax. width (m)\n\nTA height (m)\n\nWS height (m)\n\nSierra Loma-north\n\n38.289338\n\n-121.117764\n\n38\n\n90\n\n3.35\n\n0.5\n\n1.42\n\n0.8\n\n2.6\n\n5\n\n5\n\nSierra Loma-south\n\n38.280488\n\n-121.117597\n\n37\n\n90\n\n3.35\n\n0.5\n\n1.42\n\n0.8\n\n2\n\n5\n\n5","type":"content","url":"/uav-tseb-2t#application-with-uav-data","position":9},{"hierarchy":{"lvl1":"TSEB running with component Tc and Ts temperatures","lvl3":"Define working folders","lvl2":"Application with UAV data"},"type":"lvl3","url":"/uav-tseb-2t#define-working-folders","position":10},{"hierarchy":{"lvl1":"TSEB running with component Tc and Ts temperatures","lvl3":"Define working folders","lvl2":"Application with UAV data"},"content":"\n\nfrom pathlib import Path\nsite = \"slmN\"\n# Define the working directories\nworkdir = Path()\ninput_dir = workdir / \"input\" / \"pyTSEB\"  # here we have LAI, fc and TC_TS imagery that we will use\nprint(f\"Input folder is {input_dir}\")\n\n","type":"content","url":"/uav-tseb-2t#define-working-folders","position":11},{"hierarchy":{"lvl1":"TSEB running with component Tc and Ts temperatures","lvl3":"Read the LAI and f_c imagery","lvl2":"Application with UAV data"},"type":"lvl3","url":"/uav-tseb-2t#read-the-lai-and-f-c-imagery","position":12},{"hierarchy":{"lvl1":"TSEB running with component Tc and Ts temperatures","lvl3":"Read the LAI and f_c imagery","lvl2":"Application with UAV data"},"content":"\n\n# Import Python libraries\nfrom osgeo import gdal\n\nlai_image = input_dir / \"ExampleImage_LAI.tif\"\nfc_image = input_dir / \"ExampleImage_Fc.tif\"\n\n# Read the LAI GDAL file and store it in a numpy array\nfid = gdal.Open(str(lai_image), gdal.GA_ReadOnly)\nlai = fid.GetRasterBand(1).ReadAsArray()\n# Get also the geotransform and projection as it is the same for all the products\ngt = fid.GetGeoTransform()\nproj = fid.GetProjection()\n\n# Read the fc GDAL file and store it in a numpy array\nfid = gdal.Open(str(fc_image), gdal.GA_ReadOnly)\nf_c = fid.GetRasterBand(1).ReadAsArray()\ndel fid\nprint(\"Read fractional cover and LAI\")\n\n","type":"content","url":"/uav-tseb-2t#read-the-lai-and-f-c-imagery","position":13},{"hierarchy":{"lvl1":"TSEB running with component Tc and Ts temperatures","lvl3":"Get the canopy a priori structural properties","lvl2":"Application with UAV data"},"type":"lvl3","url":"/uav-tseb-2t#get-the-canopy-a-priori-structural-properties","position":14},{"hierarchy":{"lvl1":"TSEB running with component Tc and Ts temperatures","lvl3":"Get the canopy a priori structural properties","lvl2":"Application with UAV data"},"content":"\n\nimport yaml\nyaml_file = input_dir.parent / \"site_description.yaml\"\nsite_dict = yaml.safe_load(yaml_file.read_text())\nlat = float(site_dict[\"lat\"][site])\nlon = float(site_dict[\"lon\"][site])\nelev = float(site_dict[\"elev\"][site])\nrow_direction = float(site_dict[\"row_direction\"][site])\ninterrow = float(site_dict[\"interrow\"][site])\nhc_min = float(site_dict[\"hc_min\"][site])\nhc_max = float(site_dict[\"hc_max\"][site])\nwc_min = float(site_dict[\"wc_min\"][site])\nwc_max = float(site_dict[\"wc_max\"][site])\nzh = float(site_dict[\"zh\"][site])\nzm = float(site_dict[\"zm\"][site])\n\nprint(f\"{site} has the following site characteristics:\\n\"\n      f\"\\t Latitude: {lat} deg. \\n\"\n      f\"\\t Longitude: {lon} deg. \\n\"\n      f\"\\t Elevation: {elev} m \\n\"\n      f\"\\t Row direction: {row_direction} deg. \\n\"\n      f\"\\t Row spacing: {interrow} m \\n\"\n      f\"\\t Min. canopy height: {hc_min} m \\n\"\n      f\"\\t Max. canopy height: {hc_max} m \\n\"\n      f\"\\t Min. canopy width: {wc_min} m \\n\"\n      f\"\\t Max. canopy width: {wc_max} m \\n\"\n      f\"\\t Air temperature measurement height: {zh} m \\n\"\n      f\"\\t Wind speed temperature measurement height: {zh} m\"\n)\n\n","type":"content","url":"/uav-tseb-2t#get-the-canopy-a-priori-structural-properties","position":15},{"hierarchy":{"lvl1":"TSEB running with component Tc and Ts temperatures","lvl3":"Estimate the structural variables based on Earth Observation LAI timeseries","lvl2":"Application with UAV data"},"type":"lvl3","url":"/uav-tseb-2t#estimate-the-structural-variables-based-on-earth-observation-lai-timeseries","position":16},{"hierarchy":{"lvl1":"TSEB running with component Tc and Ts temperatures","lvl3":"Estimate the structural variables based on Earth Observation LAI timeseries","lvl2":"Application with UAV data"},"content":"As with the previous exercise, we could estimate the canopy structural variables based on LAI and empirical observations of trellis development.\n\n\n\nFigure 2:Empirical models relating canopy height , canopy width and the bottom of the canopy with the fused STARFM LAI. Solid dots represent in situ measured values\n\nThese empirical equations are coded in Python as:\n\nimport numpy as np\n\n################################################################################\n# Empirical equations to generate canopy structural parameters from LAI\n################################################################################\ndef lai_2_hc(lai, hc_min):\n    slope = 0.42\n    hc = hc_min + slope * lai\n    return hc\n\n\ndef lai_2_hbratio(lai, hc_min):\n    hb_ratio_mean = 0.4848388065\n    hb_ratio = np.zeros(lai.shape)\n\n    hb_ratio[lai < hc_min] = 1. + ((hb_ratio_mean - 1.) / hc_min) * lai[\n        lai < hc_min]\n    hb_ratio[lai >= hc_min] = hb_ratio_mean\n\n    return hb_ratio\n\n\ndef lai_2_width(lai, wc_min, wc_max):\n    beta = 6.96560056\n    offset = 1.70825736\n\n    width = wc_min + (wc_max - wc_min) / (1.0 + np.exp(-beta * (lai - offset)))\n\n    return width\n\n\ndef lai_2_fcover(lai, fc_min, fc_max):\n    beta = 7.0\n    offset = 1.70\n\n    fcover = fc_min + (fc_max - fc_min) / (1.0 + np.exp(-beta * (lai - offset)))\n\n    return fcover\n\n\ndef lai_2_canopy(lai, hc_min, fc_min, fc_max):\n    hc = lai_2_hc(lai, hc_min)\n    hb_ratio = lai_2_hbratio(lai, hc_min)\n    fcover = lai_2_fcover(lai, fc_min, fc_max)\n\n    return hc, hb_ratio, fcover\n\nFrom these empirical functions together with the site description properties described in \n\nSite Description we can caluculate the time series of canopy structural variables needed to compute the shadowing as shown in \n\nFigure 1\n\nNote\n\nThese equations are site specific and most likely not applicable to other sites and crops. For operational purposes, such as using Earth Observation/satellite data a trade-off must be made between accuracy and applicability.\n\nWe already have a f_c map we can skip such computation:\n\n# Compute the expected minimum and maximum canopy cover based on mininum and maximum canopy width\nfc_min = wc_min / interrow\nfc_max = wc_max / interrow\nh_c, hb_ratio, _ = lai_2_canopy(lai,\n                                hc_min,\n                                fc_min,\n                                fc_max)\n# Ensure that both canopy height and cover are within the limits\nh_c = np.clip(h_c, hc_min, hc_max)\nprint(\"Computed canopy height\")\n\n","type":"content","url":"/uav-tseb-2t#estimate-the-structural-variables-based-on-earth-observation-lai-timeseries","position":17},{"hierarchy":{"lvl1":"TSEB running with component Tc and Ts temperatures","lvl3":"We can get the shortwave net radiation for row crops","lvl2":"Application with UAV data"},"type":"lvl3","url":"/uav-tseb-2t#we-can-get-the-shortwave-net-radiation-for-row-crops","position":18},{"hierarchy":{"lvl1":"TSEB running with component Tc and Ts temperatures","lvl3":"We can get the shortwave net radiation for row crops","lvl2":"Application with UAV data"},"content":"This step is very similar to previous exercies, but since we are working with a single scene of small extension, we can assume a constant value for the weather forcing:\n\nTA (K)\n\nWS (m s^{-1})\n\nEA (kPa)\n\nPA (kPa)\n\nSW_IN (W m^{-2})\n\nSW_IN_DD (W m^{-2})\n\n291.11\n\n2.15\n\n13.4\n\n1011\n\n861.74\n\n304.97\n\nfrom pyTSEB import TSEB\n\n# Define the date and acquisiton time\ndoy = 221\t\ntime = 10.9992\t\nsdtlon = -105\n\n# Define the weather forcing, and broacast the value to a numpy array of same size as the inputs\n# Shortwave irradiance\nsw_in = 861.74 \nsw_in = np.full_like(lai, sw_in)\n\n# Air temperature\nta = 299.18\nta = np.full_like(lai, ta)\n\n# Amospheric vapour pressure\nea = 13.4\nea = np.full_like(lai, ea)\n\n# Surface pressure\npa = 1011.\npa = np.full_like(lai, pa)\n\n# Wind speed\nws = 2.15\nws = np.full_like(ws, ws)\n\n# And we compute the downwelling longwave irradiance\ne_atm = TSEB.rad.calc_emiss_atm(ea, ta)\nlw_in = e_atm * TSEB.met.calc_stephan_boltzmann(ta)\n\nprint(\"Retrieved all the required weather forcint\")\n\n...and now we get the shorwave net radioation\n\nNote\n\ncheck that the code is the same as when we worked with a timeseries of in situ observations\n\nfrom pyTSEB import TSEB\n\n# We can get the leaf and soil spectral from the values above, or hard code the corresponding values\nrho_leaf_vis = 0.054\nrho_leaf_nir = 0.262\ntau_leaf_vis = 0.038\ntau_leaf_nir = 0.333\nrho_soil_vis = 0.07\nrho_soil_nir = 0.32\n\n# canopy width\nw_c = f_c * interrow\n# Canopy width to height ratio\nw_c_ratio = w_c / (h_c - hb_ratio * h_c)\n# Local LAI\nF = lai / f_c\n\n# The time zone is PST, which corresponds to -120 deg, time longitude\nstdlon = -120\n# Call calc_sun_angles based on site coordinates and timestamp\nsza, saa = TSEB.met.calc_sun_angles(\n    np.full_like(lai, lat),\n    np.full_like(lai, lon),\n    np.full_like(lai, stdlon),\n    doy,\n    time)\n\n# Compute the relative sun-row azimuth angle\npsi = row_direction - saa\n# Compute the clumping index for row crops\nomega = TSEB.CI.calc_omega_rows(lai, f_c, theta=sza,\n                                psi=psi, w_c=w_c_ratio)\n\n# And the effective LAI is the product of local LAI and the clumping index\nlai_eff = F * omega\n\n# Estimates the direct and diffuse solar radiation\ndifvis, difnir, fvis, fnir = TSEB.rad.calc_difuse_ratio(sw_in,\n                                                        sza,\n                                                        press=np.full_like(sza, 1013.15))\npar_dir = fvis * (1. - difvis) * sw_in\nnir_dir = fnir * (1. - difnir) * sw_in\npar_dif = fvis * difvis * sw_in\nnir_dif = fnir * difnir * sw_in\n\n# Compute the canopy and soil net radiation using Cambpell RTM\nsn_c, sn_s = TSEB.rad.calc_Sn_Campbell(lai,\n                                       sza,\n                                       par_dir + nir_dir,\n                                       par_dif + nir_dif,\n                                       fvis,\n                                       fnir,\n                                       np.full_like(sza, rho_leaf_vis),\n                                       np.full_like(sza, tau_leaf_vis),\n                                       np.full_like(sza, rho_leaf_nir),\n                                       np.full_like(sza, tau_leaf_nir),\n                                       np.full_like(sza, rho_soil_vis),\n                                       np.full_like(sza, rho_soil_nir),\n                                       x_LAD=1,\n                                       LAI_eff=lai_eff)\n\nsn_c[~np.isfinite(sn_c)] = 0\nsn_s[~np.isfinite(sn_s)] = 0\nprint(\"Finished computing net shortwave radiation\")\n\n","type":"content","url":"/uav-tseb-2t#we-can-get-the-shortwave-net-radiation-for-row-crops","position":19},{"hierarchy":{"lvl1":"TSEB running with component Tc and Ts temperatures","lvl3":"Set additional site parameters needed for TSEB","lvl2":"Application with UAV data"},"type":"lvl3","url":"/uav-tseb-2t#set-additional-site-parameters-needed-for-tseb","position":20},{"hierarchy":{"lvl1":"TSEB running with component Tc and Ts temperatures","lvl3":"Set additional site parameters needed for TSEB","lvl2":"Application with UAV data"},"content":"\n\n# Grapevine leaf width\nleaf_width = 0.10\n\n# Roughness for bare soil\nz0_soil = 0.15\n\n# Kustas and Norman boundary layer resistance parameters\nroil_resistance_c_param = 0.0038\nroil_resistance_b_param = 0.012\nroil_resistance_cprime_param = 90.\n# Thermal spectra\ne_v = 0.99  # Leaf emissivity\ne_s = 0.94  # Soil emissivity\n\nprint(\"TSEB parameters registered in memory\")\n\n","type":"content","url":"/uav-tseb-2t#set-additional-site-parameters-needed-for-tseb","position":21},{"hierarchy":{"lvl1":"TSEB running with component Tc and Ts temperatures","lvl3":"Estimate surface aerodynamic roughness","lvl2":"Application with UAV data"},"type":"lvl3","url":"/uav-tseb-2t#estimate-surface-aerodynamic-roughness","position":22},{"hierarchy":{"lvl1":"TSEB running with component Tc and Ts temperatures","lvl3":"Estimate surface aerodynamic roughness","lvl2":"Application with UAV data"},"content":"We estimate aerodynamic roughness for tall canopies based on \n\nRaupach (1994) and \n\n:\n\nz_0m, d_0 = TSEB.res.calc_roughness(lai, h_c, w_c_ratio, np.full_like(lai, TSEB.res.BROADLEAVED_D), f_c=f_c)\n# Ensure realistic values\nd_0[d_0 < 0] = 0\nz_0m[np.isnan(z_0m)] = z0_soil\nz_0m[z_0m < z0_soil] = z0_soil\nprint(f\"Computed aerodynamic roughness\")\n\n","type":"content","url":"/uav-tseb-2t#estimate-surface-aerodynamic-roughness","position":23},{"hierarchy":{"lvl1":"TSEB running with component Tc and Ts temperatures","lvl3":"We read the canopy and soil temperatures","lvl2":"Application with UAV data"},"type":"lvl3","url":"/uav-tseb-2t#we-read-the-canopy-and-soil-temperatures","position":24},{"hierarchy":{"lvl1":"TSEB running with component Tc and Ts temperatures","lvl3":"We read the canopy and soil temperatures","lvl2":"Application with UAV data"},"content":"The canopy and soil temperatures were created in exercise \n\n501​-canopy​_and​_soil​_temperatures. As reminder these data were stored in a 3-band GeoTIFF file, with bands:\n\nLeaf Temperature (K)\n\nSoil Temperature (K)\n\nLocal correlation between lst and vnir inputs\n\nSo we will need to read the first two bands and stored them in two variables, t_c and t_s:\n\n# Define the input canopy and soil temperature rater\nuav_dir = workdir / \"input\" / \"UAV\" \n\ntc_ts_file = uav_dir / \"SLM_001_002_20140809_1041_TC-TS.tif\"\n\nfid = gdal.Open(str(tc_ts_file), gdal.GA_ReadOnly)\n# Read and store the 1st band (canopy temperature) in a numpy array\nt_c = fid.GetRasterBand(1).ReadAsArray()\n# Read and store the 2nd band (soil temperature) in a numpy array\nt_s = fid.GetRasterBand(2).ReadAsArray()\ndel fid\n\n# And it is assuming that the UAV mosaci is mostly looking at nadir\nvza = np.zeros_like(t_c)\nprint(\"Read the t_c and t_s temperatures\")\n\nprint(t_s)\n\n","type":"content","url":"/uav-tseb-2t#we-read-the-canopy-and-soil-temperatures","position":25},{"hierarchy":{"lvl1":"TSEB running with component Tc and Ts temperatures","lvl3":"We run now TSEB-2T","lvl2":"Application with UAV data"},"type":"lvl3","url":"/uav-tseb-2t#we-run-now-tseb-2t","position":26},{"hierarchy":{"lvl1":"TSEB running with component Tc and Ts temperatures","lvl3":"We run now TSEB-2T","lvl2":"Application with UAV data"},"content":"See Also\n\nThe full code for the TSEB-2T is at the \n\npyTSEB GitHub repository\n\nresistance_flag = [0, {\"KN_c\": np.full_like(t_c, roil_resistance_c_param),\n                       \"KN_b\": np.full_like(t_c, roil_resistance_b_param),\n                       \"KN_C_dash\": np.full_like(t_c, roil_resistance_cprime_param)}]\n\n# Run TSEB-2T\n[flag_2t, t_ac_2t, ln_s_2t, ln_c_2t, le_c_2t, h_c_2t, le_s_2t, h_s_2t, g_2t,\n r_s_2t, r_x_2t, r_a_2t, u_friction_2t, lmo_2t, n_iterations_2t] = TSEB.TSEB_2T(                                                     \n     t_c,\n     t_s,\n     ta,\n     ws,\n     ea,\n     pa,\n     sn_c,\n     sn_s,\n     lw_in,\n     lai,\n     h_c,\n     e_v,\n     e_s,\n     z_0m,\n     d_0,\n     zm,\n     zh,\n     x_LAD=np.ones_like(t_c),\n     f_c=f_c,\n     f_g=np.ones_like(t_c),\n     w_C=w_c_ratio,\n     leaf_width=leaf_width,\n     z0_soil=z0_soil,\n     resistance_form=resistance_flag,\n     calcG_params=[[1], 0.35])\n\n# ... and finally we compute the bulk fluxes\nle_2t = le_c_2t + le_s_2t\nh_2t = h_c_2t + h_s_2t\nnetrad_2t = sn_c + sn_s + ln_c_2t + ln_s_2t\n\n","type":"content","url":"/uav-tseb-2t#we-run-now-tseb-2t","position":27},{"hierarchy":{"lvl1":"TSEB running with component Tc and Ts temperatures","lvl4":"... and to compare we also run TSEB-PT","lvl3":"We run now TSEB-2T","lvl2":"Application with UAV data"},"type":"lvl4","url":"/uav-tseb-2t#id-and-to-compare-we-also-run-tseb-pt","position":28},{"hierarchy":{"lvl1":"TSEB running with component Tc and Ts temperatures","lvl4":"... and to compare we also run TSEB-PT","lvl3":"We run now TSEB-2T","lvl2":"Application with UAV data"},"content":"\n\n# Define the input composte radiometric temperature\nlst_file = input_dir / \"ExampleImage_Trad_pm.tif\"\n\nfid = gdal.Open(str(lst_file), gdal.GA_ReadOnly)\n# Read and store the 1st band (canopy temperature) in a numpy array\nlst = fid.GetRasterBand(1).ReadAsArray()\n\n\n# Run TSEB-PT\nalpha_PT_0 = 1.26\n[flag_pt, ts_pt, tc_pt, t_ac_pt, ln_s_pt, ln_c_pt, le_c_pt, h_c_pt, le_s_pt, h_s_pt, g_pt,\n r_s_pt, r_x_pt, r_a_pt, u_friction_pt, lmo_pt, n_iterations_pt] = TSEB.TSEB_PT(                                                     \n     lst,\n     vza,\n     ta,\n     ws,\n     ea,\n     pa,\n     sn_c,\n     sn_s,\n     lw_in,\n     lai,\n     h_c,\n     e_v,\n     e_s,\n     z_0m,\n     d_0,\n     zm,\n     zh,\n     x_LAD=np.ones_like(lst),\n     f_c=f_c,\n     f_g=np.ones_like(lst),\n     w_C=w_c_ratio,\n     leaf_width=leaf_width,\n     z0_soil=z0_soil,\n     alpha_PT=alpha_PT_0,\n     resistance_form=resistance_flag,\n     calcG_params=[[1], 0.35])\n\n# ... and we compute the bulk fluxes\nle_pt = le_c_pt + le_s_pt\nh_pt = h_c_pt + h_s_pt\nnetrad_pt = sn_c + sn_s + ln_c_pt + ln_s_pt\n\n","type":"content","url":"/uav-tseb-2t#id-and-to-compare-we-also-run-tseb-pt","position":29},{"hierarchy":{"lvl1":"TSEB running with component Tc and Ts temperatures","lvl4":"We compare both models","lvl3":"We run now TSEB-2T","lvl2":"Application with UAV data"},"type":"lvl4","url":"/uav-tseb-2t#we-compare-both-models","position":30},{"hierarchy":{"lvl1":"TSEB running with component Tc and Ts temperatures","lvl4":"We compare both models","lvl3":"We run now TSEB-2T","lvl2":"Application with UAV data"},"content":"\n\n# Change to have a different colour stretch\nhigh_flux=600 # Maximum flux value in the display\nlow_flux=0 # Minimum flux value in the display\n\nfrom bokeh.plotting import *\nfrom bokeh.palettes import RdYlBu11 as colortable\nfrom bokeh.models.mappers import LinearColorMapper\nfrom bokeh.io import output_notebook\nfrom bokeh.resources import INLINE\noutput_notebook(resources=INLINE)\n\ncolortable = list(reversed(colortable))\nmap_le = LinearColorMapper(palette=colortable,high=high_flux,low=low_flux)\nrows, cols = le_2t.shape\n\n# Setup the figure\ns1 = figure(title=\"TSEB-PT LE\",width=cols, height=rows, x_range=[0, cols], y_range=[0, rows])\ns1.axis.visible = False\ns1.image(image=[np.flipud(le_pt)],x=[0],y=[0],dw=cols,dh=rows,color_mapper=map_le)\ns2 = figure(title=\"TSEB-2T LE\",width=cols, height=rows, x_range=s1.x_range, y_range=s1.y_range)\ns2.axis.visible = False\ns2.image(image=[np.flipud(le_2t)],x=[0],y=[0],dw=[cols],dh=[rows],color_mapper=map_le)\ns3 = figure(title=\"TSEB-PT H\",width=cols, height=rows, x_range=s1.x_range, y_range=s1.y_range)\ns3.image(image=[np.flipud(h_pt)],x=[0],y=[0],dw=[cols],dh=[rows],color_mapper=map_le)\ns3.axis.visible = False\ns4 = figure(title=\"TSEB-2T H\",width=cols, height=rows, x_range=s1.x_range, y_range=s1.y_range)\ns4.image(image=[np.flipud(h_2t)],x=[0],y=[0],dw=[cols],dh=[rows],color_mapper=map_le)\ns4.axis.visible = False\np = gridplot([[s1, s2],[s3,s4]], toolbar_location='above')\n\n# Add a colormap legend\ny = np.linspace(low_flux,high_flux,len(colortable))\ndy = y[1]-y[0]\nramp = figure(tools=\"\", y_range = [0, 1], x_range = [low_flux,high_flux], width = 650, height=100)\nramp.toolbar_location = None\nramp.yaxis.visible = False\nramp.rect(x=y, y=0.5, color=colortable, width=dy, height = 1)\n\nshow(p)\nshow(ramp);\n\n","type":"content","url":"/uav-tseb-2t#we-compare-both-models","position":31},{"hierarchy":{"lvl1":"TSEB running with component Tc and Ts temperatures","lvl3":"Save the TSEB-2T outputs","lvl2":"Application with UAV data"},"type":"lvl3","url":"/uav-tseb-2t#save-the-tseb-2t-outputs","position":32},{"hierarchy":{"lvl1":"TSEB running with component Tc and Ts temperatures","lvl3":"Save the TSEB-2T outputs","lvl2":"Application with UAV data"},"content":"To conclude we will save our TSEB outputs to single band GeoTIFF files:\n\n# Set the output \noutdir = workdir / \"output\"\nif not outdir.exists():\n    outdir.mkdir()\n    \ndriver = gdal.GetDriverByName(\"GTiff\")\n\n# Latent heat flux\nout_file = outdir / \"SLM_001_002_20140809_1041_LE.tif\"\nfid = driver.Create(str(out_file), t_c.shape[1], t_c.shape[0], 1,\n                    gdal.GDT_Float32)\nfid.SetProjection(proj)\nfid.SetGeoTransform(gt)\nfid.GetRasterBand(1).WriteArray(le_2t)\n\n# Sensible heat flux\nout_file = outdir / \"SLM_001_002_20140809_1041_H.tif\"\nfid = driver.Create(str(out_file), t_c.shape[1], t_c.shape[0], 1,\n                    gdal.GDT_Float32)\nfid.SetProjection(proj)\nfid.SetGeoTransform(gt)\nfid.GetRasterBand(1).WriteArray(h_2t)\n\n# Net Radiation\nout_file = outdir / \"SLM_001_002_20140809_1041_NETRAD.tif\"\nfid = driver.Create(str(out_file), t_c.shape[1], t_c.shape[0], 1,\n                    gdal.GDT_Float32)\nfid.SetProjection(proj)\nfid.SetGeoTransform(gt)\nfid.GetRasterBand(1).WriteArray(netrad_2t)\n\n# Ground heat flux\nout_file = outdir / \"SLM_001_002_20140809_1041_G.tif\"\nfid = driver.Create(str(out_file), t_c.shape[1], t_c.shape[0], 1,\n                    gdal.GDT_Float32)\nfid.SetProjection(proj)\nfid.SetGeoTransform(gt)\nfid.GetRasterBand(1).WriteArray(g_2t)\n\ndel fid\n\nprint(f\"TSEB-2T fluxes saved at {out_file}\")\n\n","type":"content","url":"/uav-tseb-2t#save-the-tseb-2t-outputs","position":33},{"hierarchy":{"lvl1":"TSEB running with component Tc and Ts temperatures","lvl2":"Conclusions"},"type":"lvl2","url":"/uav-tseb-2t#conclusions","position":34},{"hierarchy":{"lvl1":"TSEB running with component Tc and Ts temperatures","lvl2":"Conclusions"},"content":"In this exercise we learned a new TSEB version available in pyTSEB\n\nIn addition, we saw that running the model over an image insteaf of a timeseries is practically the same\n\n[...]\n\nNote\n\nPlease feel free comment any thoughts. This is work in progress!!!","type":"content","url":"/uav-tseb-2t#conclusions","position":35},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery"},"type":"lvl1","url":"/uav-3seb","position":0},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery"},"content":"","type":"content","url":"/uav-3seb","position":1},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl2":"Summary"},"type":"lvl2","url":"/uav-3seb#summary","position":2},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl2":"Summary"},"content":"Interactive jupyter notebook showing the implementation of 3SEB with high resolution imagery obtained from uncrewed aerial vehicles (UAVs).\n\nThis notebook will go through the pre-processing of of 3SEB inputs and discuss different versions of 3SEB, including:\n\nSeparating leaf and soil temperatures using contextual methods\n\nPre-processing inputs and parameters to force 3SEB\n\nRunning 3SEB variants (3SEB-PT, 3SEB-2T and 3SEB-3T)\n\nEvaluating flux and temperature outputs against measurements\n\n","type":"content","url":"/uav-3seb#summary","position":3},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl2":"Instructions"},"type":"lvl2","url":"/uav-3seb#instructions","position":4},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl2":"Instructions"},"content":"Read all the text carefully and follow the instructions.\n\nHint\n\nOnce each section is read, run the jupyter code cell underneath (marked as []) by clicking the icon Run, or pressing the keys SHIFT+ENTER of your keyboard.\n\nTo start, please run the following cell to import all the packages required for this notebook. Once you run the cell below, an acknowledgement message, stating all libraries were correctly imported, should be printed on screen.\n\n","type":"content","url":"/uav-3seb#instructions","position":5},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl2":"Import Libraries"},"type":"lvl2","url":"/uav-3seb#import-libraries","position":6},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl2":"Import Libraries"},"content":"\n\n%matplotlib widget\nimport numpy as np\nfrom osgeo import gdal\nfrom pathlib import Path\nimport pandas as pd\nimport geopandas as gpd\nfrom pyTSEB import TSEB\nfrom pyTSEB import meteo_utils as met\nfrom pyTSEB import net_radiation as rad\nfrom pyTSEB import resistances as res\nfrom pyTSEB import energy_combination_ET as EC\nfrom py3seb import  py3seb \nimport matplotlib.pyplot as plt\nfrom osgeo import gdal\nimport pyDMS.pyDMSUtils as gu\nimport matplotlib.patches as mpatches\nfrom matplotlib.colors import ListedColormap\n\nprint('libraries imported correctly!')\n\n","type":"content","url":"/uav-3seb#import-libraries","position":7},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl2":"The leaf and soil temperatures in 3SEB"},"type":"lvl2","url":"/uav-3seb#the-leaf-and-soil-temperatures-in-3seb","position":8},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl2":"The leaf and soil temperatures in 3SEB"},"content":"In 3SEB, the evapotranspiration (ET) and energy fluxes from overstory vegetation, understory vegetation and soil components are solved for each component layer. For adequate flux partitioning accross landscape sources, we need estimates of overstory canopy (T_C), understory canopy (T_{C, sub})  and soil (T_S) temperatures to retrieve sensible heat fluxes from the different sources. In the orginal formulation of 3SEB, the resistance framework is first treated as a parallel (i.e., uncoupled) tree-substrate system to obtain tree canopy sensible heat flux (H_C) and substrate (understory vegetation+soil) (H_{sub}) using the heat transport equations:H_C &= \\rho C_p \\frac{T_C - T_{a}} {R_A}\\\\\nH_{sub} &= \\rho C_p \\frac{T_{sub} - T_{a}} {R_A+R_{sub}}\n\nSubsequently, the substrate fluxes and temperatures are further separated incorporating a series (i.e. coupled) approach:H_{C,sub} &= \\rho C_p \\frac{T_{C,sub} - T_{ac}} {R_X}\\\\\nH_s &= \\rho C_p \\frac{T_S - T_{ac}} {R_S}\n\nSince T_C, T_{C,sub} and T_S are unknown apriori, the original 3SEB formulation (3SEB-PT) implements a Priestley-Taylor (PT) formulation, as in \n\nNorman et al. (1995), to compute a first estimate of the canopy LE and H for both overstory and understory.\n\nFor more information on the 3SEB-PT resistance scheme, refer to \n\nBurchard-Levine et al., 2022\n\nHowever, the use of very high spatial TIR imagery can be especially relevant in row crops with wide spacing and clumped vegetation such as almond orchards where we can directly retrieve these different component temperatures and avoid the initial assumptions of potential transpiration made with the PT formulation. However, in the case of tree crops that have cover crops over the rows, it becomes more difficult to directly separate the cover crop temperature from the soil component. As such, in this exercise, we will consider different 3SEB versions that assume that the temperature retrived over the cover crop refers to canopy temperature T_{C,sub} and another that assumes that is the combined substrate (vegetation+soil) temperature (T_{sub}).","type":"content","url":"/uav-3seb#the-leaf-and-soil-temperatures-in-3seb","position":9},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl2":"3SEB versions"},"type":"lvl2","url":"/uav-3seb#id-3seb-versions","position":10},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl2":"3SEB versions"},"content":"In this notebook, we will implement three different 3SEB versions:\n\n3SEB-PT: implements a double Priestley-Taylor transpiration initialization for each vegetation canopy (i.e. tree and grass)\n\n3SEB-2T: acquires tree and substrate temperature from high resolution imagery and implements a PT initalization in the substrate\n\n3SEB-3T: acquires tree , cover crop and soil temperatures directly from high resolution imagery\n\nAlso for comparison purposes, we will also run TSEB-PT.\n\nWarning\n\n3SEB-2T and 3SEB-3T are very new developments and have not yet been extensively tested. It has not been published yet and may need further refinements.\n\nThis is work in progress so we are happy to receive any feedback!!\n\nImportant\n\nWhile UAV technology can provide very high spatial resolution information, we have to be aware that TSEB/3SEB, as well as most of the resistance-based energy balance models, must be applied at an adequate spatial domain to comply to the assumptions and the physical formulations inherent in it. Therefore, it is not possible to run TSEB/3SEB at leaf-level scale (i.e. 10cm), as the formulations of radiative transfer and turbulent exchange that it relies upon, require to run TSEB/3SEB at a scale in the order of meters.","type":"content","url":"/uav-3seb#id-3seb-versions","position":11},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl2":"Case study and dataset"},"type":"lvl2","url":"/uav-3seb#case-study-and-dataset","position":12},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl2":"Case study and dataset"},"content":"We will implement 3SEB over an experimental almond orchard located in California, USA.\n\n\n\nFigure 1:Experimental design of Almond orchards with different irrigation treatments and cover crop (CC) presence (surface irrgation+CC, surface irrigation+NoCC, subsurface irrigation+CC, subsurface irrigation+noCC). The cover crop at this field is a low-growing, perennial grass (appx. 5 cm at peak biomass in March/April) called Oakville bluegrass (Radix Poa bulbosa).\n\nTo reduce computational needs, we will work only on the surface irrigation + cover crop treatment (Conv + CC or Surface_CC) in the bottom left quadrant of the orchard.\n\n","type":"content","url":"/uav-3seb#case-study-and-dataset","position":13},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl2":"Generating 3SEB inputs: separating temperature components"},"type":"lvl2","url":"/uav-3seb#generating-3seb-inputs-separating-temperature-components","position":14},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl2":"Generating 3SEB inputs: separating temperature components"},"content":"Since the UAV imagery have a very high spatial resolution (<10cm), we can retrive effective leaf/canopy and soil temperatures directly from the imagery.\n\nTo effectively separate the different temperature components, we will use both NDVI and canopy height models (CHM) as constraints. The later especially useful to separate tree and cover crop temperatures.\n\nNote\n\nThis is just an example of one simple method that can be used to retrieve the different component temperatures. Other methods can also be applied.\n\n","type":"content","url":"/uav-3seb#generating-3seb-inputs-separating-temperature-components","position":15},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl3":"Open and visualize imagery","lvl2":"Generating 3SEB inputs: separating temperature components"},"type":"lvl3","url":"/uav-3seb#open-and-visualize-imagery","position":16},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl3":"Open and visualize imagery","lvl2":"Generating 3SEB inputs: separating temperature components"},"content":"\n\n# workdir \ndatadir = Path('./dataset')\nuav_dir = datadir / 'uav_imagery'\n\n# ndvi\nndvi_file = uav_dir / f'ndvi_surface_CC_10cm.tif'\nndvi_fid = gdal.Open(str(ndvi_file))\nndvi_ar = ndvi_fid.GetRasterBand(1).ReadAsArray()\n\n# canopy height\nch_file = uav_dir / f'chm_surface_CC_10cm.tif'\nch_fid = gdal.Open(str(ch_file))\nch_ar = ch_fid.GetRasterBand(1).ReadAsArray()\n#ch_ar[ch_ar<0] = np.nan\nch_ar[ch_ar>20] = np.nan\n\n# land surface temperature\nlst_file = uav_dir / f'lst_surface_CC_10cm.tif'\nlst_fid = gdal.Open(str(lst_file))\nlst_ar = lst_fid.GetRasterBand(1).ReadAsArray()\n\n# use LST as template for raster info\n## Get raster size\ncols = lst_fid.RasterXSize\nrows = lst_fid.RasterYSize\n## geotransform\ngt = lst_fid.GetGeoTransform()\nminx, maxy = gt[0], gt[3]\nmaxx = minx + gt[1]*cols\nminy = maxy + gt[5]*rows\n## extent\nte = [minx, maxx, miny, maxy]\n## spatial projection\nproj = lst_fid.GetProjection()\n\n# plot UAV imagery inputs to visualize\nfig, axes = plt.subplots(2,3, figsize = (14,10), constrained_layout=True)\nax1 = axes[0,0]\nim1 = ax1.imshow(lst_ar, cmap='Spectral_r', vmin=300, vmax=320, extent = te)\nax1.set_title('LST')\nax1.set_axis_off()\n\n\nax2 = axes[0,1]\nim2 = ax2.imshow(ndvi_ar, cmap='YlGn', vmin=0.3, vmax=0.8, extent = te)\nax2.set_title('NDVI')\nax2.set_axis_off()\n\n\nax3 = axes[0,2]\nim3 = ax3.imshow(ch_ar, cmap='viridis', vmin=0., vmax=5, extent = te)\nax3.set_title('Canopy Height (CH)')\nax3.set_axis_off()\n\n\n# zoom in\nax4 = axes[1,0]\nim4 = ax4.imshow(lst_ar, cmap='Spectral_r', vmin=300, vmax=320, extent = te)\nax4.set_xlim(655290, 655320)\nax4.set_ylim(4156800, 4156830)\ncb = plt.colorbar(im4, ax=ax4, orientation='horizontal', ticks=[300, 305, 310, 315, 320])\ncb.set_label('LST (K)', fontsize=14)\nax4.set_axis_off()\n\nax5 = axes[1,1]\nim5 = ax5.imshow(ndvi_ar, cmap='YlGn', vmin=0.3, vmax=0.8, extent = te)\nax5.set_xlim(655290, 655320)\nax5.set_ylim(4156800, 4156830)\ncb = plt.colorbar(im5, ax=ax5, orientation='horizontal')\ncb.set_label('NDVI', fontsize=14)\nax5.set_axis_off()\n\nax6 = axes[1,2]\nim6 = ax6.imshow(ch_ar, cmap='viridis', vmin=0., vmax=5, extent = te)\nax6.set_xlim(655290, 655320)\nax6.set_ylim(4156800, 4156830)\ncb = plt.colorbar(im6, ax=ax6, orientation='horizontal')\ncb.set_label('CH (m)', fontsize=14)\nax6.set_axis_off()\n\nplt.show()\n\n","type":"content","url":"/uav-3seb#open-and-visualize-imagery","position":17},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl3":"Obtaining component tempeatures from contextual method","lvl2":"Generating 3SEB inputs: separating temperature components"},"type":"lvl3","url":"/uav-3seb#obtaining-component-tempeatures-from-contextual-method","position":18},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl3":"Obtaining component tempeatures from contextual method","lvl2":"Generating 3SEB inputs: separating temperature components"},"content":"We will obtain T_C, T_{C,sub} and T_S by searching for pure vegetation and soil pixels in a contextual spatial domain . That is, in a coarse resolution spatial grid, consistent with the TSEB physical assumptions, we will assign for each of its cells the canopy and soil temperatures corresponding to the average temperature for the original LST resoltuion pixels that are considered, respectively, bare soil, cover crop vegetation and tree crop vegetation.\n\nNote\n\nIn this case we assume that TSEB will be run at 8 m spatial resolution, as it is spatial domain large enough to include the canopy/interrow system in order to be consistent with the radiative transfer modelling in the rows.\n\nIn this example, we simply consider:\n\ntree crops as pixels with NDVI > 0.8 & canopy heights > 1.5m\n\ncover crops as pixels with NDVI > 0.8 & canopy heights < 0.4m\n\nsoil as pixels with NDVI < 0.4 & canopy heights < 0.4\n\nWe will create masks for each of these conditions to isolate the component temperatures of each landscape source (i.e., tree crop, cover crop and soil)\n\nWarning\n\nNote that these pure vegetation and soil NDVI values, along with crop height, might change due to different spectral cameras and different crop/soil types.\n\nNote\n\nOther more sophisticated classifcation algorithms (e.g. LULC classificationn with RF) can be applied to better separate the different landscape components. This is just a simple illustrative example.\n\n# RGB file \nrgb_file = uav_dir / f'rgb_surface_CC_10cm.tif'\nrgb_fid = gdal.Open(str(rgb_file))\nblue_ar = rgb_fid.GetRasterBand(1).ReadAsArray()\ngreen_ar = rgb_fid.GetRasterBand(2).ReadAsArray()\nred_ar = rgb_fid.GetRasterBand(2).ReadAsArray()\n# stack arrays\nrgb_image = np.dstack((red_ar, green_ar, blue_ar))\n# make image brighter for visualization\nrgb_image = np.clip(rgb_image * 1.5, 0, 255) / 255\n\n# set up masks to isolate different \n# overstory mask \nmask_ov = np.logical_and(ndvi_ar > 0.8, ch_ar > 1.5)\n\n# understory mask \nmask_un = np.logical_and(ndvi_ar > 0.8, ch_ar < 0.4)\n\n# soil mask \nmask_soil = np.logical_and(ndvi_ar < 0.4, ch_ar < 0.4)\n\n# substrate mask \nmask_sub = np.logical_or(mask_un, mask_soil)\n\n# Tc\nTc_ar = lst_ar.copy()\n## all non-tree pixels as nan\nTc_ar[~mask_ov] = np.nan\n\n# Tc_sub\nTc_sub_ar = lst_ar.copy()\n## all non-grass pixels as nan\nTc_sub_ar[~mask_un] = np.nan\n\n#Ts\nTs_ar = lst_ar.copy()\n## all non-soil pixels as nan\nTs_ar[~mask_soil] = np.nan\n\n#Tsub \nTsub_ar = lst_ar.copy()\n## all non-substrate pixels as nan\nTsub_ar[~mask_un] = np.nan\n\n## create classification array\nclass_ar = lst_ar.copy()\nclass_ar[:] = np.nan\nclass_ar[mask_ov] = 1\nclass_ar[mask_un] = 2\nclass_ar[mask_soil] = 3\n\n# Define discrete colors for each category (1=tree, 2=grass, 3=soil)\ncmap = ListedColormap(['darkgreen', 'yellowgreen', 'saddlebrown'])\n\n# Define a normalization so the values map to 0, 1, 2 in the colormap\nbounds = [0.5, 1.5, 2.5, 3.5]\nnorm = plt.matplotlib.colors.BoundaryNorm(bounds, cmap.N)\n\n\nfig, axes = plt.subplots(2,2, figsize = (12,10), constrained_layout=True)\nax1 = axes[0,0]\nimg = ax1.imshow(class_ar, cmap=cmap, norm=norm, extent=te)\n\n# Create legend manually\nlegend_labels = {\n    1: 'Tree Crop',\n    2: 'Cover crop',\n    3: 'Soil'\n}\nlegend_colors = ['darkgreen', 'yellowgreen', 'saddlebrown']\n\npatches = [mpatches.Patch(color=legend_colors[i], label=legend_labels[i+1]) for i in range(3)]\nax1.legend(handles=patches, loc='upper right')\n#ax1.set_xlim(655290, 655320)\n#ax1.set_ylim(4156750, 4156780)\nax1.set_axis_off()\n\n\nax2 = axes[0,1]\nax2.imshow(class_ar, cmap=cmap, norm=norm, extent = te, alpha=1)\n#ax2.imshow(lst_ar, cmap='Spectral_r', vmin=300, vmax=320, extent = te, alpha=0.8)\n\nax2.set_xlim(655288, 655320)\nax2.set_ylim(4156800, 4156830)\nax2.set_axis_off()\n\nax3 = axes[1,0]\nim3 = ax3.imshow(lst_ar, cmap='Spectral_r', vmin=300, vmax=320, extent = te)\n\nax3.set_xlim(655288, 655320)\nax3.set_ylim(4156800, 4156830)\nax3.set_axis_off()\n\n#cb = plt.colorbar(im3, ax=ax3, orientation='vertical', shrink = 0.65)\n#cb.set_label('LST (K)', fontsize=14)\nax4 = axes[1,1]\nim4 = ax4.imshow(rgb_image, extent = te)\nax4.set_xlim(655288, 655320)\nax4.set_ylim(4156800, 4156830)\nax4.set_axis_off()\n\n#ax3.set_xlim(655290, 655320)\n#cb.set_label('CH (m)', fontsize=14)\nplt.show()\n\n","type":"content","url":"/uav-3seb#obtaining-component-tempeatures-from-contextual-method","position":19},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl2":"Save component temperature imagery and fractional covers"},"type":"lvl2","url":"/uav-3seb#save-component-temperature-imagery-and-fractional-covers","position":20},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl2":"Save component temperature imagery and fractional covers"},"content":"We will take advantage of this high resoltion imagery to calcualte the fractional covers of each landscape source (tree crop, cover crop and soil). We will save these as geotiff to then later resampled to 8m as inputs for TSEB/3SEB.\n\n# fc (tree canopy fraction)\nfc_ar = lst_ar.copy()\nfc_ar[mask_ov] = 1\nfc_ar[~mask_ov] = 0\n\n# fs (soil fraction)\nfs_ar = lst_ar.copy()\nfs_ar[mask_soil] = 1\nfs_ar[~mask_soil] = 0\n\n# fc_sub (cover crop fraction)\nfc_sub_ar = lst_ar.copy()\nfc_sub_ar[mask_un] = 1\nfc_sub_ar[~mask_un] = 0\n\n# set up filename for outputs (fractional covers)\n## tree crop fraction\noutfile_fc_mask = uav_dir / f'Fc_surface_CC_10cm.tif'\n## cover crop fraction\noutfile_fc_sub_mask = uav_dir / f'Fc_sub_surface_CC_10cm.tif'\n## soil fraction\noutfile_fs_mask = uav_dir / f'Fs_sub_surface_CC_10cm.tif'\n\n# set up filename for outputs (component temperatures)\noutfile_Tc = uav_dir / f'Tc_surface_CC_10cm.tif'\noutfile_Tc_sub = uav_dir / f'Tc_sub_surface_CC_10cm.tif'\noutfile_Ts = uav_dir / f'Ts_surface_CC_10cm.tif'\noutfile_Tsub= uav_dir / f'Tsub_surface_CC_10cm.tif'\n\nrows, cols = np.shape(lst_ar)\n\nprint('Saving inputs at 10cm...')\n# Save output\ninput_nodata = np.nan\ndriver = gdal.GetDriverByName('GTiff')\n# Tc\nds = driver.Create(str(outfile_Tc), cols, rows, 1, gdal.GDT_Float32)\nds.SetGeoTransform(gt)\nds.SetProjection(proj)\nband = ds.GetRasterBand(1)\nband.SetNoDataValue(input_nodata)\nband.WriteArray(Tc_ar)\nband.FlushCache()\nds.FlushCache()\ndel ds\n\n#Tc_sub\nds = driver.Create(str(outfile_Tc_sub), cols, rows, 1, gdal.GDT_Float32)\nds.SetGeoTransform(gt)\nds.SetProjection(proj)\nband = ds.GetRasterBand(1)\nband.SetNoDataValue(input_nodata)\nband.WriteArray(Tc_sub_ar)\nband.FlushCache()\nds.FlushCache()\ndel ds \n\n#Ts\nds = driver.Create(str(outfile_Ts), cols, rows, 1, gdal.GDT_Float32)\nds.SetGeoTransform(gt)\nds.SetProjection(proj)\nband = ds.GetRasterBand(1)\nband.SetNoDataValue(input_nodata)\nband.WriteArray(Ts_ar)\nband.FlushCache()\nds.FlushCache()\ndel ds\n\n#Tsub\nds = driver.Create(str(outfile_Tsub), cols, rows, 1, gdal.GDT_Float32)\nds.SetGeoTransform(gt)\nds.SetProjection(proj)\nband = ds.GetRasterBand(1)\nband.SetNoDataValue(input_nodata)\nband.WriteArray(Tsub_ar)\nband.FlushCache()\nds.FlushCache()\ndel ds\n\n#Fc\nds = driver.Create(str(outfile_fc_mask), cols, rows, 1, gdal.GDT_Float32)\nds.SetGeoTransform(gt)\nds.SetProjection(proj)\n\nband = ds.GetRasterBand(1)\nband.SetNoDataValue(input_nodata)\nband.WriteArray(fc_ar)\nband.FlushCache()\nds.FlushCache()\ndel ds \n\n#Fs\nds = driver.Create(str(outfile_fs_mask), cols, rows, 1, gdal.GDT_Float32)\nds.SetGeoTransform(gt)\nds.SetProjection(proj)\n\nband = ds.GetRasterBand(1)\nband.SetNoDataValue(input_nodata)\nband.WriteArray(fs_ar)\nband.FlushCache()\nds.FlushCache()\ndel ds \n\n#Fc_sub\nds = driver.Create(str(outfile_fc_sub_mask), cols, rows, 1, gdal.GDT_Float32)\nds.SetGeoTransform(gt)\nds.SetProjection(proj)\nband = ds.GetRasterBand(1)\nband.SetNoDataValue(input_nodata)\nband.WriteArray(fc_sub_ar)\nband.FlushCache()\nds.FlushCache()\ndel ds\n\nprint('Done!')\n\nNote\n\nYou can also visualize these outputs in QGIS","type":"content","url":"/uav-3seb#save-component-temperature-imagery-and-fractional-covers","position":21},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl2":"Obtain average component temperatures over 8m grids"},"type":"lvl2","url":"/uav-3seb#obtain-average-component-temperatures-over-8m-grids","position":22},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl2":"Obtain average component temperatures over 8m grids"},"content":"We now need to obtain the average component temperatures at 8m grids. The next code block visualizes this.\n\n# visualize grid layers\nvector_dir = datadir / 'vector_data'\ngrids_file = vector_dir / 'Grids_8m_surface_CC.geojson'\ngrids_df = gpd.read_file(grids_file, on_invalid=\"warn\")\n\n\nfig, axes = plt.subplots(1,3, figsize = (14,6), constrained_layout=True)\nax1 = axes[0]\nimg = ax1.imshow(rgb_image, extent=te)\ngrids_df.plot(ax=ax1, facecolor='none', edgecolor='white', linewidth=2, alpha=0.9, label='8m grids')\n\nlegend_element = mpatches.Patch(facecolor='none', edgecolor='white', label='8m grids')\n\nax1.legend(handles=[legend_element])\n\nax1.set_xlim(655288, 655320)\nax1.set_ylim(4156800, 4156830)\nax1.set_title('RGB', fontsize=16)\nax1.set_axis_off()\n\n#ax1.set_xlim(655290, 655320)\n#ax1.set_ylim(4156750, 4156780)\n\n# Define discrete colors for each category (1=tree, 2=grass, 3=soil)\ncmap = ListedColormap(['darkgreen', 'yellowgreen', 'saddlebrown'])\n\n# Define a normalization so the values map to 0, 1, 2 in the colormap\nbounds = [0.5, 1.5, 2.5, 3.5]\nnorm = plt.matplotlib.colors.BoundaryNorm(bounds, cmap.N)\nax2 = axes[1]\nax2.imshow(class_ar, cmap=cmap, norm=norm, extent = te, alpha=1)\n#grids_df.plot(ax=ax2, facecolor='none', edgecolor='orange', linewidth=1)\ngrids_df.plot(ax=ax2, facecolor='none', edgecolor='k', linewidth=2, alpha=0.9, label='8m grids')\n\nlegend_element = mpatches.Patch(facecolor='none', edgecolor='k', label='8m grids')\n\nax2.legend(handles=[legend_element])\n#ax2.imshow(lst_ar, cmap='Spectral_r', vmin=300, vmax=320, extent = te, alpha=0.8)\n\nax2.set_xlim(655288, 655320)\nax2.set_ylim(4156800, 4156830)\nax2.set_title('Pure component pixel selection', fontsize=16)\nax2.set_axis_off()\n\nax3 = axes[2]\nim3 = ax3.imshow(lst_ar, cmap='Spectral_r', vmin=300, vmax=320, extent = te)\ngrids_df.plot(ax=ax3, facecolor='none', edgecolor='k', linewidth=2, alpha=0.9, label='8m grids')\n\nax3.set_xlim(655288, 655320)\nax3.set_ylim(4156800, 4156830)\ncb = plt.colorbar(im3, ax=ax3, orientation='vertical', shrink = 0.65)\ncb.set_label('LST (K)', fontsize=14)\nax3.set_title('LST', fontsize=16)\nax3.legend(handles=[legend_element])\nax3.set_axis_off()\n\nplt.show()\n\n\n\n","type":"content","url":"/uav-3seb#obtain-average-component-temperatures-over-8m-grids","position":23},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl3":"Getting average source values with GDAL","lvl2":"Obtain average component temperatures over 8m grids"},"type":"lvl3","url":"/uav-3seb#getting-average-source-values-with-gdal","position":24},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl3":"Getting average source values with GDAL","lvl2":"Obtain average component temperatures over 8m grids"},"content":"In this case, we will simply calculate the average LST values of each surface source (tree crop, cover and soil) at the 8m scale by using a mask for each source. For example, for tree crops, we mask out all non-tree crop pixels as ‘nan’ at 10cm scale and then get average values of all non-nan pixels within each 8m grid.","type":"content","url":"/uav-3seb#getting-average-source-values-with-gdal","position":25},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl4":"save resampled grids to file","lvl3":"Getting average source values with GDAL","lvl2":"Obtain average component temperatures over 8m grids"},"type":"lvl4","url":"/uav-3seb#save-resampled-grids-to-file","position":26},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl4":"save resampled grids to file","lvl3":"Getting average source values with GDAL","lvl2":"Obtain average component temperatures over 8m grids"},"content":"\n\n# resample to 8m \ntarget_res = 8\n\n# set up outputfile name\noutfile_fc_8m = uav_dir / f'Fc_surface_CC_{target_res}m.tif'\noutfile_fc_sub_8m = uav_dir / f'Fc_sub_surface_CC_{target_res}m.tif'\noutfile_fs_8m = uav_dir / f'Fs_surface_CC_{target_res}m.tif'\n\noutfile_Tc_8m = uav_dir / f'Tc_surface_CC_{target_res}m.tif'\noutfile_Tc_sub_8m = uav_dir / f'Tc_sub_surface_CC_{target_res}m.tif'\noutfile_Ts_8m = uav_dir / f'Ts_surface_CC_{target_res}m.tif'\noutfile_Tsub_8m = uav_dir / f'Tsub_surface_CC_{target_res}m.tif'\n\noutfile_lst_8m = uav_dir / f'lst_surface_CC_{target_res}m.tif'\n\n# also chm \noutfile_chm_8m = uav_dir / f'Hc_surface_CC_{target_res}m.tif'\nprint(f'Resampling inputs to {target_res}m...')\n\n# fractional covers\ngdal.Warp(str(outfile_fc_8m), str(outfile_fc_mask), format='Gtiff', xRes=target_res, yRes=target_res, resampleAlg= 'average')\ngdal.Warp(str(outfile_fc_sub_8m), str(outfile_fc_sub_mask), format='Gtiff', xRes=target_res, yRes=target_res, resampleAlg= 'average')\ngdal.Warp(str(outfile_fs_8m), str(outfile_fs_mask), format='Gtiff', xRes=target_res, yRes=target_res, resampleAlg= 'average')\n\n# component temperatures\ngdal.Warp(str(outfile_Tc_8m), str(outfile_Tc), format='Gtiff', xRes=target_res, yRes=target_res, resampleAlg= 'min')\ngdal.Warp(str(outfile_Tc_sub_8m), str(outfile_Tc_sub), format='Gtiff', xRes=target_res, yRes=target_res, resampleAlg= 'min')\ngdal.Warp(str(outfile_Ts_8m), str(outfile_Ts), format='Gtiff', xRes=target_res, yRes=target_res, resampleAlg= 'average')\ngdal.Warp(str(outfile_Tsub_8m), str(outfile_Tsub), format='Gtiff', xRes=target_res, yRes=target_res, resampleAlg= 'average')\n\ngdal.Warp(str(outfile_lst_8m), str(lst_file), format='Gtiff', xRes=target_res, yRes=target_res, resampleAlg= 'average')\n\n# Also canopy height (get maximum in this case as this best describes surface roughness)\ngdal.Warp(str(outfile_chm_8m), str(ch_file), format='Gtiff', xRes=target_res, yRes=target_res, resampleAlg= 'max')\n\nprint(f'Done!')\n\n","type":"content","url":"/uav-3seb#save-resampled-grids-to-file","position":27},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl2":"Visualize resampled inputs"},"type":"lvl2","url":"/uav-3seb#visualize-resampled-inputs","position":28},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl2":"Visualize resampled inputs"},"content":"We can now open and visualize the temperature inputs we will use to run TSEB/3SEB\n\n# LST\nlst_file = uav_dir / 'lst_surface_CC_8m.tif'\nlst_fid = gdal.Open(str(lst_file))\nlst_ar = lst_fid.GetRasterBand(1).ReadAsArray()\nlst_ar[np.logical_or(lst_ar<275,lst_ar>400)] = np.nan\n\n# Tree crop temperature\nTc_file = uav_dir / 'Tc_surface_CC_8m.tif'\nTc_fid = gdal.Open(str(Tc_file))\nTc_ar = Tc_fid.GetRasterBand(1).ReadAsArray()\nTc_ar[np.logical_or(Tc_ar<275,Tc_ar>400)] = np.nan\n\n# Cover crop temperature\nTcc_file = uav_dir / 'Tc_sub_surface_CC_8m.tif'\nTcc_fid = gdal.Open(str(Tcc_file))\nTcc_ar = Tcc_fid.GetRasterBand(1).ReadAsArray()\nTcc_ar[np.logical_or(Tcc_ar<275,Tcc_ar>400)] = np.nan\n\n# Soil temperature\nTs_file = uav_dir / 'Ts_surface_CC_8m.tif'\nTs_fid = gdal.Open(str(Ts_file))\nTs_ar = Ts_fid.GetRasterBand(1).ReadAsArray()\nTs_ar[np.logical_or(Ts_ar<200,Ts_ar>500)] = np.nan\n\n# Soil temperature\nTsub_file = uav_dir / 'Tsub_surface_CC_8m.tif'\nTsub_fid = gdal.Open(str(Tsub_file))\nTsub_ar = Tsub_fid.GetRasterBand(1).ReadAsArray()\nTsub_ar[np.logical_or(Tsub_ar<200,Tsub_ar>500)] = np.nan\n\n\n\n# tree crop fractional cover\nFc_file = uav_dir / 'Fc_surface_CC_8m.tif'\nFc_fid = gdal.Open(str(Fc_file))\nFc_ar = Fc_fid.GetRasterBand(1).ReadAsArray()\nFc_ar[np.isnan(lst_ar)] = np.nan\n\n# soil fractional cover\nFs_file = uav_dir / 'Fs_surface_CC_8m.tif'\nFs_fid = gdal.Open(str(Fs_file))\nFs_ar = Fs_fid.GetRasterBand(1).ReadAsArray()\nFs_ar[np.isnan(lst_ar)] = np.nan\n\n\n# Cover crop fractional cover\nFcc_file = uav_dir / 'Fc_sub_surface_CC_8m.tif'\nFcc_fid = gdal.Open(str(Fcc_file))\nFcc_ar = Fcc_fid.GetRasterBand(1).ReadAsArray()\nFcc_ar[np.isnan(lst_ar)] = np.nan\n\n# the above Fcc refers to total landscape fraction of cover crop\n# we need to adjust this to obtain the fraction of cover crop over the substrate (cover crop + soil)\n# because this is the input that is needed in 3SEB\nFcc_ar = Fcc_ar / (Fcc_ar+Fs_ar)\n\n# Tree crop Canopy height model\nchm_file = uav_dir / 'Hc_surface_CC_8m.tif'\nHc_fid = gdal.Open(str(chm_file))\nHc_ar = Hc_fid.GetRasterBand(1).ReadAsArray()\nHc_ar[np.logical_or(Hc_ar==0,Hc_ar>10)] = np.nan\n\n# get raster metadata \n # get extent and info from reference dataset\nprj = lst_fid.GetProjection()\nulx, xres, xskew, uly, yskew, yres = lst_fid.GetGeoTransform()\nlrx = ulx + (lst_fid.RasterXSize * xres)\nlry = uly + (lst_fid.RasterYSize * yres)\n\nte = [minx, lrx, lry, uly]\n\n# plot UAV-based inputs\nfig, axes = plt.subplots(2,2, figsize=(12,10))\nax = axes[0,0]\nim = ax.imshow(lst_ar, vmin=290, vmax=320, cmap='coolwarm', extent = te)\nax.set_title('LST - Land Surface Temperature')\nax.set_axis_off()\n\n# Add colorbar for only axes[0, 0]\ncbar = fig.colorbar(im, ax=ax)\ncbar.set_label('LST (K)')  # Add title to colorbar\nmean_value = np.nanmean(lst_ar)\nax.text(1, 70, f'mean: {np.round(mean_value,2)}')\nax = axes[0,1]\nim = ax.imshow(Tc_ar, vmin=290, vmax=320, cmap='coolwarm',  extent = te)\nax.set_title('$T_c$ - Tree crop temperature')\n# Add colorbar for only axes[0, 0]\ncbar = fig.colorbar(im, ax=ax)\ncbar.set_label('$T_c$ (K)')  # Add title to colorbar\nmean_value = np.nanmean(Tc_ar)\nax.text(1, 70, f'mean: {np.round(mean_value,2)}')\nax.set_axis_off()\n\nax = axes[1,0]\nim = ax.imshow(Tcc_ar, vmin=290, vmax=320, cmap='coolwarm',  extent = te)\nax.set_title('$T_{c,sub}$ - Cover crop temperature')\n# Add colorbar for only axes[0, 0]\ncbar = fig.colorbar(im, ax=ax)\ncbar.set_label('$T_c$ (K)')  # Add title to colorbar\nax.set_axis_off()\n\nax = axes[1,1]\nim = ax.imshow(Ts_ar, vmin=290, vmax=320, cmap='coolwarm',  extent = te)\nax.set_title('$T_S$ - Soil temperature')\n# Add colorbar for only axes[0, 0]\ncbar = fig.colorbar(im, ax=ax)\ncbar.set_label('Ts (K)')  # Add title to colorbar\nax.set_axis_off()\n\n\nplt.show()\n\n","type":"content","url":"/uav-3seb#visualize-resampled-inputs","position":29},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl2":"Other inputs and parameters"},"type":"lvl2","url":"/uav-3seb#other-inputs-and-parameters","position":30},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl2":"Other inputs and parameters"},"content":"Now that we have the main UAV-based inputs, we will now set up the rest of parameters and inputs to run TSEB/3SEB","type":"content","url":"/uav-3seb#other-inputs-and-parameters","position":31},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl3":"Meterological forcings","lvl2":"Other inputs and parameters"},"type":"lvl3","url":"/uav-3seb#meterological-forcings","position":32},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl3":"Meterological forcings","lvl2":"Other inputs and parameters"},"content":"obtain meteo/EC data needed to run and evaluate TSEB/3SEB. In this case, we will obtain it from the in-situ EC tower located in the study site.\n\n# meteo\nmeteo_file = datadir /'insitu'/ 'WES_CSI_Format.csv'\nmeteo_ds = pd.read_csv(meteo_file, skiprows = [0,2,3])\n# soil data\nsoil_file =  datadir /'insitu'/ 'WES_Soil.dat'\nsoil_ds = pd.read_csv(soil_file, sep='\\t')\nmeteo_ds\n\n","type":"content","url":"/uav-3seb#meterological-forcings","position":33},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl3":"Extract Meteo data over overpass time","lvl2":"Other inputs and parameters"},"type":"lvl3","url":"/uav-3seb#extract-meteo-data-over-overpass-time","position":34},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl3":"Extract Meteo data over overpass time","lvl2":"Other inputs and parameters"},"content":"The UAV imagery was acquired on 2024-04-16 between 10:45-11:15 (standard time) so we take the sampling timestep of 11:00 to extract the meterological forcings.\n\n# study site information\nlat = 37.5456694\nlon = -121.2420336\nstdlon = -120\n\n# height of sensor measurements\nz_u = 5.5 # height wind speed measurement(m)\nz_t = 5.5 # height air temperature measurement(m)\n\n\ndate_mask = meteo_ds['TIMESTAMP'] == '4/16/24 11:00'\ndate_ts = pd.to_datetime('16/4/24 11:00')\n\nhour = date_ts.hour\n\ndoy = date_ts.dayofyear\n\n# sun zenith and azimuth angles\nsza, saa = met.calc_sun_angles(np.ones_like(Tc_ar) * lat,\n                                   np.ones_like(Tc_ar) * lon,\n                                   np.ones_like(Tc_ar) * stdlon,\n                                   np.ones_like(Tc_ar) * doy,\n                                   np.ones_like(Tc_ar) * hour)\nsza[sza > 90] = 90\n\nTa = meteo_ds['TA_3_1_1'].values[date_mask][0] + 273.15\nTa_ar = np.ones(Tc_ar.shape) * Ta\n\nEa = meteo_ds['e'].values[date_mask][0] * 10\nEa_ar = np.ones(Tc_ar.shape) * Ea\n\nU = meteo_ds['WS'].values[date_mask][0]\nU_ar = np.ones(Tc_ar.shape) * U\n\nP = meteo_ds['PA'].values[date_mask][0] * 10\nP_ar = np.ones(Tc_ar.shape) * P\n\nSdn = meteo_ds['SW_IN'].values[date_mask][0]\nSdn_ar = np.ones(Tc_ar.shape) * Sdn\nSdn_ar[sza > 90] = 0\n\nSup = meteo_ds['SW_OUT'].values[date_mask][0]\n\nLdn = meteo_ds['LW_IN'].values[date_mask][0]\nLdn_ar = np.ones(Tc_ar.shape) * Ldn\n\nLup = meteo_ds['LW_OUT'].values[date_mask][0]\n\n# save energy fluxes to outdict\nLE_obs = meteo_ds['LE'].values[date_mask][0]\n\nH_obs = meteo_ds['H'].values[date_mask][0]\n\nRn_obs = meteo_ds['NETRAD'].values[date_mask][0]\n\n# get IRT T_canopy\nT_canopy = meteo_ds['T_CANOPY'].values[date_mask][0] + 273.15\n\n# get soil heat flux data from soil dataset\nsoil_date_mask = soil_ds['TIMESTAMP'] == '4/16/24 11:00'\nG_obs = soil_ds['G'].values[soil_date_mask][0]\n\n\n# create an output dictionary to store results to then compare with model results\noutdict = {'date':[], 'hour':[], 'SWin_obs':[], 'SWout_obs':[],'LWin_obs':[], 'LWout_obs':[], 'Rn_obs':[], 'LE_obs':[], 'H_obs':[], 'G_obs':[], 'IRT_Canopy':[]}\noutdict['date'].append(date_ts) # date \noutdict['hour'].append(hour) # hour \noutdict['SWin_obs'].append(Sdn) # shortwave incoming radiation \noutdict['SWout_obs'].append(Sup) # shortwave outgoing radiation \noutdict['LWin_obs'].append(Ldn) # longwave incoming radiation \noutdict['LWout_obs'].append(Lup) # longwave outgoing radiation \noutdict['Rn_obs'].append(Rn_obs) # Net radiation\noutdict['LE_obs'].append(LE_obs) # latent heat flux\noutdict['H_obs'].append(H_obs) # sensible heat flux\noutdict['G_obs'].append(G_obs) # soil heat flux\noutdict['IRT_Canopy'].append(T_canopy) # IRT canopy temperature\n\nprint('Done!')\n\n","type":"content","url":"/uav-3seb#extract-meteo-data-over-overpass-time","position":35},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl3":"Calculating vegetation biophysical variables","lvl2":"Other inputs and parameters"},"type":"lvl3","url":"/uav-3seb#calculating-vegetation-biophysical-variables","position":36},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl3":"Calculating vegetation biophysical variables","lvl2":"Other inputs and parameters"},"content":"Warning\n\nFor now, we are assuming constant LAI for both Almonds and cover crops. This should ideally be estimated using multispectral and/or 3D point cloud data fitting an empirical model or inversting a radiative transfer model (RTM). You can see ./302-Biophysical_Traits_RTM.ipynb for an example on how to estimate biophysical traits using satellite imagery and RTMs, which could also be applied for UAV imagery.\n\n# for now constant values for LAI\n## tree crop\nF = 2.5\nlai_ar = Fc_ar * F\n\n## cover crop\nlai_cc_ar = np.ones_like(Tc_ar) * 0.6\n\n# get 'ecosystem' level biophysical variables (combine tree and cover crops) for TSEB\nlai_eco = lai_ar + lai_cc_ar \nFc_eco = Fc_ar + Fcc_ar\nFc_eco[Fc_eco>1] = 1\nF_eco = lai_eco/Fc_eco\n\n# cover crop height\nHc_cc_ar = np.ones_like(Tc_ar) * 0.4\n\n# green fraction\n## tree crop\nFg_ar = np.ones_like(Tc_ar) * 0.9 # less than 1 to take into account woody/non-green material\n## cover crop\nFg_cc_ar = np.ones_like(Tc_ar) * 1.\n\n# local LAI of cover crop\nF_sub = lai_cc_ar/Fcc_ar\n\n# row architecture and width\nrow_direction = 90\n\n## width of interrow\ninterrow = 8\n\n# canopy width to height ratio\nwc_ratio = 1\n## cover crop\nwc_sub_ratio = 1\n\n# leaf width\n## tree crop\nlw = 0.05\n## cover crop\nlw_cc = 0.01\nx_lad = 1\n\n# to take into account row strucure on vegetation clumping\npsi = row_direction - saa\n\n# calculate clumping index\n\n## tree crop\nOmega0 = TSEB.CI.calc_omega0_Kustas(lai_ar, Fc_ar, x_LAD=x_lad, isLAIeff=True)\nOmega = TSEB.CI.calc_omega_rows(lai_ar, Fc_ar, theta=sza,\n                                psi=psi, w_c=wc_ratio,\n                                x_lad=x_lad)\n# effective LAI (tree crop)\nlai_eff =  F * Omega\n\n## understory vegetation\nOmega0_un = TSEB.CI.calc_omega0_Kustas(lai_cc_ar, Fcc_ar, x_LAD=x_lad, isLAIeff=True)\nOmega_un = TSEB.CI.calc_omega_Kustas(Omega0_un, sza, w_C=wc_sub_ratio)\n\n# effective LAI (cover crop)\nlai_cc_eff =  F_sub * Omega_un\n\n# ecosystem lai \nOmega0_eco = TSEB.CI.calc_omega0_Kustas(lai_eco, Fc_eco, x_LAD=x_lad, isLAIeff=True)\nOmega_eco = TSEB.CI.calc_omega_Kustas(Omega0_eco, sza, w_C=wc_sub_ratio)\nlai_eco_eff = F_eco * Omega_eco\nprint('Done!')\n\n","type":"content","url":"/uav-3seb#calculating-vegetation-biophysical-variables","position":37},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl3":"Ancillary information and parameters","lvl2":"Other inputs and parameters"},"type":"lvl3","url":"/uav-3seb#ancillary-information-and-parameters","position":38},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl3":"Ancillary information and parameters","lvl2":"Other inputs and parameters"},"content":"\n\n#==============================================================================\n# Canopy and Soil spectra\n#==============================================================================\n\nspectraVeg = {'rho_leaf_vis': 0.05, 'tau_leaf_vis': 0.08, 'rho_leaf_nir': 0.26, 'tau_leaf_nir': 0.33}  # from pyTSEB\nspectraGrd = {'rsoilv': 0.07, 'rsoiln': 0.28}\n\n\n#Thermal spectra\ne_v_constant=0.99        #Leaf emissivity\ne_s_constant=0.95        #Soil emissivity\n\n# viewing angle of sensor\nvza = 0\n\n# for now keep constant for both layers\nz0_soil=0.01\n\n# TSEB parameters\nKN_c = 0.0038  # Kondo & Ishida (1997) coefficient for rough surfaces\nKN_b = 0.0120  # Kustas and Norman (1999) after Sauer and Norman (1995)\n\nalpha_pt = 1.26 # alpha parameter in Priestley-Taylor Initialization\n\n# using constant ratio appraoch to estimate G\nG_constant = 0.35\ncalcG = [[1], G_constant]\n\n# use Norman and Kustas 1995 resistance framework\nResistance_flag=[0,{}]\n\nprint('Done!')\n\n","type":"content","url":"/uav-3seb#ancillary-information-and-parameters","position":39},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl2":"Radiation partionning"},"type":"lvl2","url":"/uav-3seb#radiation-partionning","position":40},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl2":"Radiation partionning"},"content":"Net Radiation intercepted at the canopy and transmitted to the soil is estimated using the \n\nCampbell & Norman (1998) model (see Chapter 15).\n\nIn the case of 3SEB, an adapted 3-source version is implemented taking into account the two vegetation layers in addition to a soil layer. See Burchard-Levine et al. 2022 for more details","type":"content","url":"/uav-3seb#radiation-partionning","position":41},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl4":"2-Source Net Radiation Modeling","lvl2":"Radiation partionning"},"type":"lvl4","url":"/uav-3seb#id-2-source-net-radiation-modeling","position":42},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl4":"2-Source Net Radiation Modeling","lvl2":"Radiation partionning"},"content":"The \n\nCampbell & Norman (1998) model is used to simulate shortwave radiation partitioning between vegetation and soil\n\n# Emissivity\ne_s = np.ones(lst_ar.shape) * e_s_constant\ne_v = np.ones(lst_ar.shape) * e_v_constant\n\ndifvis, difnir, fvis, fnir = TSEB.rad.calc_difuse_ratio(Sdn_ar, sza, press=P_ar)\nskyl = fvis * difvis + fnir * difnir\nSdn_dir = (1. - skyl) * Sdn_ar\nSdn_dif = skyl * Sdn_ar\n\n# incoming long wave radiation\nemisAtm = rad.calc_emiss_atm(Ea_ar, Ta_ar)\nLsky = emisAtm * met.calc_stephan_boltzmann(Ta_ar)\n\nsn_veg, sn_soil = TSEB.rad.calc_Sn_Campbell(lai_eco, sza, Sdn_dir, Sdn_dif, fvis, fnir,\n                                                    np.full_like(lai_ar, spectraVeg['rho_leaf_vis']),\n                                                    np.full_like(lai_ar, spectraVeg['tau_leaf_vis']),\n                                                    np.full_like(lai_ar, spectraVeg['rho_leaf_nir']),\n                                                    np.full_like(lai_ar, spectraVeg['tau_leaf_nir']),\n                                                    np.full_like(lai_ar, spectraGrd['rsoilv']),\n                                                    np.full_like(lai_ar, spectraGrd['rsoiln']),\n                                                    x_LAD=x_lad, LAI_eff=lai_eco_eff) \n\nsn_veg[~np.isfinite(sn_veg)] = 0\nsn_soil[~np.isfinite(sn_soil)] = 0\n\nprint('Done!')\n\n","type":"content","url":"/uav-3seb#id-2-source-net-radiation-modeling","position":43},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl4":"3-Source Net Radiation Modeling","lvl2":"Radiation partionning"},"type":"lvl4","url":"/uav-3seb#id-3-source-net-radiation-modeling","position":44},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl4":"3-Source Net Radiation Modeling","lvl2":"Radiation partionning"},"content":"Estimate shortwave radiation transmission using an adapted Campbell 1998 model (adapted for 3 layers). See the Supplementary Information of \n\nBurchard-Levine et al. (2022) for more details.\n\nsn_ov = net shortwave radiation for overstory (tree crop)\n\nsn_un = net shortwave radiation for understory (cover crop)\n\nsn_soil =  net shortwave radiation for soil\n\n# estimate radiation transmission using Campbell 1998 model (adapted for 3 layers)\nsn_ov, sn_s, sn_un = py3seb.calc_Sn_Campbell(lai_ar,\n                                       lai_cc_ar,\n                                       sza,\n                                       Sdn_dir,\n                                       Sdn_dif,\n                                       fvis,\n                                       fnir,\n                                       np.full_like(lai_ar, spectraVeg['rho_leaf_vis']),\n                                       np.full_like(lai_ar, spectraVeg['rho_leaf_vis']),\n                                       np.full_like(lai_ar, spectraVeg['tau_leaf_vis']),\n                                       np.full_like(lai_ar, spectraVeg['tau_leaf_vis']),\n                                       np.full_like(lai_ar, spectraVeg['rho_leaf_nir']),\n                                       np.full_like(lai_ar, spectraVeg['rho_leaf_nir']),\n                                       np.full_like(lai_ar, spectraVeg['tau_leaf_nir']),\n                                       np.full_like(lai_ar, spectraVeg['tau_leaf_nir']),\n                                       np.full_like(lai_ar, spectraGrd['rsoilv']),\n                                       np.full_like(lai_ar, spectraGrd['rsoiln']),\n                                       Hc_ar,\n                                       0.25 * Hc_ar,\n                                       wc_sub_ratio,\n                                       Fc_ar,\n                                       LAI_eff=lai_eff,\n                                       LAI_eff_sub=lai_cc_eff)\n\nsn_ov[~np.isfinite(sn_ov)] = 0\nsn_s[~np.isfinite(sn_s)] = 0\nsn_un[~np.isfinite(sn_un)] = 0\n\nprint('Done!')\n\n","type":"content","url":"/uav-3seb#id-3-source-net-radiation-modeling","position":45},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl2":"Landscape roughness estimation"},"type":"lvl2","url":"/uav-3seb#landscape-roughness-estimation","position":46},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl2":"Landscape roughness estimation"},"content":"\n\n# main vegetation layer (i.e. Almond orchard)\n#[z_0M, d_0] = TSEB.res.calc_roughness(lai_ar, Hc_ar, np.ones(lai_ar.shape) * wc_ratio,\n #                                     np.ones(lai_ar.shape) * TSEB.res.BROADLEAVED_D)\n# calculate tree crop roughness parameters taking into account LAIeff using Raupach 1994 model\nz_0M_factor, d_0_factor = py3seb.raupach_94(lai_eff)\nd_0 = Hc_ar*d_0_factor\nz_0M = Hc_ar*z_0M_factor\n\nd_0[d_0 < 0] = 0\nz_0M[z_0M < z0_soil] = z0_soil\n\n# understory/secondary vegetation (i.e. Cover crop)\nz_0m_un, d_0_un = TSEB.res.calc_roughness(lai_cc_eff,\n                                          Hc_cc_ar,\n                                           np.full_like(lai_cc_ar, wc_sub_ratio),\n                                          np.full_like(lai_cc_ar, TSEB.res.GRASS))\nd_0_un[d_0_un < 0] = 0\nz_0m_un[z_0m_un < z0_soil] = z0_soil\n\nprint('Done!')\n\n","type":"content","url":"/uav-3seb#landscape-roughness-estimation","position":47},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl2":"Running TSEB-PT, 3SEB-PT, 3SEB-2T, 3SEB-3T"},"type":"lvl2","url":"/uav-3seb#running-tseb-pt-3seb-pt-3seb-2t-3seb-3t","position":48},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl2":"Running TSEB-PT, 3SEB-PT, 3SEB-2T, 3SEB-3T"},"content":"We will run the different TSEB/3SEB variants in this section.\n\nFor each model run, we will save the modelled outputs in a dictionary to then be able to compare models and agaisnt tower measurements\n\nmodel_outdict = {}\n\n","type":"content","url":"/uav-3seb#running-tseb-pt-3seb-pt-3seb-2t-3seb-3t","position":49},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl3":"TSEB-PT","lvl2":"Running TSEB-PT, 3SEB-PT, 3SEB-2T, 3SEB-3T"},"type":"lvl3","url":"/uav-3seb#tseb-pt","position":50},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl3":"TSEB-PT","lvl2":"Running TSEB-PT, 3SEB-PT, 3SEB-2T, 3SEB-3T"},"content":"Here we will the original TSEB with the priestley-taylor initialization for comparison purposes.\n\n[flag_PT_all, T_soil, T_veg, T_AC, Ln_soil, Ln_veg, LE_veg, H_veg,\n     LE_soil, H_soil, G_mod, R_S, R_X, R_A, u_friction, L, n_iterations] = TSEB.TSEB_PT(lst_ar,\n                                                                                        vza,\n                                                                                        Ta_ar,\n                                                                                        U_ar,\n                                                                                        Ea_ar,\n                                                                                        P_ar,\n                                                                                        sn_veg,\n                                                                                        sn_soil,\n                                                                                        Ldn,\n                                                                                        lai_eco,\n                                                                                        Hc_ar,\n                                                                                        e_v,\n                                                                                        e_s,\n                                                                                        z_0M,\n                                                                                        d_0,\n                                                                                        z_t,\n                                                                                        z_t,\n                                                                                        leaf_width=lw,\n                                                                                        alpha_PT=alpha_pt,\n                                                                                        f_c=Fc_eco,\n                                                                                        f_g=Fg_ar,\n                                                                                        calcG_params=calcG,\n                                                                                        resistance_form=Resistance_flag)\n\n# save ouputs in outdict \nLE = LE_veg + LE_soil\nH = H_veg + H_soil\nRn = (Ln_veg + sn_veg) + (Ln_soil + sn_soil)\n\n# save outputs to dictionary\nmodel_outdict['LE_TSEB-PT'] = LE\nmodel_outdict['LEc_TSEB-PT'] = LE_veg\nmodel_outdict['H_TSEB-PT'] = H\nmodel_outdict['Rn_TSEB-PT'] = Rn\nmodel_outdict['G_TSEB-PT'] = G_mod\nmodel_outdict['Tc_TSEB-PT'] = T_veg\nmodel_outdict['Ts_TSEB-PT'] = T_soil\nmodel_outdict['Flags_TSEB-PT'] = flag_PT_all\n\n# visualizing outputs \nfig, axes = plt.subplots(2,2, figsize=(10,8))\nax = axes[0,0]\nim = ax.imshow(LE, vmin=0, vmax=600, cmap='PuBu', extent = te)\nax.set_title('LE')\n# Add colorbar for only axes[0, 0]\ncbar = fig.colorbar(im, ax=ax)\ncbar.set_label('LE (W/$m^2$)')  # Add title to colorbar\nle_mean = int(np.round(np.nanmean(LE),0))\nax.text(0.01,0.1, f'mean:\\n{le_mean} W/$m^2$', transform=ax.transAxes)\nax.set_axis_off()\n\nax = axes[0,1]\nim = ax.imshow(H, vmin=0, vmax=600, cmap='OrRd',  extent = te)\nax.set_title('H')\n# Add colorbar for only axes[0, 0]\ncbar = fig.colorbar(im, ax=ax)\ncbar.set_label('H (W/$m^2$)')  # Add title to colorbar\nh_mean = int(np.round(np.nanmean(H),0))\nax.text(0.01,0.1, f'mean:\\n{h_mean} W/$m^2$', transform=ax.transAxes)\nax.set_axis_off()\n\nax = axes[1,0]\nim = ax.imshow(Rn, vmin=0, vmax=800, cmap='plasma',  extent = te)\nax.set_title('Rn')\n# Add colorbar for only axes[0, 0]\ncbar = fig.colorbar(im, ax=ax)\ncbar.set_label('Rn (W/$m^2$)')  # Add title to colorbar\nrn_mean = int(np.round(np.nanmean(Rn),0))\nax.text(0.01,0.1, f'mean:\\n{rn_mean} W/$m^2$', transform=ax.transAxes)\nax.set_axis_off()\n\nax = axes[1,1]\nim = ax.imshow(G_mod, vmin=0, vmax=200, cmap='copper',  extent = te)\nax.set_title('G')\n# Add colorbar for only axes[0, 0]\ncbar = fig.colorbar(im, ax=ax)\ncbar.set_label('G (W/$m^2$)')  # Add title to colorbar\ng_mean = int(np.round(np.nanmean(G_mod),0))\nax.text(0.01,0.1, f'mean:\\n{g_mean} W/$m^2$', transform=ax.transAxes)\nax.set_axis_off()\n\nplt.suptitle(\"TSEB-PT\",\n             fontsize=26)\nplt.show()\n\n\n","type":"content","url":"/uav-3seb#tseb-pt","position":51},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl2":"3SEB-PT"},"type":"lvl2","url":"/uav-3seb#id-3seb-pt","position":52},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl2":"3SEB-PT"},"content":"Here we will run 3SEB-PT, which initializes both vegetation canopies with Priestley-Taylor assumption\n\n[flag_PT_all, T_S, T_C, T_C_sub, T_AC, L_n_sub, L_nC, Ln_C_sub, Ln_S, LE_C, H_C, LE_C_sub, H_C_sub,\n LE_S, H_S, G_mod, R_S, R_sub, R_X, R_A, u_friction, L, n_iterations] = py3seb.ThreeSEB_PT(lst_ar,\n                                                                                         vza,\n                                                                                         Ta_ar,\n                                                                                         U_ar,\n                                                                                         Ea_ar,\n                                                                                         P_ar,\n                                                                                         sn_ov,\n                                                                                         sn_s,\n                                                                                         sn_un,\n                                                                                         Ldn_ar,\n                                                                                         lai_ar,\n                                                                                         lai_cc_ar,\n                                                                                         Hc_ar,\n                                                                                         Hc_cc_ar,\n                                                                                         e_v,\n                                                                                         e_v,#change e_v cover crop\n                                                                                         e_s,\n                                                                                         z_0M,\n                                                                                         z_0m_un,\n                                                                                         d_0,\n                                                                                         d_0_un,\n                                                                                         z_u,\n                                                                                         z_t,\n                                                                                         leaf_width=lw,\n                                                                                         leaf_width_sub=lw_cc,\n                                                                                         f_c=Fc_ar,\n                                                                                         f_c_sub=Fcc_ar,\n                                                                                         f_g=Fg_ar,\n                                                                                         f_g_sub=Fg_cc_ar,\n                                                                                         calcG_params=calcG,\n                                                                                         resistance_form=Resistance_flag)\n# save ouputs in outdict \nLE = LE_C + LE_C_sub + LE_S\nH = H_C + H_S + H_C_sub\n\nRn_C = L_nC + sn_ov\nRn_C_sub = Ln_C_sub + sn_un\nRn_S = Ln_S + sn_s\nRn = Rn_C + Rn_C_sub + Rn_S\n\n# save outputs to dictionary\nmodel_outdict['LE_3SEB-PT'] = LE\nmodel_outdict['LEc_3SEB-PT'] = LE_C\nmodel_outdict['LEcc_3SEB-PT'] = LE_C_sub\nmodel_outdict['H_3SEB-PT'] = H\nmodel_outdict['Rn_3SEB-PT'] = Rn\nmodel_outdict['G_3SEB-PT'] = G_mod\nmodel_outdict['Tc_3SEB-PT'] = T_C\nmodel_outdict['Tcc_3SEB-PT'] = T_C_sub\nmodel_outdict['Ts_3SEB-PT'] = T_S\nmodel_outdict['Flags_3SEB-PT'] = flag_PT_all\n\n# visualizing outputs \n\nfig, axes = plt.subplots(2,2, figsize=(10,8))\nax = axes[0,0]\nim = ax.imshow(LE, vmin=0, vmax=600, cmap='PuBu', extent = te)\nax.set_title('LE')\n# Add colorbar for only axes[0, 0]\ncbar = fig.colorbar(im, ax=ax)\ncbar.set_label('LE (W/$m^2$)')  # Add title to colorbar\nle_mean = int(np.round(np.nanmean(LE),0))\nax.text(0.01,0.1, f'mean:\\n{le_mean} W/$m^2$', transform=ax.transAxes)\nax.set_axis_off()\n\nax = axes[0,1]\nim = ax.imshow(H, vmin=0, vmax=600, cmap='OrRd',  extent = te)\nax.set_title('H')\n# Add colorbar for only axes[0, 0]\ncbar = fig.colorbar(im, ax=ax)\ncbar.set_label('H (W/$m^2$)')  # Add title to colorbar\nh_mean = int(np.round(np.nanmean(H),0))\nax.text(0.01,0.1, f'mean:\\n{h_mean} W/$m^2$', transform=ax.transAxes)\nax.set_axis_off()\n\nax = axes[1,0]\nim = ax.imshow(Rn, vmin=0, vmax=800, cmap='plasma',  extent = te)\nax.set_title('Rn')\n# Add colorbar for only axes[0, 0]\ncbar = fig.colorbar(im, ax=ax)\ncbar.set_label('Rn (W/$m^2$)')  # Add title to colorbar\nrn_mean = int(np.round(np.nanmean(Rn),0))\nax.text(0.01,0.1, f'mean:\\n{rn_mean} W/$m^2$', transform=ax.transAxes)\nax.set_axis_off()\n\nax = axes[1,1]\nim = ax.imshow(G_mod, vmin=0, vmax=200, cmap='copper',  extent = te)\nax.set_title('G')\n# Add colorbar for only axes[0, 0]\ncbar = fig.colorbar(im, ax=ax)\ncbar.set_label('G (W/$m^2$)')  # Add title to colorbar\ng_mean = int(np.round(np.nanmean(G_mod),0))\nax.text(0.01,0.1, f'mean:\\n{g_mean} W/$m^2$', transform=ax.transAxes)\nax.set_axis_off()\n\nplt.suptitle(\"3SEB-PT\",\n             fontsize=26)\nplt.show()\n\n","type":"content","url":"/uav-3seb#id-3seb-pt","position":53},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl2":"3SEB-2T"},"type":"lvl2","url":"/uav-3seb#id-3seb-2t","position":54},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl2":"3SEB-2T"},"content":"\n\n#T_sub = ((Fcc_ar*(Tcc_ar)**4)+((1-Fcc_ar)*(Ts_ar)**4))**0.25\n\n[flag_PT_all, T_S, T_C_sub, T_AC, Ln_sub, Ln_C, Ln_C_sub, Ln_S, LE_C, H_C, LE_C_sub, H_C_sub,\nLE_S, H_S, G_mod, R_sub, R_X_un, R_X_ov, R_A, u_friction, L, n_iterations] = py3seb.ThreeSEB_2T(Tc_ar,\n                                                                             Tsub_ar,\n                                                                             vza,\n                                                                             Ta_ar,\n                                                                             U_ar,\n                                                                             Ea_ar,\n                                                                             P_ar,\n                                                                             sn_ov,\n                                                                             sn_s,\n                                                                             sn_un,\n                                                                             Ldn_ar,\n                                                                             lai_ar,\n                                                                             lai_cc_ar,\n                                                                             Hc_ar,\n                                                                             Hc_cc_ar,\n                                                                             e_v,\n                                                                             e_v,#change e_v cover crop\n                                                                             e_s,\n                                                                             z_0M,\n                                                                             z_0m_un,\n                                                                             d_0,\n                                                                             d_0_un,\n                                                                             z_u,\n                                                                             z_t,\n                                                                             leaf_width=lw,\n                                                                             leaf_width_sub=lw_cc,\n                                                                             f_c=Fc_ar,\n                                                                             f_c_sub=Fcc_ar,\n                                                                             f_g=Fg_ar,\n                                                                             f_g_sub=Fg_cc_ar,\n                                                                             calcG_params=calcG,\n                                                                             resistance_form=Resistance_flag)\n\n# save ouputs in outdict \nLE = LE_C + LE_C_sub + LE_S\nH = H_C + H_S + H_C_sub\n\nRn_C = Ln_C + sn_ov\nRn_C_sub = Ln_C_sub + sn_un\nRn_S = Ln_S + sn_s\nRn = Rn_C + Rn_C_sub + Rn_S\nRn[Rn>1000] = np.nan\n\n# visualizing outputs \n# save outputs to dictionary\nmodel_outdict['LE_3SEB-2T'] = LE\nmodel_outdict['LEc_3SEB-2T'] = LE_C\nmodel_outdict['LEcc_3SEB-2T'] = LE_C_sub\nmodel_outdict['H_3SEB-2T'] = H\nmodel_outdict['Rn_3SEB-2T'] = Rn\nmodel_outdict['G_3SEB-2T'] = G_mod\nmodel_outdict['Tc_3SEB-2T'] = Tc_ar\nmodel_outdict['Tcc_3SEB-2T'] = T_C_sub\nmodel_outdict['Ts_3SEB-2T'] = T_S\nmodel_outdict['Flags_3SEB-2T'] = flag_PT_all\n\n# visualize outputs\nfig, axes = plt.subplots(2,2, figsize=(10,8))\nax = axes[0,0]\nim = ax.imshow(LE, vmin=0, vmax=600, cmap='PuBu', extent = te)\nax.set_title('LE')\n# Add colorbar for only axes[0, 0]\ncbar = fig.colorbar(im, ax=ax)\ncbar.set_label('LE (W/$m^2$)')  # Add title to colorbar\nle_mean = int(np.round(np.nanmean(LE),0))\nax.text(0.01,0.1, f'mean:\\n{le_mean} W/$m^2$', transform=ax.transAxes)\nax.set_axis_off()\n\nax = axes[0,1]\nim = ax.imshow(H, vmin=0, vmax=600, cmap='OrRd',  extent = te)\nax.set_title('H')\n# Add colorbar for only axes[0, 0]\ncbar = fig.colorbar(im, ax=ax)\ncbar.set_label('H (W/$m^2$)')  # Add title to colorbar\nh_mean = int(np.round(np.nanmean(H),0))\nax.text(0.01,0.1, f'mean:\\n{h_mean} W/$m^2$', transform=ax.transAxes)\nax.set_axis_off()\n\nax = axes[1,0]\nim = ax.imshow(Rn, vmin=0, vmax=800, cmap='plasma',  extent = te)\nax.set_title('Rn')\n# Add colorbar for only axes[0, 0]\ncbar = fig.colorbar(im, ax=ax)\ncbar.set_label('Rn (W/$m^2$)')  # Add title to colorbar\nrn_mean = int(np.round(np.nanmean(Rn),0))\nax.text(0.01,0.1, f'mean:\\n{rn_mean} W/$m^2$', transform=ax.transAxes)\nax.set_axis_off()\n\nax = axes[1,1]\nim = ax.imshow(G_mod, vmin=0, vmax=200, cmap='copper',  extent = te)\nax.set_title('G')\n# Add colorbar for only axes[0, 0]\ncbar = fig.colorbar(im, ax=ax)\ncbar.set_label('G (W/$m^2$)')  # Add title to colorbar\ng_mean = int(np.round(np.nanmean(G_mod),0))\nax.text(0.01,0.1, f'mean:\\n{g_mean} W/$m^2$', transform=ax.transAxes)\nax.set_axis_off()\n\nplt.suptitle(\"3SEB-2T\",\n             fontsize=26)\n\nplt.show()\n\n","type":"content","url":"/uav-3seb#id-3seb-2t","position":55},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl2":"Running 3SEB-3T"},"type":"lvl2","url":"/uav-3seb#running-3seb-3t","position":56},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl2":"Running 3SEB-3T"},"content":"\n\n[flag_PT_all, T_AC, L_nC, Ln_C_sub, Ln_S, LE_C, H_C, LE_C_sub, H_C_sub,\nLE_S, H_S, G_mod, R_S, R_x_un,R_x_ov, R_A, u_friction, L, n_iterations] = py3seb.ThreeSEB_3T(Tc_ar,\n                                                                                     Tcc_ar,\n                                                                                     Ts_ar,\n                                                                                     Ta_ar,\n                                                                                     U_ar,\n                                                                                     Ea_ar,\n                                                                                     P_ar,\n                                                                                     sn_ov,\n                                                                                     sn_s,\n                                                                                     sn_un,\n                                                                                     Ldn_ar,\n                                                                                     lai_ar,\n                                                                                     lai_cc_ar,\n                                                                                     Hc_ar,\n                                                                                     Hc_cc_ar,\n                                                                                     e_v,\n                                                                                     e_v,#change e_v cover crop\n                                                                                     e_s,\n                                                                                     z_0M,\n                                                                                     z_0m_un,\n                                                                                     d_0,\n                                                                                     d_0_un,\n                                                                                     z_u,\n                                                                                     z_t,\n                                                                                     leaf_width=lw,\n                                                                                     leaf_width_sub=lw_cc,\n                                                                                     f_c=Fc_ar,\n                                                                                     f_c_sub=Fcc_ar,\n                                                                                     f_g=Fg_ar,\n                                                                                     f_g_sub=Fg_cc_ar,\n                                                                                     calcG_params=calcG,\n                                                                                     resistance_form=Resistance_flag)\n\n# save ouputs in outdict \nLE = LE_C + LE_C_sub + LE_S\nH = H_C + H_S + H_C_sub\n\nRn_C = L_nC + sn_ov\nRn_C_sub = Ln_C_sub + sn_un\nRn_S = Ln_S + sn_s\nRn = Rn_C + Rn_C_sub + Rn_S\nRn[Rn>1000] = np.nan\nG_mod[G_mod>200] = np.nan\n# visualizing outputs \n# save outputs to dictionary\nmodel_outdict['LE_3SEB-3T'] = LE\nmodel_outdict['LEc_3SEB-3T'] = LE_C\nmodel_outdict['LEcc_3SEB-3T'] = LE_C_sub\nmodel_outdict['H_3SEB-3T'] = H\nmodel_outdict['Rn_3SEB-3T'] = Rn\nmodel_outdict['G_3SEB-3T'] = G_mod\nmodel_outdict['Tc_3SEB-3T'] = Tc_ar\nmodel_outdict['Tcc_3SEB-3T'] = Tcc_ar\nmodel_outdict['Ts_3SEB-3T'] = Ts_ar\nmodel_outdict['Flags_3SEB-3T'] = flag_PT_all\n\n# visualizing outputs \n\nfig, axes = plt.subplots(2,2, figsize=(10,8))\nax = axes[0,0]\nim = ax.imshow(LE, vmin=0, vmax=600, cmap='PuBu', extent = te)\nax.set_title('LE')\n# Add colorbar for only axes[0, 0]\ncbar = fig.colorbar(im, ax=ax)\ncbar.set_label('LE (W/$m^2$)')  # Add title to colorbar\nle_mean = int(np.round(np.nanmean(LE),0))\nax.text(0.01,0.1, f'mean:\\n{le_mean} W/$m^2$', transform=ax.transAxes)\nax.set_axis_off()\n\nax = axes[0,1]\nim = ax.imshow(H, vmin=0, vmax=600, cmap='OrRd',  extent = te)\nax.set_title('H')\n# Add colorbar for only axes[0, 0]\ncbar = fig.colorbar(im, ax=ax)\ncbar.set_label('H (W/$m^2$)')  # Add title to colorbar\nh_mean = int(np.round(np.nanmean(H),0))\nax.text(0.01,0.1, f'mean:\\n{h_mean} W/$m^2$', transform=ax.transAxes)\nax.set_axis_off()\n\nax = axes[1,0]\nim = ax.imshow(Rn, vmin=0, vmax=800, cmap='plasma',  extent = te)\nax.set_title('Rn')\n# Add colorbar for only axes[0, 0]\ncbar = fig.colorbar(im, ax=ax)\ncbar.set_label('Rn (W/$m^2$)')  # Add title to colorbar\nrn_mean = int(np.round(np.nanmean(Rn),0))\nax.text(0.01,0.1, f'mean:\\n{rn_mean} W/$m^2$', transform=ax.transAxes)\nax.set_axis_off()\n\nax = axes[1,1]\nim = ax.imshow(G_mod, vmin=0, vmax=200, cmap='copper',  extent = te)\nax.set_title('G')\n# Add colorbar for only axes[0, 0]\ncbar = fig.colorbar(im, ax=ax)\ncbar.set_label('G (W/$m^2$)')  # Add title to colorbar\ng_mean = int(np.round(np.nanmean(G_mod),0))\nax.text(0.01,0.1, f'mean:\\n{g_mean} W/$m^2$', transform=ax.transAxes)\nax.set_axis_off()\n\nplt.suptitle(\"3SEB-3T\",\n             fontsize=26)\n\nplt.show()\n\n","type":"content","url":"/uav-3seb#running-3seb-3t","position":57},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl2":"Model comparisons and evaluation"},"type":"lvl2","url":"/uav-3seb#model-comparisons-and-evaluation","position":58},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl2":"Model comparisons and evaluation"},"content":"In this section we will compare the different model outputs. First, we will evaluated the model outputs against the EC tower measurements.\n\nTo make them as comparable as possible, we will estimate the 2D flux tower footprint to better characterize the pixels associated to the tower measurements.\n\nThe 2D EC tower flux footprint was estimated using the Flux Footprint Prediction (FFP) model as described in \n\nKljun et al. (2015) and the code is available \n\nhere\n\nThis footprint estimates the weighted 2D area contributing to the EC sampling. As such, we can best compare the model results to the tower measurements by acquiring all pixels located within the estimated footprint and obtaining a weighted average for those pixels. The footprint was therefore rasterized and aligned to the arrays of the model output geometry to ease the comparison.\n\nSee below for a visualization.","type":"content","url":"/uav-3seb#model-comparisons-and-evaluation","position":59},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl3":"Visualization of footprint area","lvl2":"Model comparisons and evaluation"},"type":"lvl3","url":"/uav-3seb#visualization-of-footprint-area","position":60},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl3":"Visualization of footprint area","lvl2":"Model comparisons and evaluation"},"content":"\n\nfp_dir = datadir / 'Footprints'\nfp_file = fp_dir / f'surface_CC_202404161100_FPnorm_10cm.tif'\nfp_fid = gdal.Open(str(fp_file))\nfp_ar = fp_fid.GetRasterBand(1).ReadAsArray()\nfp_ar[fp_ar < 0.0001] = np.nan\n\nulx, xres, xskew, uly, yskew, yres = fp_fid.GetGeoTransform()\nlrx = ulx + (fp_fid.RasterXSize * xres)\nlry = uly + (fp_fid.RasterYSize * yres)\n\nte_10cm = [ulx, lrx, lry, uly]\n\n# get 8m aligned footprint\nfp_8m_file = fp_dir / f'surface_CC_202404161100_FPnorm_8m_aligned.tif'\nfp_8m_fid = gdal.Open(str(fp_8m_file))\nfp_8m_ar = fp_8m_fid.GetRasterBand(1).ReadAsArray()\nfp_8m_ar[fp_8m_ar < 0.0001] = np.nan\n\nfp_shp = fp_dir/'shp'/'surface_CC_202404161100_FPnorm.shp'\nfp_gpd = gpd.read_file(fp_shp)\n\nfig, axes = plt.subplots(2,2, figsize=(10,8))\nax1 = axes[0,0]\nax1.imshow(rgb_image, extent=te)\nax1.imshow(fp_ar, cmap='viridis', extent=te_10cm, alpha=0.7)\nfp_gpd.plot(ax=ax1, facecolor='none', edgecolor='indianred', linewidth=1, alpha=0.75, label='footprint')\nax1.set_ylim(4156650, 4157050)\nax1.set_xlim(655150,655430)\nax1.set_axis_off()\n\nax2 = axes[0,1]\n\nax2.imshow(rgb_image, extent=te)\nim1 = ax2.imshow(fp_ar, cmap='viridis', extent=te_10cm, alpha=0.7)\nax2.set_ylim(4156650,4156760)\nax2.set_xlim(655300,655430)\nfp_gpd.plot(ax=ax2, facecolor='none', edgecolor='indianred', linewidth=1, alpha=0.75, label='footprint')\nplt.colorbar(im1, ax=ax2, label='weighted flux contribution (-)',  shrink=0.65)\nax2.set_axis_off()\n\nax3 = axes[1,0]\nax3.imshow(model_outdict['LE_3SEB-PT'],vmin=0, vmax=600, cmap='PuBu', extent=te)\nax3.imshow(fp_8m_ar, cmap='viridis', extent=te, alpha=0.7)\nax3.set_ylim(4156650, 4157050)\nax3.set_xlim(655150,655430)\nfp_gpd.plot(ax=ax3, facecolor='none', edgecolor='indianred', linewidth=1, alpha=0.75, label='footprint')\nax3.set_axis_off()\n\nax4 = axes[1,1]\nax4.imshow(model_outdict['LE_3SEB-PT'],vmin=0, vmax=600, cmap='PuBu', extent=te)\nim2 = ax4.imshow(fp_8m_ar, cmap='viridis', extent=te, alpha=0.7)\nax4.set_ylim(4156650,4156760)\nax4.set_xlim(655300,655430)\nfp_gpd.plot(ax=ax4, facecolor='none', edgecolor='indianred', linewidth=1, alpha=0.75, label='footprint')\nax4.set_axis_off()\nplt.colorbar(im2, ax=ax4, label='weighted flux contribution (-)', shrink=0.65)\n\nplt.suptitle(\"Footprint Area\",\n             fontsize=26)\nplt.show()\n\n","type":"content","url":"/uav-3seb#visualization-of-footprint-area","position":61},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl2":"Compare model results to measurements"},"type":"lvl2","url":"/uav-3seb#compare-model-results-to-measurements","position":62},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl2":"Compare model results to measurements"},"content":"","type":"content","url":"/uav-3seb#compare-model-results-to-measurements","position":63},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl3":"Get weighted model results over footprint","lvl2":"Compare model results to measurements"},"type":"lvl3","url":"/uav-3seb#get-weighted-model-results-over-footprint","position":64},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl3":"Get weighted model results over footprint","lvl2":"Compare model results to measurements"},"content":"\n\n# observed data are saved in outdict\n\nmodel_types = ['TSEB-PT', '3SEB-PT', '3SEB-2T','3SEB-3T']\nfluxes = ['LE', 'H', 'Rn', 'G']\n\nfor model in model_types:\n    for var in fluxes:\n        var_ar = model_outdict[f'{var}_{model}']\n        flags =  model_outdict[f'Flags_{model}']\n        var_ar[var_ar<-100] = np.nan\n        var_ar[var_ar>1000] = np.nan\n        var_ar[flags > 5] = np.nan\n        fp_8m_ar[fp_8m_ar==0] = np.nan\n        # get weighted average\n        avg_w = np.nansum(var_ar * fp_8m_ar)/np.nansum(fp_8m_ar)\n        \n        outdict[f'{var}_{model}'] = []\n        outdict[f'{var}_{model}'].append(avg_w)\n\nresults_df = pd.DataFrame(outdict)\nresults_df\n\n# plot results\n\nimport scipy.stats as st\n    \nmodel_types = ['TSEB-PT', '3SEB-PT', '3SEB-2T', '3SEB-3T']\n\nh_obs = results_df['H_obs'].values\nRn_obs = results_df['Rn_obs'].values\nG_obs = results_df['G_obs'].values\nle_obs = results_df['LE_obs'].values\nec_res = Rn_obs - h_obs - le_obs - G_obs\n\nle_res = Rn_obs - h_obs - G_obs\nbowen_ratio = h_obs/le_obs\nle_bowen = (Rn_obs - G_obs)/(1+bowen_ratio)\nle_ens = (le_obs + le_bowen + le_res)/3\nh_ens = Rn_obs - G_obs - le_ens\n\nfig, axes = plt.subplots(2,2, figsize=(14,12))\ni = 0\nfor model_type in model_types:\n    #H\n    h_mod = results_df[f'H_{model_type}'].values\n    # Rn\n    Rn_mod = results_df[f'Rn_{model_type}'].values\n    # G\n    G_mod = results_df[f'G_{model_type}'].values\n    # LE\n    le_mod = results_df[f'LE_{model_type}'].values\n\n    if i == 0:\n        ax = axes[0,0]\n    elif i == 1:\n        ax = axes[0,1]\n    elif i == 2:\n        ax = axes[1,0]\n    else:\n        ax = axes[1,1]\n\n\n    #plt.scatter(le_mod[mask], le_obs[mask], color='dodgerblue', marker='o', label='LE (unclosed)', s=50)\n    ax.scatter(le_mod, le_ens, color='dodgerblue', marker='s', label='LE', s=30)\n    ax.scatter(h_mod, h_ens, color='indianred', marker='o', label='H', s=50)\n    ax.scatter(Rn_mod, Rn_obs, color='orange', marker='d', label='Rn', s=50)\n    ax.scatter(G_mod[G_obs > 0], G_obs[G_obs > 0], color='k', marker='^', label='G', s=50)\n    ax.plot((0, 800), (0, 800), color='k', label='1:1 line', linestyle = '--')\n    \n\n    ax.legend()\n    ax.set_xlim(0, 800)\n    ax.set_ylim(0, 800)\n    ax.set_xlabel(f'{model_type} modeled (W/$m^2$)', fontsize=14)\n    if i == 0 or i == 2:\n        ax.set_ylabel('EC Observed (W/$m^2$)', fontsize=14)\n    #ax.set_title(f'{model_type}', fontsize=16)\n    i = i + 1\nplt.show()\n\n","type":"content","url":"/uav-3seb#get-weighted-model-results-over-footprint","position":65},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl2":"Comparison of modeled estimated component temperatures vs UAV contextual approach"},"type":"lvl2","url":"/uav-3seb#comparison-of-modeled-estimated-component-temperatures-vs-uav-contextual-approach","position":66},{"hierarchy":{"lvl1":"Implementation of 3SEB with high resolution imagery","lvl2":"Comparison of modeled estimated component temperatures vs UAV contextual approach"},"content":"Let us compare the component temperatures (T_c, T_{cc} and T_s) retrieved from contextual methods to those estimated from TSEB-PT, 3SEB-PT and 3SEB-2T\n\ndef model_metrics(X, Y, mask):\n    rmse = np.sqrt(np.nanmean((X[mask] - Y[mask]) ** 2))\n    cor = st.pearsonr(X[np.logical_and.reduce((mask,~np.isnan(X),~np.isnan(Y)))], Y[np.logical_and.reduce((mask,~np.isnan(Y),~np.isnan(X)))])[0]\n    bias = np.nanmean(X[mask] - Y[mask])\n    return rmse, cor, bias\n\n\n# make 2 x 2 plot with different comparison\n# get T_canopy\nfig, axes = plt.subplots(2,2, figsize=(14,12))\n\n# measured IRT\nIRT_canopy = meteo_ds['T_CANOPY'].values[date_mask][0] + 273.15\n\n# TSEB-PT estimated \nTc_tseb = model_outdict['Tc_TSEB-PT']\nTs_tseb = model_outdict['Ts_TSEB-PT']\n\n# 3SEB-PT estimated \nTc_3seb_pt = model_outdict['Tc_3SEB-PT']\nTcc_3seb_pt = model_outdict['Tcc_3SEB-PT']\nTs_3seb_pt = model_outdict['Ts_3SEB-PT']\n\n# 3SEB-2T estimated \nTcc_3seb_2t = model_outdict['Tcc_3SEB-2T']\nTs_3seb_2t = model_outdict['Ts_3SEB-2T']\n\n# error metrics for TSEB-PT\nTc_rmse, Tc_cor,_ = model_metrics(Tc_tseb,Tc_ar, np.logical_and(Tc_tseb>270, Tc_tseb<320))\nTs_rmse, Ts_cor,_ = model_metrics(Ts_tseb,Ts_ar, np.logical_and(Ts_tseb>270, Ts_tseb<320))\n\n# TSEB-PT\nax = axes[0,0]\nax.scatter(Tc_tseb, Tc_ar, color='darkgreen', marker='o', label=f'$T_C$, r = {Tc_cor:.2f}, RMSE = {Tc_rmse:.1f}', s=50)\nax.scatter(Ts_tseb, Ts_ar, color='saddlebrown', marker='o', label=f'$T_S$, r = {Ts_cor:.2f}, RMSE = {Ts_rmse:.1f}', s=50)\nax.plot((0, 800), (0, 800), color='k', label='1:1 line', linestyle = '--')\nax.set_xlim(290,320)\nax.set_ylim(290,320)\nax.set_ylabel('Contextual UAV (K)', fontsize=16)\nax.set_xlabel('Modelled TSEB-PT (K)', fontsize=16)\nax.legend(fontsize=12)\n\n# error metrics for 3SEB-PT\nTc_rmse, Tc_cor,_ = model_metrics(Tc_3seb_pt,Tc_ar, np.logical_and(Tc_3seb_pt>270, Tc_3seb_pt<320))\nTcc_rmse, Tcc_cor,_ = model_metrics(Tcc_3seb_pt,Tcc_ar, np.logical_and(Tcc_3seb_pt>270, Tcc_3seb_pt<320))\nTs_rmse, Ts_cor,_ = model_metrics(Ts_3seb_pt,Ts_ar, np.logical_and(Ts_3seb_pt>270, Ts_3seb_pt<320))\n\n# 3SEB-PT\nax = axes[0,1]\nax.scatter(Tc_3seb_pt, Tc_ar, color='darkgreen', marker='o', label=f'$T_C$, r = {Tc_cor:.2f}, RMSE = {Tc_rmse:.1f}', s=50)\nax.scatter(Tcc_3seb_pt, Tcc_ar, color='yellowgreen', marker='o', label='$T_{C,sub}$'+ f', r = {Tcc_cor:.2f}, RMSE = {Tcc_rmse:.1f}', s=50)\nax.scatter(Ts_3seb_pt, Ts_ar, color='saddlebrown', marker='o', label=f'$T_S$, r = {Ts_cor:.2f}, RMSE = {Ts_rmse:.1f}', s=50)\nax.plot((0, 800), (0, 800), color='k', label='1:1 line', linestyle = '--')\n\nax.set_xlim(290,320)\nax.set_ylim(290,320)\nax.set_ylabel('Contextual UAV (K)', fontsize=16)\nax.set_xlabel('Modelled 3SEB-PT (K)', fontsize=16)\nax.legend(fontsize=12)\n\n# 3SEB-2T\nax = axes[1,0]\n# error metrics for 3SEB-2T\nTcc_rmse, Tcc_cor,_ = model_metrics(Tcc_3seb_2t,Tcc_ar, np.logical_and(Tcc_3seb_2t>270, Tcc_3seb_2t<320))\nTs_rmse, Ts_cor,_ = model_metrics(Ts_3seb_2t,Ts_ar, np.logical_and(Ts_3seb_2t>270, Ts_3seb_2t<320))\n\nax.scatter(Tcc_3seb_2t, Tcc_ar, color='yellowgreen', marker='o', label='$T_{C,sub}$'+ f', r = {Tcc_cor:.2f}, RMSE = {Tcc_rmse:.1f}', s=50)\nax.scatter(Ts_3seb_2t, Ts_ar, color='saddlebrown', marker='o', label=f'$T_S$, r = {Ts_cor:.2f}, RMSE = {Ts_rmse:.1f}', s=50)\nax.plot((270, 400), (270, 400), color='k', label='1:1 line', linestyle = '--')\n\nax.set_xlim(290,320)\nax.set_ylim(290,320)\nax.set_ylabel('Contextual UAV (K)', fontsize=16)\nax.set_xlabel('Modelled 3SEB-2T (K)', fontsize=16)\nax.legend(fontsize=12)\n\n\n# get averages over footprint\nTc_tseb_fp = np.nansum(Tc_tseb * fp_8m_ar)/np.nansum(fp_8m_ar)\nTc_3seb_fp = np.nansum(Tc_3seb_pt * fp_8m_ar)/np.nansum(fp_8m_ar)\nTc_ar_fp = np.nansum(Tc_ar * fp_8m_ar)/np.nansum(fp_8m_ar)\n\nax = axes[1,1]\nax.scatter(Tc_tseb_fp, IRT_canopy, color='orange', marker='d', label=f'TSEB-PT', s=50)\nax.scatter(Tc_3seb_fp, IRT_canopy, color='indianred', marker='o', label=f'3SEB-PT', s=50)\nax.scatter(Tc_ar_fp, IRT_canopy, color='dodgerblue', marker='^', label=f'Contextual UAV', s=50)\nax.set_ylabel('Measured $T_c$ IRT (K)', fontsize=16)\nax.set_xlabel('Estimated $T_c$ (K)', fontsize=16)\n\nax.set_xlim(290,310)\nax.set_ylim(290,310)\n\nax.plot((0, 800), (0, 800), color='k', label='1:1 line', linestyle = '--')\nax.legend(fontsize=12)\n\nplt.show()\n\nNote\n\nThere is some evidence that the contextual retrievals of temperature are overestimated according to the T_C comparison with IRT measurements but also from the overestimation of H by 3SEB-3T. How do you think we could improve this or further evaluate this?\n\nNext steps: How does the partitioning of LE/ET change with each model variant? Compare the LE_C, LE_{C,sub} and T/ET between model outputs.","type":"content","url":"/uav-3seb#comparison-of-modeled-estimated-component-temperatures-vs-uav-contextual-approach","position":67},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery"},"type":"lvl1","url":"/copernicus-tseb-3seb","position":0},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery"},"content":"","type":"content","url":"/copernicus-tseb-3seb","position":1},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl2":"Summary"},"type":"lvl2","url":"/copernicus-tseb-3seb#summary","position":2},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl2":"Summary"},"content":"Interactive jupyter notebook showing the implementation of 3SEB with satellite imagery from the Copernicus program, namely from Sentinel-2 and Sentinel-3.\n\nThis notebook will go through the pre-processing of satellite-based imagery, preparing all necesary inputs and runnign TSEB/3SEB. This includes:\n\nPre-processing and preparing satellite imagery\n\nSharpening Sentinel-3 LST\n\nEstimating biopysical variables and ancillary parameters\n\nRunning TSEB and 3SEB","type":"content","url":"/copernicus-tseb-3seb#summary","position":3},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl2":"Instructions"},"type":"lvl2","url":"/copernicus-tseb-3seb#instructions","position":4},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl2":"Instructions"},"content":"Read carefully all the text and follow the instructions.\n\nHint\n\nOnce each section is read, run the jupyter code cell underneath (marked as []) by clicking the icon Run, or pressing the keys SHIFT+ENTER of your keyboard.\n\nTo start, please run the following cell to import all the packages required for this notebook. Once you run the cell below, an acknowledgement message, stating all libraries were correctly imported, should be printed on screen.\n\nWarning\n\nMost of the functions implemented in this notebook are credited to the EOMAJI-OpenEO-Toolbox (found here: https://​github​.com​/DHI​/EOMAJI​-OpenEO​-toolbox/).\n\nThis project is under active development. Features may change and bugs may exist.\n\n","type":"content","url":"/copernicus-tseb-3seb#instructions","position":5},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl2":"Import Libraries"},"type":"lvl2","url":"/copernicus-tseb-3seb#import-libraries","position":6},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl2":"Import Libraries"},"content":"\n\n%matplotlib widget\nimport os \nimport openeo\nimport numpy as np\nfrom osgeo import gdal\nfrom pathlib import Path\nimport pandas as pd\nimport geopandas as gpd\nimport rasterio\nimport xarray\nfrom pyTSEB import TSEB\nfrom pyTSEB import meteo_utils as met\nfrom pyTSEB import net_radiation as rad\nfrom pyTSEB import resistances as res\nfrom py3seb import  py3seb \nimport matplotlib.pyplot as plt\nfrom functions import gdal_utils as gu\nfrom functions.eomaji.utils import draw_utils, date_selector\nfrom functions.eomaji.utils.general_utils import dump_area_date_info, read_area_date_info\nfrom functions.eomaji.workflows import prepare_data_cubes\nfrom functions.eomaji.workflows.decision_tree_sharpener import run_decision_tree_sharpener\nfrom functions.eomaji.workflows.sentinel2_preprocessing import split_datasets_to_tiffs\nfrom functions.eomaji.workflows.meteo_preprocessing import get_meteo_data\nfrom functions.eomaji.utils.raster_utils import resample_to_s2\n\nprint('libraries imported correctly!')\n\n","type":"content","url":"/copernicus-tseb-3seb#import-libraries","position":7},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl2":"General workflow"},"type":"lvl2","url":"/copernicus-tseb-3seb#general-workflow","position":8},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl2":"General workflow"},"content":"The general workflow to run TSEB/3SEB using Sentinel imagery from the Copernicus program is depicted below.\n\nThe main processing steps are:\n\nAcquring and pre-processing Sentinel-2 and Sentinel-3 imagery from the \n\nCDSE\n\nPerforming TIR sharpening on Sentinel-3 LST (1km ->20m) using \n\npyDMS\n\nEstimating biophysical variables (e.g. LAI) from RTM inversion using \n\npypro4sail\n\nRetrieving ancillary vegetation parameters per plant functional type based on global land cover map.\n\nAcquiring and pre-processing ERA-5 reanalysis meteo data using \n\nmeteo_utils\n\nRunning TSEB and 3SEB using \n\npyTSEB and \n\npy3SEB, respectively\n\n\n\nFigure 1:TSEB input processing using Copernicus datasets (figure credit: Héctor Nieto)\n\nNote\n\nWhile the figure above depicts the use of Landsat imagery to further correct the sharpened LST product, we won´t be implementing this in this notebook as we will solely focus on the use of Copernicus products from the CDSE.\n\nThe use of Landsat to better capture the high resolution LST variability during the sharpening process is based on the results from \n\nGuzinski et al. 2023.\n\nNote\n\nFuthermore, the global Land Cover map used in this notebook is ESA’s 10m \n\nWorldCover2021 instead of the 100m \n\nGlobal Dynamic Land Cover map fom Copernicus Land Monitoring Service.\n\n","type":"content","url":"/copernicus-tseb-3seb#general-workflow","position":9},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl2":"Requirements"},"type":"lvl2","url":"/copernicus-tseb-3seb#requirements","position":10},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl2":"Requirements"},"content":"Important\n\nIn order to execute this notebook, you will need to register in the \n\nCopernicus Data Space Ecosystem (CSDE) to process Sentinel-2 and Sentinel-3 imagery.\n\nAlong with this, to acquire ERA-5 weather data you should first register to the Copernicus’ \n\nClimate Data Store\nand \n\nAtmospheric Data Store systems.\n\nOnce registered, follow the steps in the \n\nCDS User Guide where you will get a personal URL and KEY for both CDS and ADS.\n\nYou will then need to create a .adsapirc and a .cdsapirc file with the API key like this:.adsapirc\nurl: https://ads.atmosphere.copernicus.eu/api\nkey: <api_key>\n\nand.cdsapirc\nurl: https://cds.climate.copernicus.eu/api\nkey: <api_key>\n\nExamples files are provided in./.adsapirc_example and ./cdsapirc_example.\n\n","type":"content","url":"/copernicus-tseb-3seb#requirements","position":11},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl2":"Data preparation"},"type":"lvl2","url":"/copernicus-tseb-3seb#data-preparation","position":12},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl2":"Data preparation"},"content":"This notebook will make use of Sentinel data freely available from the \n\nCopernicus Data Space Ecosystem (CDSE) platform.\n\nThe first step is to generate data cubes of the datasets needed over you area of interest.\n\nImportant\n\nTo access the data and execute the notebook, you will need to register a free account here: https://​dataspace​.copernicus​.eu/\n\n","type":"content","url":"/copernicus-tseb-3seb#data-preparation","position":13},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl3":"Select area of interest","lvl2":"Data preparation"},"type":"lvl3","url":"/copernicus-tseb-3seb#select-area-of-interest","position":14},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl3":"Select area of interest","lvl2":"Data preparation"},"content":"You have the option of drawing a polygon on the map, for the area you want to process or you can specifying the bounding box (bbox) with the format [minx, miny, maxx, maxy] i.e. [min_lon, min_lat, max_lon, max_lat]\n\nNote\n\nWe have pre-selected a bounding box around the WES experimental Almond Orchard with bbox = [-121.35,37.45, -121.10, 37.65]. Change this or use the map tool to draw a polygon to process a different area. However, the notebook is designed to be used over the WES Almond Orchard.\n\nWarning\n\nWe suggest to start with small region of interest to limit processing time. For large areas the download and aggregation of data in OpenEO may take some time and fail.\n\nmap, bboxs = draw_utils.draw_aoi()\nmap\n\n","type":"content","url":"/copernicus-tseb-3seb#select-area-of-interest","position":15},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl3":"Select a date from the available Sentinel-3 imagery","lvl2":"Data preparation"},"type":"lvl3","url":"/copernicus-tseb-3seb#select-a-date-from-the-available-sentinel-3-imagery","position":16},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl3":"Select a date from the available Sentinel-3 imagery","lvl2":"Data preparation"},"content":"Here, we will select satellite imagery over the same data and area as the UAV overpass from the WES almond orchard as from the previous notebook (./403-UAV-3SEB.ipynb).\n\nAs mentioned before, the bbox is set over the WES almond orchard area of interest but if you want to use the area that you drew on the map, you can uncomment#bbox = bboxs[-1]  # Uncomment this if you want to use the polygon drawn above\n\n\n# Define search parameters\nstart_date = \"2024-04-16\"\nend_date = \"2024-04-16\"\nbbox = [-121.35,37.45, -121.10, 37.65] # please insert a bbox here in the form of [minx, miny, maxx, maxy]\n#bbox = bboxs[-1] # Uncomment this if you want to use the polygon drawn above\n\nmax_cloud_cover = 10  # Filter out high-cloud-coverage scenes\n\n# Search for available Sentinel-3 imagery\ndate_selection = date_selector.get_available_dates(\n    start_date=start_date,\n    end_date=end_date,\n    bbox=bbox,\n    max_cloud_cover=max_cloud_cover\n)\n\n","type":"content","url":"/copernicus-tseb-3seb#select-a-date-from-the-available-sentinel-3-imagery","position":17},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl3":"Connect to OpenEO Backend","lvl2":"Data preparation"},"type":"lvl3","url":"/copernicus-tseb-3seb#connect-to-openeo-backend","position":18},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl3":"Connect to OpenEO Backend","lvl2":"Data preparation"},"content":"\n\nconnection = openeo.connect(\"https://openeo.dataspace.copernicus.eu\")\nconnection.authenticate_oidc()\n\n","type":"content","url":"/copernicus-tseb-3seb#connect-to-openeo-backend","position":19},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl3":"Pre-process Sentinel 2 and Sentinel 3 data for the specified AOI and date","lvl2":"Data preparation"},"type":"lvl3","url":"/copernicus-tseb-3seb#pre-process-sentinel-2-and-sentinel-3-data-for-the-specified-aoi-and-date","position":20},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl3":"Pre-process Sentinel 2 and Sentinel 3 data for the specified AOI and date","lvl2":"Data preparation"},"content":"We will create a folder to save the processed imagery in ./dataset/sentinel_imagery\n\nSpecify the path to store the processed satellite imagery\n\n# specify directory to save satellite imagery\ndata_dir = \"./dataset/sentinel_imagery\"\nif not os.path.isdir(data_dir):\n    os.mkdir(data_dir)\n\ndate = date_selection.value\n#date, bbox = read_area_date_info(\n#    dir=data_dir\n#) # <-- USE THIS IF YOU WANT TO REUSE BBOX AND DATE FROM FILE\n\nNow we will begin the pre-proceessing of sentinel-2 and sentinel-3 imagery and generate data cubes\n\nWarning\n\nAs mentioned previously, this section might take some time, especially for larger areas. For the pre-selected AOI over the WES almond orchard, it could take over 15-20 minutes.\n\nYou can go to https://​openeo​.dataspace​.copernicus​.eu/ and sign in to your account and follow the status of your jobs and see any errors.\n\ns2_path, s3_path, vza_path, worldcover_path, dem_s2_path, dem_s3_path, sentinel3_acq_time, = prepare_data_cubes.prepare_data_cubes(\n    connection=connection,\n    bbox=bbox,\n    date=date,\n    sentinel2_search_range = 3,\n    out_dir = data_dir,\n)\n\n","type":"content","url":"/copernicus-tseb-3seb#pre-process-sentinel-2-and-sentinel-3-data-for-the-specified-aoi-and-date","position":21},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl4":"Store AOI and data for subsequent use","lvl3":"Pre-process Sentinel 2 and Sentinel 3 data for the specified AOI and date","lvl2":"Data preparation"},"type":"lvl4","url":"/copernicus-tseb-3seb#store-aoi-and-data-for-subsequent-use","position":22},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl4":"Store AOI and data for subsequent use","lvl3":"Pre-process Sentinel 2 and Sentinel 3 data for the specified AOI and date","lvl2":"Data preparation"},"content":"\n\ndump_area_date_info(\n    date = date, \n    bbox = bbox, \n    out_dir = data_dir\n)\n\n","type":"content","url":"/copernicus-tseb-3seb#store-aoi-and-data-for-subsequent-use","position":23},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl3":"Visualize sentinel-2 and Sentinel-3 data cubes","lvl2":"Data preparation"},"type":"lvl3","url":"/copernicus-tseb-3seb#visualize-sentinel-2-and-sentinel-3-data-cubes","position":24},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl3":"Visualize sentinel-2 and Sentinel-3 data cubes","lvl2":"Data preparation"},"content":"Here, we can inspect the sentinel imagery.\n\nSentinel-2 band information:\n\n\n\nFigure 2:Sentinel-2 MSI bands information (figure taken from \n\nPasqualotto et al. 2019)\n\n# open sentinel-2 data\ns2_cube =  xarray.open_dataset(s2_path)\nband_names = [\"B02\", \"B03\", \"B04\", \"B05\", \"B07\", \"B08\", \"B8A\", \"B11\", \"B12\"]  # These are the Sentinel 2 bands to use for the sharpening\ns2_array = s2_cube[band_names].to_array(dim=\"band\").rio.write_crs(rasterio.crs.CRS.from_string(s2_cube.crs.spatial_ref).to_string())\n\n# open sentinel-3 data\ns3_cube = xarray.open_dataset(s3_path)\nlst_array = s3_cube.LST.rio.write_crs(rasterio.crs.CRS.from_string(s3_cube.crs.spatial_ref).to_string())\n\n# get extent [minx, maxx, miny, maxy]\nte = [float(s2_cube['x'].min()), float(s2_cube['x'].max()), float(s2_cube['y'].min()), float(s2_cube['y'].max())]\n\n# Read specific bands (5=NIR, 2=Red,1=green and 0=blue)\nnir_band = s2_array[5,:,:]\nred_band = s2_array[2,:,:]\ngreen_band = s2_array[1,:,:]\nblue_band = s2_array[0,:,:]\n\n# calc NDVI\nndvi_ar = (nir_band - red_band)/(nir_band + red_band)\n\n# normalize to visualize RGB\nred_norm = (red_band - np.nanmin(red_band)) / (np.nanmax(red_band) - np.nanmin(red_band))  # scale 0–1\ngreen_norm = (green_band - np.nanmin(green_band)) / (np.nanmax(green_band) - np.nanmin(green_band))  # scale 0–1\nblue_norm = (blue_band - np.nanmin(green_band)) / (np.nanmax(blue_band) - np.nanmin(blue_band))  # scale 0–1\n\nrgb_stack =  np.dstack((red_norm, green_norm, blue_norm))\n\n# plot imagery\nfig, axes = plt.subplots(2,3, figsize = (12,8), constrained_layout=True)\nax = axes[0,0]\nax.imshow(rgb_stack*5.5, extent = te)\nax.set_title('S2-True Color', fontsize=12)\n\nax = axes[0,1]\nim1 = ax.imshow(ndvi_ar, extent = te, cmap='YlGn', vmin=0.3, vmax=0.7)\nax.set_title('S2-NDVI', fontsize=12)\ncb = plt.colorbar(im1, ax=ax, shrink=0.65)\ncb.set_label(' (-)', fontsize=14)\n\nax = axes[0,2]\nim2 = ax.imshow(lst_array.values[0,:,:], extent = te, cmap='coolwarm', vmin=290, vmax=310)\nax.set_title('S3-LST', fontsize=12)\ncb = plt.colorbar(im2, ax=ax, shrink=0.65)\ncb.set_label('(K)', fontsize=14)\n\n# zoom to WES almonds\nax = axes[1,0]\nax.imshow(rgb_stack*5.5, extent = te)\nax.set_title('Zoom to Almond orchard', fontsize=12)\nax.set_xlim(654900, 655850)\nax.set_ylim(4156600, 4157500)\n\n# zoom to WES almonds\nax = axes[1,1]\nim1 = ax.imshow(ndvi_ar, extent = te, cmap='YlGn', vmin=0.3, vmax=0.7)\nax.set_title('Zoom to Almond orchard', fontsize=12)\nax.set_xlim(654900, 655850)\nax.set_ylim(4156600, 4157500)\n\n# zoom to WES almonds\nax = axes[1,2]\nim2 = ax.imshow(lst_array.values[0,:,:], extent = te, cmap='coolwarm', vmin=290, vmax=310)\nax.set_title('Zoom to Almond orchard', fontsize=12)\nax.set_xlim(654900, 655850)\nax.set_ylim(4156600, 4157500)\nplt.show()\n\n\nNote\n\nAs you can see, we do not have any plot-level information with the LST data from Sentinel-3 because it is too coarse.\n\nFor this reason, it is important to perform an LST sharpening to obtain high resolution LST at the sub-plot level\n\n","type":"content","url":"/copernicus-tseb-3seb#visualize-sentinel-2-and-sentinel-3-data-cubes","position":25},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl2":"Sentinel-3 LST Sharpening"},"type":"lvl2","url":"/copernicus-tseb-3seb#sentinel-3-lst-sharpening","position":26},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl2":"Sentinel-3 LST Sharpening"},"content":"Sentinel-3 SLSTR sensor provides thermal infrared (TIR) images at 1km spatial resolution but we can use the information from Sentinel-2 images (with 20m pixel size) to sharpnen the TIR images to 20m to obtain information at the subplot scale, especially important for agricultural applications.\n\nIn this case, we will use the Data Mining Sharpener (DMS) which was first proposed by Gao et al. (2012) (for more information see paper \n\nhere) which assumes a relationship between optical shortwave bands and LST. We will use the pyDMS code (available here: \n\nhttps://​github​.com​/radosuav​/pyDMS) to perform this sharpening.","type":"content","url":"/copernicus-tseb-3seb#sentinel-3-lst-sharpening","position":27},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl3":"Open S2 and S3 data cubes","lvl2":"Sentinel-3 LST Sharpening"},"type":"lvl3","url":"/copernicus-tseb-3seb#open-s2-and-s3-data-cubes","position":28},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl3":"Open S2 and S3 data cubes","lvl2":"Sentinel-3 LST Sharpening"},"content":"\n\n# open sentinel-2 data\ns2_cube =  xarray.open_dataset(s2_path)\nband_names = [\"B02\", \"B03\", \"B04\", \"B05\", \"B07\", \"B08\", \"B8A\", \"B11\", \"B12\"]  # These are the Sentinel 2 bands to use for the sharpening\ns2_array = s2_cube[band_names].to_array(dim=\"band\").rio.write_crs(rasterio.crs.CRS.from_string(s2_cube.crs.spatial_ref).to_string())\n\n# open sentinel-3 data\ns3_cube = xarray.open_dataset(s3_path)\nlst_array = s3_cube.LST.rio.write_crs(rasterio.crs.CRS.from_string(s3_cube.crs.spatial_ref).to_string())\nmask_array = ((s3_cube.confidence_in < 16384).astype(float).rio.write_crs(rasterio.crs.CRS.from_string(s3_cube.crs.spatial_ref).to_string()))\nprint('Done!')\n\n","type":"content","url":"/copernicus-tseb-3seb#open-s2-and-s3-data-cubes","position":29},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl3":"Run the Data Mining Sharpener","lvl2":"Sentinel-3 LST Sharpening"},"type":"lvl3","url":"/copernicus-tseb-3seb#run-the-data-mining-sharpener","position":30},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl3":"Run the Data Mining Sharpener","lvl2":"Sentinel-3 LST Sharpening"},"content":"Here we run the data mining sharpening algorithm which is based on \n\npyDMS\n\nsharpened_data = run_decision_tree_sharpener(\n    high_res_dataarray=s2_array,\n    low_res_dataarray=lst_array,\n    low_res_mask=mask_array,\n    mask_values=[1],\n    cv_homogeneity_threshold=0,\n    moving_window_size=30,\n    disaggregating_temperature=True,\n    n_jobs=3,\n    n_estimators=30,\n    max_samples=0.8,\n    max_features=0.8,\n)\n\n# specify output path for sharpened LST\nlst_outdir = Path(s3_path).parent/\"sharpened_LST.tif\"\n\nprint(f'Saving sharpened LST to {lst_outdir}')\nsharpened_data.band_data.rio.to_raster(lst_outdir)\n\nprint('Done!')\n\n","type":"content","url":"/copernicus-tseb-3seb#run-the-data-mining-sharpener","position":31},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl4":"Visualize LST sharpening","lvl3":"Run the Data Mining Sharpener","lvl2":"Sentinel-3 LST Sharpening"},"type":"lvl4","url":"/copernicus-tseb-3seb#visualize-lst-sharpening","position":32},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl4":"Visualize LST sharpening","lvl3":"Run the Data Mining Sharpener","lvl2":"Sentinel-3 LST Sharpening"},"content":"Here we plot the sharpened images but you can also inspect the images using QGIS\n\n# plot imagery\nfig, axes = plt.subplots(2,3, figsize = (12,8), constrained_layout=True)\n\nax = axes[0,0]\nax.imshow(rgb_stack*5.5, extent = te)\nax.set_title('S2-True Color', fontsize=12)\n\nax = axes[0,1]\nim2 = ax.imshow(lst_array.values[0,:,:], extent = te, cmap='coolwarm', vmin=290, vmax=310)\nax.set_title('S3-LST (1km)', fontsize=12)\n#cb = plt.colorbar(im2, ax=ax, shrink=0.65)\n#cb.set_label('(K)', fontsize=14)\n\nax = axes[0,2]\nim1 = ax.imshow(sharpened_data['band_data'].values[0,:,:], extent = te, cmap='coolwarm',vmin=290, vmax=310)\nax.set_title('S3-LST-Sharpened (20m)', fontsize=12)\ncb = plt.colorbar(im1, ax=ax, shrink=0.7)\ncb.set_label(' (K)', fontsize=12)\n\n# zoom to WES almonds\nax = axes[1,0]\nax.imshow(rgb_stack*5.5, extent = te)\nax.set_title('Zoom to Almond orchard', fontsize=12)\nax.set_xlim(654900, 655850)\nax.set_ylim(4156600, 4157500)\n\n# zoom to WES almonds\nax = axes[1,1]\nim2 = ax.imshow(lst_array.values[0,:,:], extent = te, cmap='coolwarm', vmin=290, vmax=310)\nax.set_title('Zoom to Almond orchard', fontsize=12)\nax.set_xlim(654900, 655850)\nax.set_ylim(4156600, 4157500)\n\n# zoom to WES almonds\nax = axes[1,2]\nim2 = ax.imshow(sharpened_data['band_data'].values[0,:,:], extent = te, cmap='coolwarm', vmin=290, vmax=310)\nax.set_title('Zoom to Almond orchard', fontsize=12)\nax.set_xlim(654900, 655850)\nax.set_ylim(4156600, 4157500)\nplt.show()\n\n\n","type":"content","url":"/copernicus-tseb-3seb#visualize-lst-sharpening","position":33},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl2":"Meteo and biophysical processing"},"type":"lvl2","url":"/copernicus-tseb-3seb#meteo-and-biophysical-processing","position":34},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl2":"Meteo and biophysical processing"},"content":"Now we need to process the other TSEB/3SEB inputs including the biophysical variables and meterological forcings\n\nRe-Check if all necessary imagery were pre-processed correctly\n\ns2_path, s3_path, vza_path, worldcover_path, dem_s2_path, dem_s3_path, sentinel3_acq_time = prepare_data_cubes.prepare_data_cubes(\n    connection=connection,\n    bbox=bbox,\n    date=date,\n    sentinel2_search_range = 3,\n    out_dir = data_dir,\n)\n\n# correct sentinel-3 acquisition time to UTC (seems that the function does not produce correct UTC time)\ndate_ts = pd.to_datetime(s3_cube.t.values[0])\nsentinel3_acq_time = float(date_ts.hour)\nprint('Done!')\n\n","type":"content","url":"/copernicus-tseb-3seb#meteo-and-biophysical-processing","position":35},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl3":"Estimation of biophysical variables","lvl2":"Meteo and biophysical processing"},"type":"lvl3","url":"/copernicus-tseb-3seb#estimation-of-biophysical-variables","position":36},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl3":"Estimation of biophysical variables","lvl2":"Meteo and biophysical processing"},"content":"The prepare_data_cubes function from the \n\nEOMAJI​-OpenEO​-Toolbox  internally estimates the necessary biophysical variables (i.e. LAI, Fg (green fraction), Fc (veg. fractional cover)) using the \n\nBIOPAR tool from the CDSE.\n\nThis method essentially implements a hybrid radiative transfer modeling (RTM) method where a machine learning (ML) algorithm (e.g. Artificial Neural Network-ANN) to estimate biophysical variables is trained using synthetic top-of-canopy reflectances from the RTM (i.e. PROSAIL) and then applied to the Sentinel-2 bands to retrieve the different variables.\n\n\n\nFigure 3:Flow chart showing how the BIOPAR products are generated operationally (figure taken from \n\nS2 Toolbox ATDB)\n\nYou can find the documentation of the biophysical processor \n\nhere and an adapted and more efficient version of this method can be found in the \n\npypro4sail python package.\n\nNote\n\nThe notebook ./502-Biophysical_Traits_RTM.ipynb goes into more details on how to implement these types of methods for estimating biophysical traits, offerring a step-by-step guide.\n\nOther vegetation parameters, such as canopy height (Hc), which are not estimated through the RTM inversion, need to be estimated using other methods. In this case, these are estimated using a look-up-table over a global land cover map, assigning vegetation parameters based on different plant functional types. In this case of Hc, values are then scaled based on LAI for crops or herbaceous vegetation which have strong phenological dynamics.\n\nIn other applications, ancillary non-copernicus datasets can be ingested, such as \n\nGEDI’s canopy height product, which can serve to characterize Hc in forested ecosystems.\n\nYou can find more information in Guzinski et al. (\n\n2020, \n\n2021, \n\n2023).\n\nIn the \n\nEOMAJI-OpenEO-Toolbox. , this procedure is done internally using the split_datasets_to_tiffs function after the sentinel-3 pre-processing.\n\ntif_path = split_datasets_to_tiffs(s2_path = s2_path, s3_path = s3_path, worldcover_path = worldcover_path, date = date)\n\n","type":"content","url":"/copernicus-tseb-3seb#estimation-of-biophysical-variables","position":37},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl4":"Visualize biophysical inputs","lvl3":"Estimation of biophysical variables","lvl2":"Meteo and biophysical processing"},"type":"lvl4","url":"/copernicus-tseb-3seb#visualize-biophysical-inputs","position":38},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl4":"Visualize biophysical inputs","lvl3":"Estimation of biophysical variables","lvl2":"Meteo and biophysical processing"},"content":"\n\nvariables = {'LAI':{'cmap':'YlGn', 'range':[0,5]},\n             'FCOVER':{'cmap':'Greens', 'range':[0,1]},\n             'H_C':{'cmap':'cividis', 'range':[0,10]}\n            }\n\ncmaps = ['PiYG', 'Greens', 'cividis']\n\n# make a 2x3 \nfig, axes = plt.subplots(2,3, figsize = (12,8), constrained_layout=True)\ni = 0\nfor var in variables.keys():\n    filename = tif_path/f'{str(date)[:4]}{str(date)[5:7]}{str(date)[-2:]}_{var}.tif'\n    fid = gdal.Open(str(filename))\n    ar = fid.GetRasterBand(1).ReadAsArray()\n    \n    ax = axes[0,i]\n    ax.imshow(ar, extent = te, cmap=variables[var]['cmap'], vmin=variables[var]['range'][0], vmax=variables[var]['range'][1])\n    ax.set_title(f'{var}', fontsize=12)\n\n    # zoom to WES almonds\n    ax = axes[1,i]\n    ax.imshow(ar, extent = te, cmap=variables[var]['cmap'], vmin=variables[var]['range'][0], vmax=variables[var]['range'][1])\n    ax.set_title('Zoom to Almond orchard', fontsize=12)\n    ax.set_xlim(654900, 655850)\n    ax.set_ylim(4156600, 4157500)\n    i = i + 1\n    \nplt.show()\n\n\nQuestion\n\nIn the WES almond orchard, do the biophysical values seem reasonable? What about the spatial pattern of Hc? Have a look at the land use map (./dataset/sentinel_imagery/20240416_ad419755/WordlCover2021.tif) and see how the orchard is classified? (see WorldView documentation \n\nhere)\n\nIt is often challenging to apply global methods over tree orchards which have complex characteristics and tend to be misclassified or simply classified as CROP even though they have quite different structural characteristics, especially those with co-ocurring cover crops.\n\nQuestion\n\nHow do you think this will affect the TSEB modeling and flux outputs?\n\n","type":"content","url":"/copernicus-tseb-3seb#visualize-biophysical-inputs","position":39},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl3":"Get ERA-5 Meteo data","lvl2":"Meteo and biophysical processing"},"type":"lvl3","url":"/copernicus-tseb-3seb#get-era-5-meteo-data","position":40},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl3":"Get ERA-5 Meteo data","lvl2":"Meteo and biophysical processing"},"content":"Fetch data from Atmosphere Data Store and Climate Data Store and calculate meteorological forcings.\n\nThe notebook depends on \n\nClimate Data Store and the \n\nAtmosphere Data Store. To access data from these two sources, you need to create a profile in the \n\nClimate Data Store and obtain an API key as described in the documentation:\n\nCDS User Guide\n\nImportant\n\nTo run the next functions, you need to create a .adsapirc and a .cdsapirc file with the API key like this:.adsapirc\nurl: https://ads.atmosphere.copernicus.eu/api\nkey: <api_key>\n\nand.cdsapirc\nurl: https://cds.climate.copernicus.eu/api\nkey: <api_key>\n\n# Specify path to .cdsapirc and .adsapirc files with your URL and KEY\ncds_file = \"./.cdsapirc\"\nads_file = \"./.adsapirc\"\n\nmeteo_output_path = get_meteo_data(\n    date = str(date),\n    bbox = bbox,\n    dem_path = dem_s3_path,\n    acq_time = sentinel3_acq_time,\n    data_dir=dem_s3_path.parent,\n    cds_credentials_file=cds_file,\n    ads_credentials_file=ads_file,\n)\nprint('Done!')\n\n","type":"content","url":"/copernicus-tseb-3seb#get-era-5-meteo-data","position":41},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl2":"Running TSEB"},"type":"lvl2","url":"/copernicus-tseb-3seb#running-tseb","position":42},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl2":"Running TSEB"},"content":"Now, we have all necessary inputs to run TSEB.\n\n","type":"content","url":"/copernicus-tseb-3seb#running-tseb","position":43},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl4":"Open satellite imagery as arrays","lvl2":"Running TSEB"},"type":"lvl4","url":"/copernicus-tseb-3seb#open-satellite-imagery-as-arrays","position":44},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl4":"Open satellite imagery as arrays","lvl2":"Running TSEB"},"content":"Here, we will create input dictionary (i.e. input_dict) which will store all the inputs necessary to run TSEB and 3SEB\n\n# dictioanry to store inputs arrays\ninput_dict = {}\n\n# input directory\ninput_dir = tif_path\n\n# meteo dir\nmeteo_dir = input_dir / 'meteo_data'\n\n# store inputs as in input dict\ninput_vars = ['LST', 'LAI', 'F_G', 'FCOVER', 'H_C', 'W_C', 'VZA', 'SZA', 'RHO_NIR_C', 'RHO_VIS_C', 'TAU_NIR_C', 'TAU_VIS_C']\n\nfor var in input_vars:\n    if var == 'LST':\n        filename = input_dir / 'sharpened_LST.tif'\n    else:\n        filename = input_dir/f'{str(date)[:4]}{str(date)[5:7]}{str(date)[-2:]}_{var}.tif'\n\n    # get raster info \n    if var == 'LAI':\n        proj, gt, x_size, y_size, extent, center_geo, _ = gu.raster_info(str(filename))\n\n    fid = gdal.Open(str(filename))\n    ar = fid.GetRasterBand(1).ReadAsArray()\n    # store within input dictionary\n    input_dict[var] = ar \n    \n\nmeteo_var = [\"EA\", \"p\", \"u\", \"S_dn_24\", \"S_dn\", \"T_A1\", 'LW-IN', 'ETR']\n# use LAI as a template\ntemplate_file = Path(tif_path)/f\"{str(date).replace('-', '')}_LAI.tif\"\n\nfor var in meteo_var:\n    filename = list(meteo_dir.glob(f'*{var}.tif'))[0]\n    # resample to sentinel-2 resolution\n    fid = gu.resample_with_gdalwarp(filename, template_file, \"bilinear\")\n    #fid = gdal.Open(str(filename))\n    ar = fid.GetRasterBand(1).ReadAsArray()\n    input_dict[var] = ar \n\n# parameterize constant variables\nconstant_params = {'RHO_NIR_S':0.07, # reflectance of soil in NIR\n                  'RHO_VIS_S':0.28, # reflectance of soil in VIS\n                  'E_S':0.95, # soil emissivity\n                  'E_V':0.99, # vegetation emissivity\n                  'Z0_SOIL':0.01, # soil roughness\n                  'KN_C':0.0038, # Kondo & Ishida (1997) coefficient for rough surfaces\n                  'KN_B':0.0120, # Kustas and Norman (1999) after Sauer and Norman (1995)\n                  'ALPHA_PT':1.26, # alpha parameter in Priestley-Taylor Initialization\n                  'X_LAD':1., # Chi parameter for leaf angle distribution\n                  'Fc':1, # fractional cover of vegetation\n                  'Fg':1, # fraction of vegetation that is photosynthetically active\n                  'LEAF_WIDTH':0.05 # effective leaf width\n                      \n                  }\n\nfor key in constant_params.keys():\n    ar = np.full_like(input_dict['LAI'], constant_params[key])\n    input_dict[key] = ar \n\n\nprint(f'Inputs stored in input_dict: \\n{list(input_dict.keys())}')\n\n","type":"content","url":"/copernicus-tseb-3seb#open-satellite-imagery-as-arrays","position":45},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl4":"Net Radiation and clumping","lvl2":"Running TSEB"},"type":"lvl4","url":"/copernicus-tseb-3seb#net-radiation-and-clumping","position":46},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl4":"Net Radiation and clumping","lvl2":"Running TSEB"},"content":"\n\n# calculate diffuse/direct ratio\ndifvis, difnir, fvis, fnir = TSEB.rad.calc_difuse_ratio(input_dict['S_dn'], input_dict['SZA'], press=input_dict['p'])\nskyl = fvis * difvis + fnir * difnir\nSdn_dir = (1. - skyl) * input_dict['S_dn']\nSdn_dif = skyl * input_dict['S_dn']\n\n# incoming long wave radiation\nemisAtm = rad.calc_emiss_atm(input_dict['EA'], input_dict['T_A1'])\nLsky = emisAtm * met.calc_stephan_boltzmann(input_dict['T_A1'])\n\n# We need to compute SAA\ndoy = date_ts.dayofyear\ndec_time = date_ts.hour + date_ts.minute / 60.\nsza, saa = met.calc_sun_angles(center_geo[1], center_geo[0], 0,doy, dec_time)\n\n\n# to take into account row strucure on vegetation clumping\nrow_direction = 90\npsi = row_direction - saa\n\n\nOmega0 = TSEB.CI.calc_omega0_Kustas(input_dict['LAI'], input_dict['FCOVER'], x_LAD=input_dict['X_LAD'], isLAIeff=True)\nOmega = TSEB.CI.calc_omega_rows(input_dict['LAI'], input_dict['FCOVER'], theta=input_dict['SZA'],\n                                psi=psi, w_c=input_dict['W_C'],\n                                x_lad=input_dict['X_LAD'])\n\nF = input_dict['LAI']/input_dict['FCOVER']\n# effective LAI (tree crop)\ninput_dict['LAI_EFF'] =  F * Omega\n\n\n\nsn_veg, sn_soil = TSEB.rad.calc_Sn_Campbell(input_dict['LAI'], input_dict['SZA'], Sdn_dir, Sdn_dif, fvis, fnir,\n                                                    input_dict['RHO_VIS_C'],\n                                                    input_dict['TAU_VIS_C'],\n                                                    input_dict['RHO_NIR_C'],\n                                                    input_dict['TAU_NIR_C'],\n                                                    input_dict['RHO_VIS_S'],\n                                                    input_dict['RHO_NIR_S'],\n                                                    x_LAD=input_dict['X_LAD'], LAI_eff=input_dict['LAI_EFF']) \n\nsn_veg[~np.isfinite(sn_veg)] = 0\nsn_soil[~np.isfinite(sn_soil)] = 0\n\ninput_dict['SN_VEG'] = sn_veg\ninput_dict['SN_SOIL'] = sn_soil\n\n\nprint('Done!')\n\n","type":"content","url":"/copernicus-tseb-3seb#net-radiation-and-clumping","position":47},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl4":"Landscape roughness","lvl2":"Running TSEB"},"type":"lvl4","url":"/copernicus-tseb-3seb#landscape-roughness","position":48},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl4":"Landscape roughness","lvl2":"Running TSEB"},"content":"\n\nz_0m, d_0 = TSEB.res.calc_roughness(input_dict['LAI'],\n                                    input_dict['H_C'],\n                                    input_dict['W_C'],\n                                    np.full_like(input_dict['LAI'], TSEB.res.CROP))\nd_0[d_0 < 0] = 0\nz_0m[z_0m < input_dict['Z0_SOIL']] = constant_params['Z0_SOIL']\n\n# store in input dictionary\ninput_dict['d_0'] = d_0\ninput_dict['Z_0M'] = z_0m\n\nprint('Done!')\n\n","type":"content","url":"/copernicus-tseb-3seb#landscape-roughness","position":49},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl2":"Running TSEB"},"type":"lvl2","url":"/copernicus-tseb-3seb#running-tseb-1","position":50},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl2":"Running TSEB"},"content":"Now we have processed all necessary inputs to run TSEB! Let’s run TSEB and store the results in an output dictionary (i.e. model_outdict)\n\n# output dictionary to save model results\nmodel_outdict = {}\n\n# use Norman and Kustas 1995 resistance framework\nResistance_flag=[0,{}]\n# using constant ratio appraoch to estimate G\nG_constant = 0.35\ncalcG = [[1], G_constant]\n\n[flag_PT_all, T_soil, T_veg, T_AC, Ln_soil, Ln_veg, LE_veg, H_veg,\n     LE_soil, H_soil, G_mod, R_S, R_X, R_A, u_friction, L, n_iterations] = TSEB.TSEB_PT(input_dict['LST'],\n                                                                                        input_dict['VZA'],\n                                                                                        input_dict['T_A1'],\n                                                                                        input_dict['u'],\n                                                                                        input_dict['EA'],\n                                                                                        input_dict['p'],\n                                                                                        input_dict['SN_VEG'],\n                                                                                        input_dict['SN_SOIL'],\n                                                                                        input_dict['LW-IN'],\n                                                                                        input_dict['LAI'],\n                                                                                        input_dict['H_C'],\n                                                                                        input_dict['E_V'],\n                                                                                        input_dict['E_S'],\n                                                                                        input_dict['Z_0M'],\n                                                                                        input_dict['d_0'],\n                                                                                        100,\n                                                                                        100,\n                                                                                        leaf_width=input_dict['LEAF_WIDTH'],\n                                                                                        alpha_PT=input_dict['ALPHA_PT'],\n                                                                                        f_c=input_dict['FCOVER'],\n                                                                                        f_g=input_dict['F_G'],\n                                                                                        calcG_params=calcG,\n                                                                                        resistance_form=Resistance_flag)\n\n# save ouputs in outdict \nLE = LE_veg + LE_soil\nH = H_veg + H_soil\nRn = (Ln_veg + sn_veg) + (Ln_soil + sn_soil)\n\n# Estimate daily ET assuming LE/Sdn ratio remains relatively constant troughout the day\nle_ratio = LE/input_dict['S_dn']\nET_daily = met.flux_2_evaporation(input_dict['S_dn_24'] * le_ratio, input_dict['T_A1'], time_domain=24)\n\n# evaporative stress index\nesi = ET_daily/input_dict['ETR']\n\n# save outputs to dictionary\nmodel_outdict['LE_TSEB-PT'] = LE\nmodel_outdict['LEc_TSEB-PT'] = LE_veg\nmodel_outdict['H_TSEB-PT'] = H\nmodel_outdict['Rn_TSEB-PT'] = Rn\nmodel_outdict['G_TSEB-PT'] = G_mod\nmodel_outdict['ET_TSEB-PT'] = ET_daily\nmodel_outdict['ESI_TSEB-PT'] = esi\nmodel_outdict['Flags_TSEB-PT'] = flag_PT_all\n\nte = [float(s2_cube['x'].min()), float(s2_cube['x'].max()), float(s2_cube['y'].min()), float(s2_cube['y'].max())]\n\nvariables = ['LE', 'H', 'Rn', 'G']\n# visualizing outputs \n#fig, axes = plt.subplots(2,2, figsize=(10,8))\ni = 0\nfig, axes = plt.subplots(4,2, figsize=(10,16))\n\nfor var in variables:\n    # entire ROI\n    ax = axes[i,0]\n    if var == 'LE':\n        im = ax.imshow(model_outdict[f'{var}_TSEB-PT'], vmin=0, vmax=600, cmap='PuBu', extent = te)\n    elif var == 'H':\n        im = ax.imshow(model_outdict[f'{var}_TSEB-PT'], vmin=0, vmax=600, cmap='OrRd',  extent = te)\n    elif var == 'Rn':\n        im = ax.imshow(model_outdict[f'{var}_TSEB-PT'], vmin=0, vmax=800, cmap='plasma',  extent = te)\n    else:\n        im = ax.imshow(model_outdict[f'{var}_TSEB-PT'], vmin=0, vmax=200, cmap='copper',  extent = te)\n\n    ax.set_title(f'{var}', fontsize=14)\n    flux_mean = int(np.round(np.nanmean(model_outdict[f'{var}_TSEB-PT']),0))\n    ax.text(0.01,0.1, f'mean:\\n{flux_mean} W/$m^2$', transform=ax.transAxes)\n    \n    # zoom to Almonds\n    ax = axes[i,1]\n    if var == 'LE':\n        im = ax.imshow(model_outdict[f'{var}_TSEB-PT'], vmin=0, vmax=600, cmap='PuBu', extent = te)\n    elif var == 'H':\n        im = ax.imshow(model_outdict[f'{var}_TSEB-PT'], vmin=0, vmax=600, cmap='OrRd',  extent = te)\n    elif var == 'Rn':\n        im = ax.imshow(model_outdict[f'{var}_TSEB-PT'], vmin=0, vmax=800, cmap='plasma',  extent = te)\n    else:\n        im = ax.imshow(model_outdict[f'{var}_TSEB-PT'], vmin=0, vmax=200, cmap='copper',  extent = te)\n\n    # Add colorbar \n    cbar = fig.colorbar(im, ax=ax)\n    cbar.set_label(f'{var} (W/$m^2$)')  # Add title to colorbar\n    ax.set_xlim(654900, 655850)\n    ax.set_ylim(4156600, 4157500)\n    ax.set_title(f'Zoom to Almond Orchard', fontsize=12)\n\n\n    i = i + 1\n\nplt.show()\n\nQuestion\n\nWhat do you think is driving the spatial patterns of modelled LE/H from TSEB? Have a look at the biophysical variables and parameters above.\n\n","type":"content","url":"/copernicus-tseb-3seb#running-tseb-1","position":51},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl2":"Running 3SEB"},"type":"lvl2","url":"/copernicus-tseb-3seb#running-3seb","position":52},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl2":"Running 3SEB"},"content":"As discussed previously, 3SEB uses esentially the same inputs as TSEB but needs to parameterize both vegetation layers i.e. tree crop and cover crop.\n\nImportant\n\nIn general, 3SEB should only be applied in agro-forestry systems with two distinct co-occurring vegetation layers such as savannas or tree crops with cover crops. Normally, at the satellite scale, we usually only apply 3SEB over pixels that are classified as savannas and using a global tree cover fraction product such as \n\nthis.\n\nHowever, it is still a challenge to find global land cover maps that seperate tree crops with and without cover crops as the agronomic practices may change year to year.\n\nIn other land types, such as grasslands, herbaceous crops, or tree crops without cover crops, it is recommend to implement TSEB.\n\n","type":"content","url":"/copernicus-tseb-3seb#running-3seb","position":53},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl4":"Characterizing 3SEB specific variables","lvl2":"Running 3SEB"},"type":"lvl4","url":"/copernicus-tseb-3seb#characterizing-3seb-specific-variables","position":54},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl4":"Characterizing 3SEB specific variables","lvl2":"Running 3SEB"},"content":"Here we will characterterize the two vegetation layers by making certain assumptions while attempting to best characterize the target Almond orchards.\n\nSeparating the contribution of tree and grass layers within a mixed is often challenging at global scales. In orchards with cover crops, we could use information of the different phenology of tree and cover crops to seperate both signals as done in the application of 3SEB using proximal sensing (see ./303-py3SEB-Proximal). However, ideally this seperation could be done more dynamically without prescribe information, through, for example, spectral unmixing algorithms, but this is still in development.\n\n# assumed cover crop fraction cover is 1 (this refers to fraction of vegetation cover in the substate(soil+cover crop)\ninput_dict['Fc_C'] = np.full_like(input_dict['LAI'], 0.2)\ninput_dict['Fc_CC'] = np.full_like(input_dict['LAI'], 1)\n\n# assumed tree crop has a fixed local LAI\n## tree crop \nF = 2.5\n# tree crop LAI\ninput_dict['LAI_C']=  input_dict['Fc_C'] * F\n\n## cover crop\ninput_dict['LAI_CC'] =  input_dict['LAI'] - input_dict['LAI_C']\ninput_dict['LAI_CC'][input_dict['LAI_CC']<0] = 0\n\n# cover crop height (assiming the Almond orchard target)\ninput_dict['H_C_TREE'] = np.full_like(input_dict['LAI'], 3.)\ninput_dict['H_CC'] = np.full_like(input_dict['LAI'], 0.4)\n\n# green fraction\ninput_dict['Fg_C'] = np.full_like(input_dict['LAI'], 0.9)\ninput_dict['Fg_CC'] = np.full_like(input_dict['LAI'], 1)\n\n# Leaf width\ninput_dict['LEAF_WIDTH_C'] = np.full_like(input_dict['LAI'], 0.05)\ninput_dict['LEAF_WIDTH_CC'] = np.full_like(input_dict['LAI'], 0.01)\n\n\n# calculate clumping index\n## tree crop\nOmega0 = TSEB.CI.calc_omega0_Kustas(input_dict['LAI_C'], input_dict['Fc_C'], x_LAD=input_dict['X_LAD'], isLAIeff=True)\nOmega = TSEB.CI.calc_omega_rows(input_dict['LAI_C'], input_dict['Fc_C'], theta=input_dict['SZA'],\n                                psi=psi, w_c=input_dict['W_C'], x_lad=input_dict['X_LAD'])\n# effective LAI (tree crop)\ninput_dict['LAI_EFF_C'] =  F * Omega\n\n## understory vegetation\nOmega0_un = TSEB.CI.calc_omega0_Kustas(input_dict['LAI_CC'], input_dict['Fc_CC'], x_LAD=input_dict['X_LAD'], isLAIeff=True)\nOmega_un = TSEB.CI.calc_omega_Kustas(Omega0_un, input_dict['W_C'], w_C=input_dict['SZA'])\n\nF_cc = input_dict['LAI_CC']/input_dict['Fc_CC']\n# effective LAI (cover crop)\ninput_dict['LAI_EFF_CC'] =  F_cc * Omega_un\n\nprint('Done!')\n\n","type":"content","url":"/copernicus-tseb-3seb#characterizing-3seb-specific-variables","position":55},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl4":"3-Source Net Radiation Modeling","lvl2":"Running 3SEB"},"type":"lvl4","url":"/copernicus-tseb-3seb#id-3-source-net-radiation-modeling","position":56},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl4":"3-Source Net Radiation Modeling","lvl2":"Running 3SEB"},"content":"Estimate shortwave radiation transmission using an adapted Campbell 1998 model (adapted for 3 layers). See the Supplementary Information of \n\nBurchard-Levine et al. (2022) for more details.\n\nsn_ov = net shortwave radiation for overstory (tree crop)\n\nsn_un = net shortwave radiation for understory (cover crop)\n\nsn_soil =  net shortwave radiation for soil\n\n# estimate radiation transmission using Campbell 1998 model (adapted for 3 layers)\nsn_ov, sn_s, sn_un = py3seb.calc_Sn_Campbell(input_dict['LAI_C'],\n                                       input_dict['LAI_CC'],\n                                       input_dict['SZA'],\n                                       Sdn_dir,\n                                       Sdn_dif,\n                                       fvis,\n                                       fnir,\n                                       input_dict['RHO_VIS_C'],\n                                       input_dict['RHO_VIS_C'],\n                                       input_dict['TAU_VIS_C'],\n                                       input_dict['TAU_VIS_C'],\n                                       input_dict['RHO_NIR_C'],\n                                       input_dict['RHO_NIR_C'],\n                                       input_dict['TAU_NIR_C'],\n                                       input_dict['TAU_NIR_C'],\n                                       input_dict['RHO_VIS_S'],\n                                       input_dict['RHO_NIR_S'],\n                                       input_dict['H_C_TREE'],\n                                       0.25 * input_dict['H_C_TREE'],\n                                       input_dict['W_C'],\n                                       input_dict['Fc_C'],\n                                       LAI_eff=input_dict['LAI_EFF_C'],\n                                       LAI_eff_sub=input_dict['LAI_EFF_CC'])\n\nsn_ov[~np.isfinite(sn_ov)] = 0\nsn_s[~np.isfinite(sn_s)] = 0\nsn_un[~np.isfinite(sn_un)] = 0\n\ninput_dict['SN_C'] = sn_ov\ninput_dict['SN_CC'] = sn_un\ninput_dict['SN_S'] = sn_s\n\n\n\nprint('Done!')\n\n","type":"content","url":"/copernicus-tseb-3seb#id-3-source-net-radiation-modeling","position":57},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl4":"Landscape roughness","lvl2":"Running 3SEB"},"type":"lvl4","url":"/copernicus-tseb-3seb#landscape-roughness-1","position":58},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl4":"Landscape roughness","lvl2":"Running 3SEB"},"content":"\n\n# calculate tree crop roughness parameters taking into account LAIeff using Raupach 1994 model\nz_0M_factor, d_0_factor = py3seb.raupach_94(input_dict['LAI_EFF_C'])\nd_0 = input_dict['H_C_TREE']*d_0_factor\nz_0M = input_dict['H_C_TREE']*z_0M_factor\n\nd_0[d_0 < 0] = 0\nz_0M[z_0M < input_dict['Z0_SOIL']] = constant_params['Z0_SOIL']\n\n# understory/secondary vegetation (i.e. Cover crop)\nz_0m_un, d_0_un = TSEB.res.calc_roughness(input_dict['LAI_EFF_CC'],\n                                          input_dict['H_CC'],\n                                          input_dict['W_C'],\n                                          np.full_like(input_dict['LAI'], TSEB.res.GRASS))\nd_0_un[d_0_un < 0] = 0\nz_0m_un[z_0m_un < input_dict['Z0_SOIL']] = constant_params['Z0_SOIL']\n\ninput_dict['d_0_C'] = d_0\ninput_dict['Z_0M_C'] = z_0M\n\ninput_dict['d_0_CC'] = d_0_un\ninput_dict['Z_0M_CC'] = z_0m_un\n\nprint('Done!')\n\n","type":"content","url":"/copernicus-tseb-3seb#landscape-roughness-1","position":59},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl3":"Running 3SEB-PT","lvl2":"Running 3SEB"},"type":"lvl3","url":"/copernicus-tseb-3seb#running-3seb-pt","position":60},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl3":"Running 3SEB-PT","lvl2":"Running 3SEB"},"content":"\n\n[flag_PT_all, T_S, T_C, T_C_sub, T_AC, L_n_sub, L_nC, Ln_C_sub, Ln_S, LE_C, H_C, LE_C_sub, H_C_sub,\n LE_S, H_S, G_mod, R_S, R_sub, R_X, R_A, u_friction, L, n_iterations] = py3seb.ThreeSEB_PT(input_dict['LST'],\n                                                                                         input_dict['VZA'],\n                                                                                         input_dict['T_A1'],\n                                                                                         input_dict['u'],\n                                                                                         input_dict['EA'],\n                                                                                         input_dict['p'],\n                                                                                         input_dict['SN_C'],\n                                                                                         input_dict['SN_S'],\n                                                                                         input_dict['SN_CC'],\n                                                                                         input_dict['LW-IN'],\n                                                                                         input_dict['LAI_C'],\n                                                                                         input_dict['LAI_CC'],\n                                                                                         input_dict['H_C_TREE'],\n                                                                                         input_dict['H_CC'],\n                                                                                         input_dict['E_V'],\n                                                                                         input_dict['E_V'],#change e_v cover crop\n                                                                                         input_dict['E_S'],\n                                                                                         input_dict['Z_0M_C'],\n                                                                                         input_dict['Z_0M_CC'],\n                                                                                         input_dict['d_0_C'],\n                                                                                         input_dict['d_0_CC'],\n                                                                                         100,\n                                                                                         100,\n                                                                                         leaf_width=input_dict['LEAF_WIDTH_C'],\n                                                                                         leaf_width_sub=input_dict['LEAF_WIDTH_CC'],\n                                                                                         f_c=input_dict['Fc_C'],\n                                                                                         f_c_sub=input_dict['Fc_CC'],\n                                                                                         f_g=input_dict['Fg_C'],\n                                                                                         f_g_sub=input_dict['Fg_CC'],\n                                                                                         calcG_params=calcG,\n                                                                                         resistance_form=Resistance_flag)\n# save ouputs in outdict \nLE = LE_C + LE_C_sub + LE_S\nH = H_C + H_S + H_C_sub\n\nRn_C = L_nC + sn_ov\nRn_C_sub = Ln_C_sub + sn_un\nRn_S = Ln_S + sn_s\nRn = Rn_C + Rn_C_sub + Rn_S\n\n# Estimate daily ET assuming LE/Sdn ratio remains relatively constant troughout the day\nle_ratio = LE/input_dict['S_dn']\nET_daily = met.flux_2_evaporation(input_dict['S_dn_24'] * le_ratio, input_dict['T_A1'], time_domain=24)\n\n# evaporative stress index\nesi = ET_daily/input_dict['ETR']\n\n# save outputs to dictionary\nmodel_outdict['LE_3SEB-PT'] = LE\nmodel_outdict['LEc_3SEB-PT'] = LE_C\nmodel_outdict['LEcc_3SEB-PT'] = LE_C_sub\nmodel_outdict['H_3SEB-PT'] = H\nmodel_outdict['Rn_3SEB-PT'] = Rn\nmodel_outdict['G_3SEB-PT'] = G_mod\nmodel_outdict['ET_3SEB-PT'] = ET_daily\nmodel_outdict['ESI_3SEB-PT'] = esi\n\nmodel_outdict['Flags_3SEB-PT'] = flag_PT_all\n\n# visualizing outputs \nvariables = ['LE', 'H', 'Rn', 'G']\ni = 0\nfig, axes = plt.subplots(4,2, figsize=(10,16))\n\nfor var in variables:\n    # entire ROI\n    ax = axes[i,0]\n    if var == 'LE':\n        im = ax.imshow(model_outdict[f'{var}_3SEB-PT'], vmin=0, vmax=600, cmap='PuBu', extent = te)\n    elif var == 'H':\n        im = ax.imshow(model_outdict[f'{var}_3SEB-PT'], vmin=0, vmax=600, cmap='OrRd',  extent = te)\n    elif var == 'Rn':\n        im = ax.imshow(model_outdict[f'{var}_3SEB-PT'], vmin=0, vmax=800, cmap='plasma',  extent = te)\n    else:\n        im = ax.imshow(model_outdict[f'{var}_3SEB-PT'], vmin=0, vmax=200, cmap='copper',  extent = te)\n\n    ax.set_title(f'{var}', fontsize=14)\n    flux_mean = int(np.round(np.nanmean(model_outdict[f'{var}_3SEB-PT']),0))\n    ax.text(0.01,0.1, f'mean:\\n{flux_mean} W/$m^2$', transform=ax.transAxes)\n    \n    # zoom to Almonds\n    ax = axes[i,1]\n    if var == 'LE':\n        im = ax.imshow(model_outdict[f'{var}_3SEB-PT'], vmin=0, vmax=600, cmap='PuBu', extent = te)\n    elif var == 'H':\n        im = ax.imshow(model_outdict[f'{var}_3SEB-PT'], vmin=0, vmax=600, cmap='OrRd',  extent = te)\n    elif var == 'Rn':\n        im = ax.imshow(model_outdict[f'{var}_3SEB-PT'], vmin=0, vmax=800, cmap='plasma',  extent = te)\n    else:\n        im = ax.imshow(model_outdict[f'{var}_3SEB-PT'], vmin=0, vmax=200, cmap='copper',  extent = te)\n\n    # Add colorbar \n    cbar = fig.colorbar(im, ax=ax)\n    cbar.set_label(f'{var} (W/$m^2$)')  # Add title to colorbar\n    ax.set_xlim(654900, 655850)\n    ax.set_ylim(4156600, 4157500)\n    ax.set_title(f'Zoom to Almond Orchard', fontsize=12)\n\n\n    i = i + 1\n\nplt.show()\n\nNote\n\nIn this case, the comparison between TSEB-PT and 3SEB-PT is not entirely fair since we used tailored inputs specific for the Almond orchards in 3SEB-PT for the entire scene while TSEB-PT used a dynamic vegetation parameterization based on global methods.\n\nYou can re-run TSEB-PT using parameter values expected for the Almond Orchard and see if the results change significantly over the experimental area.\n\nNext steps and Questions\n\nYou can evaluate both TSEB-PT and 3SEB-PT over the tower footprint. Hint: see ./403-UAV_3SEB.ipynb\n\nHow to these satellite-based outputs compare to the UAV results from ./403-UAV_3SEB.ipynb?\n\nAny other global datasets that can be used to improve this workflow for tree crops?\n\n","type":"content","url":"/copernicus-tseb-3seb#running-3seb-pt","position":61},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl2":"Conclusions"},"type":"lvl2","url":"/copernicus-tseb-3seb#conclusions","position":62},{"hierarchy":{"lvl1":"Running TSEB/3SEB with Satellite Imagery","lvl2":"Conclusions"},"content":"The Copernicus program offers a large set of products that are suitable to model ET globally\n\n3SEB presents the advantage of partitioning fluxes from two distict coexisting canopies, suitable to better simluate orchards with cover crops\n\nHowever, it remains a challenge to well characterize and parameterize the two vegetation canopies solely relying on global datasets\n\n[...]\n\nNote\n\nPlease feel free comment any thoughts. This is work in progress!!!","type":"content","url":"/copernicus-tseb-3seb#conclusions","position":63},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion"},"type":"lvl1","url":"/biophysical-traits-rtm","position":0},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion"},"content":"","type":"content","url":"/biophysical-traits-rtm","position":1},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl2":"Summary"},"type":"lvl2","url":"/biophysical-traits-rtm#summary","position":2},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl2":"Summary"},"content":"Interactive jupyter notebook demonstrating the retrieval of biophysical variables by inverting a Radiative Transfer Model (RTM) using a hybrid appraoch, showing its applicability with Sentinel-2 imagery.\nThis notebook will go through:\n\nBuiling synthetic Lool-up-Table (LUT) with pypro4sail\n\nTraining Random Forest algorithm with LUT\n\nEvaluating Random Forest algorithm to estimate biophysical traits.\n\nInversion of Sentinel-2 bands to retrieve biophysical traits","type":"content","url":"/biophysical-traits-rtm#summary","position":3},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl2":"Instructions"},"type":"lvl2","url":"/biophysical-traits-rtm#instructions","position":4},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl2":"Instructions"},"content":"Read carefully all the text and follow the instructions.\n\nHint\n\nOnce each section is read, run the jupyter code cell underneath (marked as []) by clicking the icon Run, or pressing the keys SHIFT+ENTER of your keyboard.\n\nTo start, please run the following cell to import all the packages required for this notebook. Once you run the cell below, an acknowledgement message, stating all libraries were correctly imported, should be printed on screen.\n\n","type":"content","url":"/biophysical-traits-rtm#instructions","position":5},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl2":"Import Libraries"},"type":"lvl2","url":"/biophysical-traits-rtm#import-libraries","position":6},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl2":"Import Libraries"},"content":"\n\n%matplotlib widget\nimport os \nimport openeo\nimport numpy as np\nimport xarray as xr\nimport rasterio\nfrom osgeo import gdal\nfrom pathlib import Path\nimport multiprocess as mp\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom pypro4sail import machine_learning_regression as inv\nfrom functions.biophysical import get_diffuse_radiation_6S, build_soil_database, SRF_LIBRARY, S2_BANDS\nfrom functions import gdal_utils as gu\nfrom functions.eomaji.utils import date_selector\nfrom sklearn.ensemble import RandomForestRegressor as rf_sklearn\nimport datetime as dt\nfrom model_evaluation import double_collocation as dc\nfrom dateutil.relativedelta import relativedelta\nimport datetime\nimport logging\nlogging.getLogger(\"sklearnex\").setLevel(logging.ERROR)\n\nprint('libraries imported correctly!')\n\n","type":"content","url":"/biophysical-traits-rtm#import-libraries","position":7},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl2":"General workflow"},"type":"lvl2","url":"/biophysical-traits-rtm#general-workflow","position":8},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl2":"General workflow"},"content":"This biophysical retrieval method essentially inverts a radiative transfer model (RTM) using a hybrid method where a machine learning (ML) algorithm between top-of-canopy reflectances and biophysical traits is trained using a physically-based RTM (i.e. PRO4SAIL) and is then applied to the Sentinel-2 bands to retrieve the different biophysical variables. This is the method used in the official Sentinel-2 biophysical processor (documentation found \n\nhere) where the workflow is shown in the figure below:\n\n\n\nFigure 3:Flow chart showing how the BIOPAR products are generated operationally (figure taken from \n\nS2 Toolbox ATDB)\n\nIn this notebook, we will use a very similar methodology using the pyhton implementation of \n\npypro4sail. It is essentially the same method described in the above figure, but using Random Forest regressor instead of an Artificial Neural Network (ANNs) algorithm and using a more computationally efficienty Pro4SAIL model (using jacobians).\n\n","type":"content","url":"/biophysical-traits-rtm#general-workflow","position":9},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl2":"Building synthetic dataset"},"type":"lvl2","url":"/biophysical-traits-rtm#building-synthetic-dataset","position":10},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl2":"Building synthetic dataset"},"content":"First, we will build a synthetic dataset where a look-up-table (LUT) will be created using PRO4SAIL that relates top-of-canopy spectra and biophysical variables.\n\nThe target biophysical variables are: [“Cab”, “Car”, “Cm”, “Cw”, “Ant”, “Cbrown”,“LAI”, “leaf_angle”].","type":"content","url":"/biophysical-traits-rtm#building-synthetic-dataset","position":11},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl4":"Leaf biochemical traits (from PROSPECT):","lvl2":"Building synthetic dataset"},"type":"lvl4","url":"/biophysical-traits-rtm#leaf-biochemical-traits-from-prospect","position":12},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl4":"Leaf biochemical traits (from PROSPECT):","lvl2":"Building synthetic dataset"},"content":"Cab (Chlorophyll a + b content)\nThe amount of chlorophyll pigments per unit leaf area, usually expressed in µg/cm².\n\nCar (Carotenoid content)\nConcentration of carotenoids (xanthophylls + carotenes) per unit leaf area, expressed in µg/cm².\n\nCm (Leaf dry matter content)\nThe mass of dry matter (structural compounds like cellulose, lignin, proteins, etc.) per unit leaf area, usually in g/cm².\n\nCw (Equivalent leaf water thickness)\nThe water content of the leaf per unit area, in cm (equivalent water thickness).\n\nAnt (Anthocyanin content)\nConcentration of anthocyanins per unit leaf area (µg/cm²).\n\nCbrown (Brown pigment content)\nA semi-empirical parameter representing the amount of “brown pigments” (products of leaf senescence, degradation of chlorophyll, accumulation of tannins, etc.).","type":"content","url":"/biophysical-traits-rtm#leaf-biochemical-traits-from-prospect","position":13},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl4":"Canopy structural traits (from SAIL):","lvl2":"Building synthetic dataset"},"type":"lvl4","url":"/biophysical-traits-rtm#canopy-structural-traits-from-sail","position":14},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl4":"Canopy structural traits (from SAIL):","lvl2":"Building synthetic dataset"},"content":"LAI (Leaf Area Index)\nTotal one-sided leaf area per unit ground area (m²/m²).\n\nleaf_angle (Leaf angle distribution parameter)\nA parameter describing the average orientation of leaves in the canopy, often represented by an ellipsoidal distribution.\nLow values → leaves more horizontally oriented (planophile).\nHigh values → leaves more vertically oriented (erectophile).\n\n","type":"content","url":"/biophysical-traits-rtm#canopy-structural-traits-from-sail","position":15},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl3":"Forward RTM simulations to build LUT","lvl2":"Building synthetic dataset"},"type":"lvl3","url":"/biophysical-traits-rtm#forward-rtm-simulations-to-build-lut","position":16},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl3":"Forward RTM simulations to build LUT","lvl2":"Building synthetic dataset"},"content":"We will perform 40000 PRO4SAIL simulations in Forward mode (i.e. using vegetation paramters to simulate surface reflectance based on the RTM’s description of light-canopy intereactions) using global vegetation parameters bounds as specified below, which are taken from global datasets (e.g. \n\nLOPEX). This is done to be able to train the model over a wide range of condtions and be globally applicable.\n\nn_simulations = 40000\n\n# parameter names\nOBJ_PARAM_NAMES = [\"Cab\", \"Car\", \"Cm\", \"Cw\", \"Ant\", \"Cbrown\",\n                   \"LAI\", \"leaf_angle\"]\n# parameter info\nPARAM_PROPS = {\"Cab\": [\"Chlorophyll a+b\", r\"$\\mu g\\,cm^{-2}$\", 1],\n               \"Car\": [\"Carotenoids\", r\"$\\mu g\\,cm^{-2}$\", 1],\n               \"Cm\": [\"Dry matter\", r\"$g\\,cm^{-2}$\", 3],\n               \"Cw\": [\"Water content\", r\"$g\\,cm^{-2}$\", 3],\n               \"Ant\": [\"Antocyanins\", r\"$\\mu g\\,cm^{-2}$\", 1],\n               \"Cbrown\": [\"Brown pigments\", r\"$-$\", 1],\n               \"LAI\": [\"Leaf Area Index\", r\"$m^{2}\\,m^{-2}$\", 2],\n               \"leaf_angle\": [\"Mean leaf inclination angle\", r\"º\", 1]}\n\n# specify range of variable values\n## minimum\nMIN_N_LEAF = 1.0  # From LOPEX + ANGERS average\nMIN_CAB = 0.0  # From LOPEX + ANGERS average\nMIN_CAR = 0.0  # From LOPEX + ANGERS average\nMIN_CBROWN = 0.0  # from S2 L2B ATBD\nMIN_CM = 0.0017  # From LOPEX + ANGERS average\nMIN_CW = 0.000  # From LOPEX + ANGERS average\nMIN_ANT = 0.0\nMIN_LAI = 0.0\nMIN_LEAF_ANGLE = 30.0  # from S2 L2B ATBD\nMIN_HOTSPOT = 0.1  # from S2 L2B ATBD\nMIN_BS = 0.50  # from S2 L2B ATBD\n\n## maximum\nMAX_N_LEAF = 3.0  # From LOPEX + ANGERS average\nMAX_CAB = 110.0  # From LOPEX + ANGERS average\nMAX_CAR = 30.0  # From LOPEX + ANGERS average\nMAX_CBROWN = 2.00  # from S2 L2B ATBD\nMAX_CM = 0.0331  # From LOPEX + ANGERS average\nMAX_CW = 0.0525  # From LOPEX + ANGERS average\nMAX_ANT = 40.0\nMAX_LAI = 5  # from S2 L2B ATBD\nMAX_LEAF_ANGLE = 80.0  # from S2 L2B ATBD\nMAX_HOTSPOT = 0.5  # from S2 L2B ATBD\nMAX_BS = 3.5  # from S2 L2B ATBD\n\nprosail_bounds = {'N_leaf': (MIN_N_LEAF, MAX_N_LEAF),\n                  'Cab': (MIN_CAB, MAX_CAB),\n                  'Car': (MIN_CAR, MAX_CAR),\n                  'Cbrown': (MIN_CBROWN, MAX_CBROWN),\n                  'Cw': (MIN_CW, MAX_CW),\n                  'Cm': (MIN_CM, MAX_CM),\n                  'Ant': (MIN_ANT, MAX_ANT),\n                  'LAI': (MIN_LAI, MAX_LAI),\n                  'leaf_angle': (MIN_LEAF_ANGLE, MAX_LEAF_ANGLE),\n                  'hotspot': (MIN_HOTSPOT, MAX_HOTSPOT),\n                  'bs': (MIN_BS, MAX_BS)}\ndf_bounds = pd.DataFrame(prosail_bounds, index=['min', 'max'])\nn_simulations = 40000\nprint(f'Setting up {n_simulations} simulations with inputs bounds:\\n\\n {df_bounds[OBJ_PARAM_NAMES]}')\nparams_orig = inv.build_prosail_database(n_simulations,\n                                         param_bounds=prosail_bounds,\n                                         distribution=inv.SALTELLI_DIST)\nprint('\\nDone!')\nprint('Table with simulation inputs:')\npd.DataFrame(params_orig)\n\n","type":"content","url":"/biophysical-traits-rtm#forward-rtm-simulations-to-build-lut","position":17},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl3":"Estimate diffuse irradiance","lvl2":"Building synthetic dataset"},"type":"lvl3","url":"/biophysical-traits-rtm#estimate-diffuse-irradiance","position":18},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl3":"Estimate diffuse irradiance","lvl2":"Building synthetic dataset"},"content":"\n\nprint(f\"Running 6S for estimation of diffuse/direct irradiance\")\n# specify geometric variables (this normally can be acquired from Sentinel-2 metadata)\n# As an example, we specify default values\naot = 1. # Aerosol optical thicness\nwvp = 25. # water vapour\nsza = 37.5 # sun zenith angle\nsaa = 180 # sun azimuth angle\nvza = 25 # sensor viewing angle\n\n# specify date\ndate_obj = dt.datetime(2023, 8, 5, 10, 30)\n\nskyl = get_diffuse_radiation_6S(aot, wvp, sza, saa, date_obj,\n                                                   altitude=0.1)\nprint('Done!')\n\n","type":"content","url":"/biophysical-traits-rtm#estimate-diffuse-irradiance","position":19},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl3":"Build soil spectral database","lvl2":"Building synthetic dataset"},"type":"lvl3","url":"/biophysical-traits-rtm#build-soil-spectral-database","position":20},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl3":"Build soil spectral database","lvl2":"Building synthetic dataset"},"content":"\n\nprint(f\"Building {np.size(params_orig['bs'])} PROSPECTD+4SAIL simulations\")\nsoil_spectrum = build_soil_database(params_orig[\"bs\"])\nprint('Done!')\n\n","type":"content","url":"/biophysical-traits-rtm#build-soil-spectral-database","position":21},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl2":"Simulate Sentinel-2 spectra"},"type":"lvl2","url":"/biophysical-traits-rtm#simulate-sentinel-2-spectra","position":22},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl2":"Simulate Sentinel-2 spectra"},"content":"We are interested in inverting Sentinel-2 top-of-canopy reflectance to retrieve the biophysical variables. As such, we will need to take into account the chracteristics of the Sentinel-2 sensor.\n\n\n\nFigure 2:Sentinel-2 MSI bands information (figure taken from \n\nPasqualotto et al. 2019)\n\nIn this case, we will use bands [‘B02’, ‘B03’, ‘B04’, ‘B05’, ‘B06’, ‘B07’, ‘B08’, ‘B8A’, ‘B11’, ‘B12’] as our ‘features’ to invert the RTM.\n\nFirst, will need to convolve the surface reflectance to the spectral response function (SRF) of the Sentinel-2 sensor to best simulate this sensor.","type":"content","url":"/biophysical-traits-rtm#simulate-sentinel-2-spectra","position":23},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl4":"Visualize Sentinel-2 Spectral Response Function (SRF)","lvl2":"Simulate Sentinel-2 spectra"},"type":"lvl4","url":"/biophysical-traits-rtm#visualize-sentinel-2-spectral-response-function-srf","position":24},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl4":"Visualize Sentinel-2 Spectral Response Function (SRF)","lvl2":"Simulate Sentinel-2 spectra"},"content":"\n\n# bands to use in generating LUT and inversion\nS2_BANDS = ['B02', 'B03', 'B04', 'B05', 'B06', 'B07', 'B08', 'B8A', 'B11', 'B12']\n# Stack spectral bands\nsrf = []\nsrf_file = SRF_LIBRARY / f'Sentinel2A.txt'\nsrfs = np.genfromtxt(srf_file, dtype=None, names=True)\nfor band in S2_BANDS:\n    srf.append(srfs[band])\n\n\n# open as pandas dataframe\nsrf_df = pd.read_csv(srf_file, sep = '\\t')\n\nband_names = srf_df[S2_BANDS].columns\n\n# plot spectral response function\ncolormap = plt.cm.rainbow # Choose a colormap\n# get color within colormap range for each band (depends on number of bands)\ncolors = [colormap(x / (len(band_names) - 1)) for x in range(len(band_names))]\n\n# Show spectral response function (SRF) curves\nplt.figure(figsize=(9, 5))\nplt.title(f'Spectral Response Function (SRF) - Sentinel-2', fontsize=14)\nplt.xlabel('Wavelength (nm)', fontsize=12)\nplt.xlim(400, 2500)\nplt.ylabel('Relative Response (-)', fontsize=12)\nplt.ylim(0, 1)\nplt.grid(True)\ni = 0\nfor band in band_names:\n    plt.plot(srf_df['SR_WL'], srf_df[band], color=colors[i], label = f'{str(band)}')\n    i += 1\n\nplt.legend(loc='lower right', ncol=5)\nplt.show()\n\n\n\n","type":"content","url":"/biophysical-traits-rtm#visualize-sentinel-2-spectral-response-function-srf","position":25},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl3":"Build simulated Sentinel-2-like Look-Up-Table (LUT)","lvl2":"Simulate Sentinel-2 spectra"},"type":"lvl3","url":"/biophysical-traits-rtm#build-simulated-sentinel-2-like-look-up-table-lut","position":26},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl3":"Build simulated Sentinel-2-like Look-Up-Table (LUT)","lvl2":"Simulate Sentinel-2 spectra"},"content":"Here we will mimic sentinel-2 surface reflectance using the PRO4SAIL RTM. For this testing, we will assume certain geometric and atmospheric conditions with specific values for sun zenith angle (sza), sun azimuth angle (saa), sensor viewing zenith angle (vza), water vapour (wvp).\n\n# if you want to save the LUT generating you can can specify a directory for lut_outfile\nlut_outfile = None\n\n# spectral range\nwls_sim = np.arange(400, 2501)\n\n# number of CPUs to use to perform simulations \n# (can change depending on number of CPUs in your computer)\nnjobs = 4\n\n# generate LUT\nrho_canopy_vec, params = inv.simulate_prosail_lut_parallel(\n        njobs,\n        params_orig,\n        wls_sim,\n        soil_spectrum,\n        skyl=skyl,\n        sza=sza,\n        vza=vza,\n        psi=0,\n        srf=srf,\n        outfile=lut_outfile,\n        calc_FAPAR=False,\n        reduce_4sail=True)\n\nprint('Done!')\n\n\n","type":"content","url":"/biophysical-traits-rtm#build-simulated-sentinel-2-like-look-up-table-lut","position":27},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl2":"Training model using synthetic LUT"},"type":"lvl2","url":"/biophysical-traits-rtm#training-model-using-synthetic-lut","position":28},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl2":"Training model using synthetic LUT"},"content":"Here we will train a Random Forest (RF) regressor with \n\nScikit-learn from the synthetic LUT generated with the PROSAIL simulations, which relate Sentinel-2 bands with biophysical variables.\n\nWe train individual RF models for each target variables (i.e. LAI, Cab, Car, Cm, Cw, Ant, Cbrown, leaf_angle)\n\n# Approach 1: Train individual random forest model for each variable\nprint(f\"Training {len(OBJ_PARAM_NAMES)} Random forests for \"\n      f\"{','.join(OBJ_PARAM_NAMES)}\")\n\n# RF paramters\nscikit_regressor_opts = {\"n_estimators\": 100,\n                         \"min_samples_leaf\": 1,\n                         \"n_jobs\": -1}\n\nstart_time = dt.datetime.today()\ninput_scalers = {}\noutput_scalers = {}\nregs = {}\nfor i, param in enumerate(OBJ_PARAM_NAMES):\n    reg, input_gauss_scaler, output_gauss_scaler, _ = \\\n        inv.train_reg(rho_canopy_vec,\n                      params[param].reshape(-1, 1),\n                      scaling_input='normalize',\n                      scaling_output='normalize',\n                      regressor_opts=scikit_regressor_opts,\n                      reg_method=\"random_forest\")\n\n    input_scalers[param] = input_gauss_scaler\n    output_scalers[param] = output_gauss_scaler\n    regs[param] = reg\n    \nend_time_standard = dt.datetime.today() - start_time\n\nprint(\"\\nProcessing time (Training):\")\nprint(f\"\\t{len(OBJ_PARAM_NAMES)} Random forests: {end_time_standard}\")\n    \nprint('Done!')\n\n","type":"content","url":"/biophysical-traits-rtm#training-model-using-synthetic-lut","position":29},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl2":"Testing model"},"type":"lvl2","url":"/biophysical-traits-rtm#testing-model","position":30},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl2":"Testing model"},"content":"We will now test the RF regression model using synthetic sentinel-2-like reflectance to see how well the trained RF model can simulate the RTM. In this case, we will add some random noise to the testing surface reflectance to better mimic real conditions that occur with optical sensors.\n\n# create synthetic Sentine-2-like spectra\nrho_canopy_test, params_test = inv.simulate_prosail_lut_parallel(\n        njobs,\n        params_orig,\n        wls_sim,\n        soil_spectrum,\n        skyl=skyl,\n        sza=sza,\n        vza=vza,\n        psi=0,\n        srf=srf,\n        outfile=None,\n        calc_FAPAR=False,\n        reduce_4sail=True)\n\n# set how much noise to add (either relative or absolute)\nrel_unc = 0.1\nabs_unc = 0.015\nRELATIVE_UNC = 1\nABSOLUTE_UNC = 0\nnoise_method = RELATIVE_UNC\n# add noise to mimic real conditions\nif noise_method == RELATIVE_UNC:\n    stdev = rho_canopy_test * rel_unc\n    white_noise = np.random.normal(scale=stdev, size=rho_canopy_test.shape)\n    rho_canopy_test = rho_canopy_test * (1 + white_noise)\nelse:\n    white_noise = np.random.normal(scale=abs_unc, size=rho_canopy_test.shape)\n    rho_canopy_test = rho_canopy_test + white_noise\n    \nprint('Done!')\n\n","type":"content","url":"/biophysical-traits-rtm#testing-model","position":31},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl2":"Evaluation of the retrievals of biophysical variables"},"type":"lvl2","url":"/biophysical-traits-rtm#evaluation-of-the-retrievals-of-biophysical-variables","position":32},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl2":"Evaluation of the retrievals of biophysical variables"},"content":"Now we will apply the trained model on the testing dataset to see how well we can estimate the biophysical traits using this hybrid approach.\n\nfigsize = 16 / 2.45, 22 / 2.45\n\nstart_time = dt.datetime.today()\n# Apply individual RF model to test data\nprint(f\"Applying individual RF regression model to Sentinel-like spectra\")\noutput_regs = {}\nfor i, param in enumerate(OBJ_PARAM_NAMES):\n    output = output_scalers[param].inverse_transform(\n        regs[param].predict(\n            input_scalers[param].transform(\n                rho_canopy_test)).reshape(-1, 1)).reshape(-1)\n    output_regs[param] = output\n\nend_time_standard = dt.datetime.today() - start_time\n\nprint(\"\\nProcessing time (Testing):\")\nprint(f\"\\t{len(OBJ_PARAM_NAMES)} Random forests: {end_time_standard}\")\nprint('\\nPloting scatter plots...')\n#outfile = out_dir / f\"evaluation_singleRF.eps\"\nfig, axs = plt.subplots(ncols=2, nrows=4,\n                        figsize=figsize)\n\nfig.supxlabel(\"Estimated\")\nfig.supylabel(\"Observed\")\n\naxs = axs.reshape(-1)\nerror_table = pd.DataFrame({\"Trait\" : [], \"N\": [], \"bias\": [],\n                            \"RMSE\": [], \"r\": []})\nfor i, param in enumerate(OBJ_PARAM_NAMES):\n    name, unit, decs = PARAM_PROPS[param]\n    txt_template =  (\"   N: {:>6d}\\n\"\n                     \"bias: {:>6.%sf}\\n\"\n                     \"RMSE: {:>6.%sf}\\n\"\n                     \"   r: {:>6.2f}\")%(decs, decs)\n    \n    test = output_regs[param]\n    cor, *_ = dc.agreement_metrics(params_test[param] ,test)\n    bias, mae, rmse = dc.error_metrics(params_test[param], test)\n    dc.density_plot(test, params_test[param], axs[i], s=1, rasterized=True)\n\n    absline = np.asarray([[np.amin(params_test[param]), np.amax(params_test[param])],\n                          [np.amin(params_test[param]), np.amax(params_test[param])]])\n\n    axs[i].plot(absline[0], absline[1], \"k:\")\n    axs[i].set_title(f\"{name} ({unit})\")\n    axs[i].text(0.05,\n                0.95,\n                txt_template.format(len(test), bias, rmse, cor),\n                va=\"top\",\n                fontfamily=\"monospace\",\n                transform=axs[i].transAxes)\n\n    error_dict = {\"Trait\" : [param], \"N\": [len(test)], \"bias\": [bias],\n                  \"RMSE\": [rmse], \"r\": [cor]}\n    error_table = pd.concat([error_table, pd.DataFrame(error_dict)],\n                            ignore_index=True)\n\nplt.tight_layout()\nplt.show()\nprint('Error metrics table:')\nerror_table\n\nNote\n\nAs shown, this hybrid approach allows to train an empirical RF regressor based on the simulations of synthetic datasets of surface reflectance and biophysical variables from a physically-based RTM. This trained model can then be easily applied to Sentinel-2 imagery and is much more computationally efficient than inverting an RTM using traditional approaches.\n\n","type":"content","url":"/biophysical-traits-rtm#evaluation-of-the-retrievals-of-biophysical-variables","position":33},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl2":"Apply RF model to real Sentinel-2 image"},"type":"lvl2","url":"/biophysical-traits-rtm#apply-rf-model-to-real-sentinel-2-image","position":34},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl2":"Apply RF model to real Sentinel-2 image"},"content":"Let us now apply this trained model on sentinel-2 image to retrieve the different biophysical traits.\n\nWe wil again acquire the data from the Copernicus Data Space Ecosystem (CDSE).\n\nImportant\n\nIn order to execute this notebook, you will need to register in the \n\nCopernicus Data Space Ecosystem (CSDE) to acquire and process Sentinel-2 imagery.\n\n","type":"content","url":"/biophysical-traits-rtm#apply-rf-model-to-real-sentinel-2-image","position":35},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl3":"Connect to OpenEO Backend","lvl2":"Apply RF model to real Sentinel-2 image"},"type":"lvl3","url":"/biophysical-traits-rtm#connect-to-openeo-backend","position":36},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl3":"Connect to OpenEO Backend","lvl2":"Apply RF model to real Sentinel-2 image"},"content":"\n\nconnection = openeo.connect(\"https://openeo.dataspace.copernicus.eu\")\nconnection.authenticate_oidc()\n\n","type":"content","url":"/biophysical-traits-rtm#connect-to-openeo-backend","position":37},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl4":"Visualize information of Sentinel-2 collection","lvl3":"Connect to OpenEO Backend","lvl2":"Apply RF model to real Sentinel-2 image"},"type":"lvl4","url":"/biophysical-traits-rtm#visualize-information-of-sentinel-2-collection","position":38},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl4":"Visualize information of Sentinel-2 collection","lvl3":"Connect to OpenEO Backend","lvl2":"Apply RF model to real Sentinel-2 image"},"content":"We can get all the band and metadta information related to the Sentinel-2 L2A product with the connection.describe_collection(“SENTINEL2_L2A”) function\n\nconnection.describe_collection(\"SENTINEL2_L2A\")\n\n","type":"content","url":"/biophysical-traits-rtm#visualize-information-of-sentinel-2-collection","position":39},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl2":"Load Sentinel-2 image using OpenEO"},"type":"lvl2","url":"/biophysical-traits-rtm#load-sentinel-2-image-using-openeo","position":40},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl2":"Load Sentinel-2 image using OpenEO"},"content":"Choose date and area of interest of sentinel-2 imager\n\nNote\n\nBy default, we will use the image acquired over the WES Almond orchard near the UAV overpass (April 16th 2024)\n\n\n# Define search parameters\ndate = datetime.date(2024, 4, 16)\nbbox = [-121.35,37.45, -121.10, 37.65] # please insert a bbox here in the form of [minx, miny, maxx, maxy\ntime_window = [\n        str(date + relativedelta(days=-3)),\n        str(date + relativedelta(days=+3)),\n    ]\naoi = dict(zip([\"west\", \"south\", \"east\", \"north\"], bbox))\n\ns2_ref_bands = [\n        \"B02\",\n        \"B03\",\n        \"B04\",\n        \"B05\",\n        \"B06\",\n        \"B07\",\n        \"B08\",\n        \"B8A\",\n        \"B11\",\n        \"B12\"\n    ]\n\ns2_meta_bands = [\"SCL\",\n                 'WVP',\n                 'AOT',\n                 'sunAzimuthAngles',\n                 'sunZenithAngles',\n                 'viewZenithMean'\n                ]\n\n\n","type":"content","url":"/biophysical-traits-rtm#load-sentinel-2-image-using-openeo","position":41},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl4":"Pre-process Sentinel-2 image","lvl2":"Load Sentinel-2 image using OpenEO"},"type":"lvl4","url":"/biophysical-traits-rtm#pre-process-sentinel-2-image","position":42},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl4":"Pre-process Sentinel-2 image","lvl2":"Load Sentinel-2 image using OpenEO"},"content":"\n\n# set up outfile\ns2_dir =  Path(\"./dataset/sentinel_imagery\")\ns2_outfile = s2_dir / \"s2_cube_bio.nc\"\n\noverwrite = False\n\nif s2_outfile.exists() and overwrite == False:\n    print(f'{s2_outfile} already exists..')\nelse:\n    print('Loading S2 data cube from Copernicus Data Space Ecosystem..')\n    # Load Sentinel-2 cube and merge with Biopar\n    s2_cube = connection.load_collection(\n        \"SENTINEL2_L2A\", spatial_extent=aoi, temporal_extent=time_window, bands=s2_ref_bands+s2_meta_bands)\n    \n    print('Mask out non-vegetated pixels...')\n    # Apply cloud and shadow mask using SCL (keep only class 4 and 5 = vegetation/bare)\n    mask = ~((s2_cube.band(\"SCL\") == 4) | (s2_cube.band(\"SCL\") == 5))\n    s2_masked = s2_cube.mask(mask)\n    \n    print('Select best available pixel from time window')\n    # Reduce time dimension by selecting the first valid observation\n    s2_best_pixel = s2_masked.reduce_dimension(dimension=\"t\", reducer=\"first\")\n    \n    print(f'Saving s2 cube as {s2_outfile} .. ')\n    s2_best_pixel.download(str(s2_outfile))\n    \n    print(f'Loading {str(s2_outfile)} as xarray object')\n    \ns2_cube =  xr.open_dataset(str(s2_outfile))\n\n# get geographic metadata \nx_utm = s2_cube['B02']['x']\ny_utm = s2_cube['B02']['y']\n# Pixel size\ndx = float((x_utm[1] -x_utm[0]))\ndy = float((y_utm[1] - y_utm[0]))\n\n# Top-left corner \nx_min = float(s2_cube['x'].min())\ny_max = float(s2_cube['y'].max())\n#geotransform\ngt = (x_min, dx, 0.0, y_max, 0.0, dy)\n# projection\nprj =  s2_cube.crs.spatial_ref\n\n\nprint(f'Extracting {S2_BANDS} as 3D array cube')\n# These are the Sentinel 2 bands to use RTM inversion\ns2_xarray = s2_cube[S2_BANDS].to_array(dim=\"band\").rio.write_crs(rasterio.crs.CRS.from_string(prj).to_string())\ns2_ar = s2_xarray.values/10000\n# get metadata and store in dictionary\nmeta_dict = {}\nfor var in s2_meta_bands:\n    print(f'Extracting {var} as array')\n    var_ar = s2_cube[[var]].to_array(dim=\"band\").values[0]\n    meta_dict[var] = var_ar\n    \n\n\n\n","type":"content","url":"/biophysical-traits-rtm#pre-process-sentinel-2-image","position":43},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl2":"Build database based on geometric conditions"},"type":"lvl2","url":"/biophysical-traits-rtm#build-database-based-on-geometric-conditions","position":44},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl2":"Build database based on geometric conditions"},"content":"Now, we will train the model based the actual geometric and atmospheric conditions during the Sentinel-2 overpass. For this, we will again build the LUT using PROSAIL and the metadata provided in the Sentinel-2 images.\n\n# get sun/viewing angles\nsza = np.nanmean(meta_dict['sunZenithAngles'])\nsaa = np.nanmean(meta_dict['sunAzimuthAngles'])\nvza = np.nanmean(meta_dict['viewZenithMean'])\n# get aerosol optical thickness and water vapour\naot = np.nanmean(meta_dict['AOT'])/1000\nwvp = np.nanmean(meta_dict['WVP'])/1000\n\ndate_obj = dt.datetime(2024, 4, 16, 10, 30)\n\nprint(\"Running 6S for estimation of diffuse/direct irradiance\")\nskyl = get_diffuse_radiation_6S(aot, wvp, sza, saa, date_obj,\n                                altitude=0.1)\n\nprint(f\"Building {np.size(params_orig['bs'])} PROSPECTD+4SAIL simulations\")\nsoil_spectrum = build_soil_database(params_orig[\"bs\"])\n\n# spectral range\nwls_sim = np.arange(400, 2501)\n\n# number of CPUs to use to perform simulations\nnjobs = 4\n# generate LUT\nrho_canopy_vec, params = inv.simulate_prosail_lut_parallel(\n        njobs,\n        params_orig,\n        wls_sim,\n        soil_spectrum,\n        skyl=skyl,\n        sza=sza,\n        vza=vza,\n        psi=0,\n        srf=srf,\n        outfile=lut_outfile,\n        calc_FAPAR=False,\n        reduce_4sail=True)\nprint('Done!')\n\n","type":"content","url":"/biophysical-traits-rtm#build-database-based-on-geometric-conditions","position":45},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl2":"Train RF model"},"type":"lvl2","url":"/biophysical-traits-rtm#train-rf-model","position":46},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl2":"Train RF model"},"content":"As before, we will now train the RF algorithm based on the simulated LUT.\n\nprint(f\"Training Random forest for {','.join(OBJ_PARAM_NAMES)}\")\ninput_scalers = {}\noutput_scalers = {}\nregs = {}\nfor i, param in enumerate(OBJ_PARAM_NAMES):\n    reg, input_gauss_scaler, output_gauss_scaler, _ = \\\n        inv.train_reg(rho_canopy_vec, params[param].reshape(-1, 1),\n                      scaling_input=\"normalize\", scaling_output=\"normalize\",\n                      regressor_opts=scikit_regressor_opts,\n                      reg_method=\"random_forest\")\n\n    input_scalers[param] = input_gauss_scaler\n    output_scalers[param] = output_gauss_scaler\n    regs[param] = reg\n\nprint('Done!')\n\n","type":"content","url":"/biophysical-traits-rtm#train-rf-model","position":47},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl2":"Apply model on S2"},"type":"lvl2","url":"/biophysical-traits-rtm#apply-model-on-s2","position":48},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl2":"Apply model on S2"},"content":"Now, let us apply the trained RF model on the Sentinel-2 imagery\n\n# get 2D dimensions of array\ndims = s2_ar[0,:,:].shape\n\n# only select vegetation/soil pixels\nvalid = np.logical_or(meta_dict['SCL'] == 4, meta_dict['SCL'] == 5)\nvalid = np.ravel(valid)\nimage_array = s2_ar.reshape((s2_ar.shape[0], -1)).T\nimage_array = image_array[valid]\nbio_dict = {}\nfor i, param in enumerate(OBJ_PARAM_NAMES):\n    output = np.full(valid.size, np.nan)\n    print(f\"Appliying {param} model to S2 image reflectance array\")\n    if np.any(valid):\n        output[valid] = output_scalers[param].inverse_transform(\n            regs[param].predict(input_scalers[param].transform(\n                image_array)).reshape(-1, 1)).reshape(-1)\n    \n    output = output.reshape(dims)\n    \n    if param == 'fAPAR' or param == 'fIPAR':\n        min_value = 0\n        max_value = 1\n    else:\n        min_value = inv.prosail_bounds[param][0]\n        max_value = inv.prosail_bounds[param][1]\n    \n    output = np.clip(output, min_value, max_value)\n    # save to dictionary\n    bio_dict[param] = output\n    output_name = f\"S2_{param}_{date.strftime('%Y%m%d')}.tif\"\n    output_file = s2_dir / output_name\n    print(f\"Saving {param} in {output_file}\\n\")\n    gu.save_image(output, gt, prj, output_file)\n    \n    del output\n\nprint('Done!')\n\n","type":"content","url":"/biophysical-traits-rtm#apply-model-on-s2","position":49},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl2":"Visualize retrieved biophysical outputs"},"type":"lvl2","url":"/biophysical-traits-rtm#visualize-retrieved-biophysical-outputs","position":50},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl2":"Visualize retrieved biophysical outputs"},"content":"Note\n\nYou can also visualize the retrieved biophysical products in QGIS. The rasters should be saved in “./dataset/sentinel_imagery”\n\n# get extent [minx, maxx, miny, maxy] of scene\nte = [float(s2_cube['x'].min()), float(s2_cube['x'].max()), float(s2_cube['y'].min()), float(s2_cube['y'].max())]\n\n# visualizing outputs \nvariables = ['LAI', 'Cab', 'Cw']\n\nfig, axes = plt.subplots(1,3, figsize=(12, 6))\nfor i,var in enumerate(variables):\n    name, unit, _ = PARAM_PROPS[var]\n    range_lim = prosail_bounds[var]\n    \n    if var == 'LAI':\n        cmap = 'YlGn'\n    elif var == 'Cab':\n        cmap = 'PiYG'\n    else:\n        cmap = 'BrBG'\n    \n    # entire ROI\n    ax = axes[i]\n    ar = bio_dict[var]\n    \n    im = ax.imshow(ar, vmin=range_lim[0], vmax=range_lim[1], cmap=cmap, extent = te)\n    ax.set_title(f'{name}', fontsize=14)\n    # Add colorbar \n    cbar = fig.colorbar(im, ax=ax, shrink=0.95, orientation='horizontal')\n    cbar.set_label(f'{var} ({unit})', fontsize=12)  # Add title to colorbar\n\nplt.tight_layout()\nplt.show()\n\n","type":"content","url":"/biophysical-traits-rtm#visualize-retrieved-biophysical-outputs","position":51},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl2":"Conclusions"},"type":"lvl2","url":"/biophysical-traits-rtm#conclusions","position":52},{"hierarchy":{"lvl1":"Estimating biophysical traits using RTM inversion","lvl2":"Conclusions"},"content":"Hybrid RTM approach is an effective method combining physically-based modeling with machine learning algotithms\n\nSince the calibration is performed with synthetic dataset, no in-situ data is required making it globally applicable\n\nWarning\n\nThe effectiveness of these methods also depend on the assumptions made in the PRO4SAIL model, which assumes a horizontally and vertically homogeneous turbid vegetation layer. These methods tend to work relatively well in structurally homogenous vegetation such as herbaceous crops/vegetation but uncertainties may be greater in complex agro-forestry systems which have more heterogeneous characteristics (e.g. clumping, multiple vegetation layers, senecent vegetation).\n\nNote\n\nPlease feel free comment any thoughts. This is work in progress!!!","type":"content","url":"/biophysical-traits-rtm#conclusions","position":53},{"hierarchy":{"lvl1":"TSEB in row crops"},"type":"lvl1","url":"/b01-row-crops","position":0},{"hierarchy":{"lvl1":"TSEB in row crops"},"content":"","type":"content","url":"/b01-row-crops","position":1},{"hierarchy":{"lvl1":"TSEB in row crops","lvl2":"Summary"},"type":"lvl2","url":"/b01-row-crops#summary","position":2},{"hierarchy":{"lvl1":"TSEB in row crops","lvl2":"Summary"},"content":"This interactive Jupyter Notebook has the objective of showing the implemenation of radiation transmission in row crops. It is based on \n\nParry et al. (2019)\n\nWe will make use of simulation models, particularly radiative transfer models at both leaf and canopy levels.\n\n","type":"content","url":"/b01-row-crops#summary","position":3},{"hierarchy":{"lvl1":"TSEB in row crops","lvl2":"Instructions"},"type":"lvl2","url":"/b01-row-crops#instructions","position":4},{"hierarchy":{"lvl1":"TSEB in row crops","lvl2":"Instructions"},"content":"Read carefully all the text and follow the instructions.\n\nOnce each section is read, run the jupyter code cell underneath (marked as In []) by clicking the icon Run, or pressing the keys SHIFT+ENTER of your keyboard. A graphical interface will then display, which allows you to interact with and perform the assigned tasks.\n\nTo start, please run the following cell to import all the packages required for this notebook. Once you run the cell below, an acknowledgement message, stating all libraries were correctly imported, should be printed on screen.\n\n%matplotlib inline\nfrom pathlib import Path\nfrom ipywidgets import interact, interactive, fixed, widgets\nfrom IPython.display import display\nfrom functions import radiation_and_available_energy as fn\nimport numpy as np\n\n","type":"content","url":"/b01-row-crops#instructions","position":5},{"hierarchy":{"lvl1":"TSEB in row crops","lvl2":"Shortwave radiation in row crops"},"type":"lvl2","url":"/b01-row-crops#shortwave-radiation-in-row-crops","position":6},{"hierarchy":{"lvl1":"TSEB in row crops","lvl2":"Shortwave radiation in row crops"},"content":"So far, all simulations and processes have assumed a horizontally homogeneous canopy or crop, or at least dense enough to approximate a homogeneous crop. However, what happens when one is working with row crops or isolated canopies, such as in vineyards or orchards?\n\nThe hard fact is that everything is much more complex as on the one hand the canopy is usually clumped around a stem and branches, leaving some parts of the ground fully exposed. On the other hand, in row crops, the dimension of the canopy/trellis system and the orientation of the rows also affect how light is intercepted and transmitted between the crop and the ground.\n\nIn order to evaluate this situation, we need to consider additional parameters of crop structure:\n\nThe canopy height (h_c), since higher canopies will cast longer shadows in the interrow.\n\nThe fraction of canopy occupied by the ground (f_c), or the ratio between the canopy/trellis width (w_c) and the row spacing (L).\n\nThe azimuth row orientation, with respect to the north. 0º will indicate that the rows are oriented S-N, negative values indicate that the rows go from NW to SE, and positive values from NE to SW, with -90º and/or 90º showing rows oriented E-W.\n\n\n\nFigure 1:Canopy model for estimating the clumping index in row crops, F is the leaf area index, L is the distance between rows, hc is the canopy height, hb is the height of the canopy above ground, and wc is the canopy width\n\nThe approach builds upon the concept of the clumping index, defined as a conversion factor that modifies the leaf area index of a real canopy (F) in a fictitious homogeneous canopy with LAI_{eff} = \\Omega\\left(\\theta, \\psi\\right) F, such as its gap fraction (G\\left(\\theta, \\psi\\right)) is the same as the gap fraction of the real-world canopy:\\Omega\\left(\\theta,\\psi\\right) F \\kappa_b\\left(\\theta\\right)= -\\log\\left[G\\left(\\theta,\\psi\\right)\\right]\n\nwith \\kappa_b\\left(\\theta\\right) is the beam extinction cofficient computed for a homogenous canopy (e.g. using \n\nCampbell & Norman (1998).\n\nThe real canopy gap fraction is estimated on this simplied model as the sunlit part of the bare soil that is not shaded by the canopy (1 - f_{sc}) plus the gaps caused by the solar beam passing through the crop canopy (ignoring mutual shadowing between rows:G(\\theta ,\\psi)={f_{sc}}(\\theta ,\\psi )\\exp [ - {\\kappa _{{\\text{b}}}}(\\theta )F]+[1 - {f_{{\\text{sc}}}}(\\theta ,\\phi )].\n\nand f_{sc} is computed from (#row-crop-model) using trigonometry:{f_{{\\text{sc}}}}(\\theta ,\\phi )=\\frac{{{w_{\\text{c}}}+({h_{\\text{c}}} - {h_{\\text{b}}})\\tan \\theta |\\sin \\phi |}}{L}\n\nIn the following interactive plot, we have added these parameters to see their effect on net radiation. In addition, to ease the comparison with previous plot, we have included a second graph that shows the fraction of absorbed radiation for both a horizontally homogeneous crop and a row crop.\n\nw_sn = interactive(fn.plot_net_solar_radiation,\n                   lai=fn.w_lai, leaf_angle=fn.w_leaf_angle, h_c=fn.w_hc, f_c=fn.w_fc,\n                   row_distance=fn.w_interrow, row_direction=fn.w_psi, sdn_day=fn.w_sdn, skyl=fn.w_skyl, \n                   fvis=fixed(0.55), lat=fn.w_lat, cab=fn.w_cab, cw=fn.w_cw, soil_type=fn.w_soil)\ndisplay(w_sn)\n\nThe sun rises from the eastern side, at noon reaches its zenith towards the north (or south depending on whether we are north or south of the equator), and sunset is from the western side. Taking into account these facts, observe the effect of changing the row orientation from E-W to S-N. There should be a drop in canopy net radiation when the sun is parallel to the rows, as in this case there should be lower radiation interception by the canopy.\n\nObserve that with larger canopy fractions (f_c, or wider canopies relative to the row spacing), the crop behaves similarly to the homogeneous crops from the previous simulation.\n\nThere is an interaction effect between canopy height and row separation (L). Narrower rows in lower crops display a similar effect as that of taller crops in wider rows.\n\nFinally, as we have seen in previous interactive plots, these effects are minimized at larger proportion of diffuse radiation.\n\nSee Also\n\nCheck the code in the \n\npyTSEB GitHub repository.\n\n","type":"content","url":"/b01-row-crops#shortwave-radiation-in-row-crops","position":7},{"hierarchy":{"lvl1":"TSEB in row crops","lvl2":"Implementation with actual data in pyTSEB"},"type":"lvl2","url":"/b01-row-crops#implementation-with-actual-data-in-pytseb","position":8},{"hierarchy":{"lvl1":"TSEB in row crops","lvl2":"Implementation with actual data in pyTSEB"},"content":"We will work some of the sites of GRAPEX. There are a few sites with measurements of below canopy radiation that could be used to evaluate the model. In this case we can work with the sites in Sierra Loma and Barrelli, with different row orientations and canopy sctructure.\n\nSite characteristics\n\nSite\n\nLatitude\n\nLongitude\n\nElevation (m)\n\nRow direction (deg.)\n\nRow spacing (m)\n\nMin. height (m)\n\nMax. height (m)\n\nMin. width (m)\n\nMax. width (m)\n\nTA height (m)\n\nWS height (m)\n\nBarrelli_007\n\n38.753\n\n-122.98\n\n113\n\n135\n\n3.35\n\n1.25\n\n2.3\n\n0.5\n\n1.8\n\n4\n\n4\n\nBarrelli_012\n\n38.751369\n\n-122.974658\n\n112\n\n45\n\n3.35\n\n1.25\n\n2.3\n\n0.5\n\n1.8\n\n4.4\n\n4.4\n\nSierra Loma-north\n\n38.289338\n\n-121.117764\n\n38\n\n90\n\n3.35\n\n0.5\n\n1.42\n\n0.8\n\n2.6\n\n5\n\n5\n\nSierra Loma-south\n\n38.280488\n\n-121.117597\n\n37\n\n90\n\n3.35\n\n0.5\n\n1.42\n\n0.8\n\n2\n\n5\n\n5\n\nThe input we will use can be found in \n\n for the micrometeorological data and in \n\n for the below canopy radiation measurements.\n\nOn the other hand, LAI was obtained from Earth Observation data \n\nKang et al., 2022\n\n","type":"content","url":"/b01-row-crops#implementation-with-actual-data-in-pytseb","position":9},{"hierarchy":{"lvl1":"TSEB in row crops","lvl3":"Select a site","lvl2":"Implementation with actual data in pyTSEB"},"type":"lvl3","url":"/b01-row-crops#select-a-site","position":10},{"hierarchy":{"lvl1":"TSEB in row crops","lvl3":"Select a site","lvl2":"Implementation with actual data in pyTSEB"},"content":"\n\nw_site = widgets.Dropdown(\n    options=[('Sierra Loma N', \"slmN\"), ('Sierra Loma S', \"slmS\"), ('Barrelli_007', \"bar007\"), ('Barrelli_012', \"bar012\")],\n    value=\"slmN\",\n    description='Site:',\n)\ndisplay(w_site)\n\n","type":"content","url":"/b01-row-crops#select-a-site","position":11},{"hierarchy":{"lvl1":"TSEB in row crops","lvl3":"Read the radiation and LAI timeseries","lvl2":"Implementation with actual data in pyTSEB"},"type":"lvl3","url":"/b01-row-crops#read-the-radiation-and-lai-timeseries","position":12},{"hierarchy":{"lvl1":"TSEB in row crops","lvl3":"Read the radiation and LAI timeseries","lvl2":"Implementation with actual data in pyTSEB"},"content":"\n\n# Import Python libraries\nfrom pathlib import Path\nimport pandas as pd\n\n# Set the LAI and readiation folders\ninput_dir = Path().absolute() / \"input\"\nlai_dir = input_dir / \"canopy\"\nrad_dir = input_dir / \"radiation\"\n# Set the input files based on the chosen site\nlai_filename = lai_dir / f\"FLX_US-{w_site.value}_FLUXNET2015_AUXCANOPY_DD.csv\"\nrad_filename = rad_dir / f\"FLX_US-{w_site.value}_FLUXNET2015_AUXRADIATION_HH.csv\"\nprint(f\"LAI file path is {lai_filename}\")\nprint(f\"Radiation file path is {rad_filename}\")\n\n# Read the LAI and radiation tables\nlai = pd.read_csv(lai_filename, sep=\";\", na_values=-9999)\nrad = pd.read_csv(rad_filename, sep=\";\", na_values=-9999)\n\n# Merge both tables by date\nrad[\"TIMESTAMP\"] = pd.to_datetime(rad[\"TIMESTAMP\"], format=\"%Y%m%d%H%M\")\nlai[\"DATE\"] = pd.to_datetime(lai[\"TIMESTAMP\"], format=\"%Y%m%d\").dt.date\nlai = lai.drop(labels=[\"TIMESTAMP\"], axis=1)\nrad[\"DATE\"] = rad[\"TIMESTAMP\"].dt.date\nrad = rad.merge(lai, on=\"DATE\")\n\n# We discard all cases at night (SW_IN <=0)\nrad = rad[rad[\"SW_IN\"] > 0]\n\n\n","type":"content","url":"/b01-row-crops#read-the-radiation-and-lai-timeseries","position":13},{"hierarchy":{"lvl1":"TSEB in row crops","lvl4":"Plot the input variables","lvl3":"Read the radiation and LAI timeseries","lvl2":"Implementation with actual data in pyTSEB"},"type":"lvl4","url":"/b01-row-crops#plot-the-input-variables","position":14},{"hierarchy":{"lvl1":"TSEB in row crops","lvl4":"Plot the input variables","lvl3":"Read the radiation and LAI timeseries","lvl2":"Implementation with actual data in pyTSEB"},"content":"\n\nfrom plotly.subplots import make_subplots\nimport plotly.graph_objects as go\nfig = make_subplots(specs=[[{\"secondary_y\": True}]])\n\nfig.add_trace(go.Scatter(x=rad[\"TIMESTAMP\"], y=rad[\"LAI\"], \n                         name=\"LAI\", \n                         mode=\"lines\", line={\"color\":\"green\"}),\n              secondary_y=True)\n\nfig.add_trace(go.Scatter(x=rad[\"TIMESTAMP\"], y=rad[\"SW_IN\"], \n                         name=\"Incoming shortwave irradiance\",\n                         mode=\"lines\",line={\"color\":\"black\"})\n             )\n\nfig.add_trace(go.Scatter(x=rad[\"TIMESTAMP\"], y=rad[\"SW_BELOW\"],\n                         name=\"Below-canopy shortwave irradiance\", \n                         mode=\"lines\", line={\"color\":\"blue\"})\n             )\n\nfig.update_layout(title_text=f\"Radiation measurements at {w_site.label}\",\n                 hovermode=\"x\")\n\n","type":"content","url":"/b01-row-crops#plot-the-input-variables","position":15},{"hierarchy":{"lvl1":"TSEB in row crops","lvl3":"Get the canopy a priori structural properties","lvl2":"Implementation with actual data in pyTSEB"},"type":"lvl3","url":"/b01-row-crops#get-the-canopy-a-priori-structural-properties","position":16},{"hierarchy":{"lvl1":"TSEB in row crops","lvl3":"Get the canopy a priori structural properties","lvl2":"Implementation with actual data in pyTSEB"},"content":"\n\nimport yaml\nyaml_file = input_dir / \"site_description.yaml\"\nsite_dict = yaml.safe_load(yaml_file.read_text())\nlat = float(site_dict[\"lat\"][w_site.value])\nlon = float(site_dict[\"lon\"][w_site.value])\nelev = float(site_dict[\"elev\"][w_site.value])\nrow_direction = float(site_dict[\"row_direction\"][w_site.value])\ninterrow = float(site_dict[\"interrow\"][w_site.value])\nhc_min = float(site_dict[\"hc_min\"][w_site.value])\nhc_max = float(site_dict[\"hc_max\"][w_site.value])\nwc_min = float(site_dict[\"wc_min\"][w_site.value])\nwc_max = float(site_dict[\"wc_max\"][w_site.value])\nzh = float(site_dict[\"zh\"][w_site.value])\nzm = float(site_dict[\"zm\"][w_site.value])\n\nprint(f\"{w_site.label} has the following site characteristics:\\n\"\n      f\"\\t Latitude: {lat} deg. \\n\"\n      f\"\\t Longitude: {lon} deg. \\n\"\n      f\"\\t Elevation: {elev} m \\n\"\n      f\"\\t Row direction: {row_direction} deg. \\n\"\n      f\"\\t Row spacing: {interrow} m \\n\"\n      f\"\\t Min. canopy height: {hc_min} m \\n\"\n      f\"\\t Max. canopy height: {hc_max} m \\n\"\n      f\"\\t Min. canopy width: {wc_min} m \\n\"\n      f\"\\t Max. canopy width: {wc_max} m \\n\"\n)\n\n","type":"content","url":"/b01-row-crops#get-the-canopy-a-priori-structural-properties","position":17},{"hierarchy":{"lvl1":"TSEB in row crops","lvl3":"Estimate the structural variables based on Earth Observation LAI timeseries","lvl2":"Implementation with actual data in pyTSEB"},"type":"lvl3","url":"/b01-row-crops#estimate-the-structural-variables-based-on-earth-observation-lai-timeseries","position":18},{"hierarchy":{"lvl1":"TSEB in row crops","lvl3":"Estimate the structural variables based on Earth Observation LAI timeseries","lvl2":"Implementation with actual data in pyTSEB"},"content":"we will estimate timeseries of canopy structural variables based on LAI and empirical observations of trellis development. These relationships were obtained for Sierra Loma \n\nNieto et al., 2018 so they might be less robust in other sites\n\n\n\nFigure 2:Empirical models relating canopy height , canopy width and the bottom of the canopy with the fused STARFM LAI. Solid dots represent in situ measured values\n\nThese empirical equations are coded in Python as:\n\nimport numpy as np\n\n################################################################################\n# Empirical equations to generate canopy structural parameters from LAI\n################################################################################\ndef lai_2_hc(lai, hc_min):\n    slope = 0.42\n    hc = hc_min + slope * lai\n    return hc\n\n\ndef lai_2_hbratio(lai, hc_min):\n    hb_ratio_mean = 0.4848388065\n    hb_ratio = np.zeros(lai.shape)\n\n    hb_ratio[lai < hc_min] = 1. + ((hb_ratio_mean - 1.) / hc_min) * lai[\n        lai < hc_min]\n    hb_ratio[lai >= hc_min] = hb_ratio_mean\n\n    return hb_ratio\n\n\ndef lai_2_width(lai, wc_min, wc_max):\n    beta = 6.96560056\n    offset = 1.70825736\n\n    width = wc_min + (wc_max - wc_min) / (1.0 + np.exp(-beta * (lai - offset)))\n\n    return width\n\n\ndef lai_2_fcover(lai, fc_min, fc_max):\n    beta = 7.0\n    offset = 1.70\n\n    fcover = fc_min + (fc_max - fc_min) / (1.0 + np.exp(-beta * (lai - offset)))\n\n    return fcover\n\n\ndef lai_2_canopy(lai, hc_min, fc_min, fc_max):\n    hc = lai_2_hc(lai, hc_min)\n    hb_ratio = lai_2_hbratio(lai, hc_min)\n    fcover = lai_2_fcover(lai, fc_min, fc_max)\n\n    return hc, hb_ratio, fcover\n\nFrom these empirical functions together with the site description properties described in \n\nSite Description we can caluculate the time series of canopy structural variables needed to compute the shadowing as shown in \n\nFigure 1\n\nNote\n\nThese equations are site specific and most likely not applicable to other sites and crops. For operational purposes, such as using Earth Observation/satellite data a trade-off must be made between accuracy and applicability.\n\n# Compute the expected minimum and maximum canopy cover based on mininum and maximum canopy width\nfc_min = wc_min / interrow\nfc_max = wc_max / interrow\nh_c, hb_ratio, f_c = lai_2_canopy(rad[\"LAI\"].values,\n                                  hc_min,\n                                  fc_min,\n                                  fc_max)\n\n# Ensure that both canopy height and cover are within the limits\nh_c = np.clip(h_c, hc_min, hc_max)\nf_c = np.clip(f_c, 0, 1)\n\n","type":"content","url":"/b01-row-crops#estimate-the-structural-variables-based-on-earth-observation-lai-timeseries","position":19},{"hierarchy":{"lvl1":"TSEB in row crops","lvl3":"We can define the spectral properties of our leaves and soil","lvl2":"Implementation with actual data in pyTSEB"},"type":"lvl3","url":"/b01-row-crops#we-can-define-the-spectral-properties-of-our-leaves-and-soil","position":20},{"hierarchy":{"lvl1":"TSEB in row crops","lvl3":"We can define the spectral properties of our leaves and soil","lvl2":"Implementation with actual data in pyTSEB"},"content":"\n\nstyle = {'description_width': 'initial'}\nw_rho_leaf_vis = widgets.BoundedFloatText(min=0, max=1, value=0.05, description='Leaf PAR reflectance', step=0.01, style=style)\nw_rho_leaf_nir = widgets.BoundedFloatText(min=0, max=1, value=0.35, description='Leaf NIR reflectance', step=0.01, style=style)\nw_tau_leaf_vis = widgets.BoundedFloatText(min=0, max=1, value=0.05, description='Leaf PAR transmittance', step=0.01, style=style)\nw_tau_leaf_nir = widgets.BoundedFloatText(min=0, max=1, value=0.35, description='Leaf NIR transmittance', step=0.01, style=style)\nw_rho_soil_vis = widgets.BoundedFloatText(min=0, max=1, value=0.15, description='Soil PAR reflectance', step=0.01, style=style)\nw_rho_soil_nir = widgets.BoundedFloatText(min=0, max=1, value=0.25, description='Soil NIR reflectance', step=0.01, style=style)\ndisplay(w_rho_leaf_vis, w_rho_leaf_nir, w_tau_leaf_vis, w_tau_leaf_nir, w_rho_soil_vis, w_rho_soil_nir)\n\n","type":"content","url":"/b01-row-crops#we-can-define-the-spectral-properties-of-our-leaves-and-soil","position":21},{"hierarchy":{"lvl1":"TSEB in row crops","lvl3":"Now parse the spectral propoerties and also compute illumination angles","lvl2":"Implementation with actual data in pyTSEB"},"type":"lvl3","url":"/b01-row-crops#now-parse-the-spectral-propoerties-and-also-compute-illumination-angles","position":22},{"hierarchy":{"lvl1":"TSEB in row crops","lvl3":"Now parse the spectral propoerties and also compute illumination angles","lvl2":"Implementation with actual data in pyTSEB"},"content":"\n\nfrom pyTSEB import TSEB\n\n# We can get the leaf and soil spectral from the values above, or hard code the corresponding values\nrho_leaf_vis = w_rho_leaf_vis.value\nrho_leaf_nir = w_rho_leaf_nir.value\ntau_leaf_vis = w_tau_leaf_vis.value\ntau_leaf_nir = w_tau_leaf_nir.value\nrho_soil_vis = w_rho_soil_vis.value\nrho_soil_nir = w_rho_soil_nir.value\n\n# We also need to compute the solar angles\n# The time zone is PST, which corresponds to -120 deg, time longitude\nstdlon = -120\n# Call calc_sun_angles based on site coordinates and timestamp\nsza, saa = TSEB.met.calc_sun_angles(\n    np.full_like(rad['LAI'].values, lat),\n    np.full_like(rad[\"LAI\"].values, lon),\n    np.full_like(rad[\"LAI\"].values, stdlon),\n    rad['TIMESTAMP'].dt.dayofyear.values,\n    rad['TIMESTAMP'].dt.hour.values + rad['TIMESTAMP'].dt.minute.values / 60.)\n\n\n","type":"content","url":"/b01-row-crops#now-parse-the-spectral-propoerties-and-also-compute-illumination-angles","position":23},{"hierarchy":{"lvl1":"TSEB in row crops","lvl3":"We compute the clumping index and effective LAI for row crops","lvl2":"Implementation with actual data in pyTSEB"},"type":"lvl3","url":"/b01-row-crops#we-compute-the-clumping-index-and-effective-lai-for-row-crops","position":24},{"hierarchy":{"lvl1":"TSEB in row crops","lvl3":"We compute the clumping index and effective LAI for row crops","lvl2":"Implementation with actual data in pyTSEB"},"content":"\n\n# canopy width\nw_c = f_c * interrow\n# Canopy width to height ratio\nw_c_ratio = w_c / (h_c - hb_ratio * h_c)\n# Local LAI\nF = rad[\"LAI\"].values / f_c\n\n# Compute the relative sun-row azimuth angle\npsi = row_direction - saa\n# Compute the clumping index for row crops\n# Calculate the zenith angle of incidence towards the normal of the row direction\ntan_alpha_x = np.tan(np.radians(sza)) * abs(np.sin(np.radians(psi)))\n# Calculate the fraction that is transmitted trough vegetation\nf_sc = np.asarray(f_c * (1.0 + (tan_alpha_x / w_c)))\nf_sc = np.minimum(f_sc, 1.0)\n# Estimate the beam extinction coefficient based on a elipsoidal LAD function\n# Eq. 15.4 of Campbell and Norman (1998)\nk_be = TSEB.rad.calc_K_be_Campbell(sza, x_lad=1)\n# Calculate the real gap fraction of our canopy\ntrans = f_sc * np.exp(-k_be * F) + (1.0 - f_sc)\n# and then the clumping factor\nomega = np.zeros(F.shape)\nomega[trans > 0] = -np.log(trans[trans > 0]) / (F[trans > 0] * k_be[trans > 0])\n# And the effective LAI is the product of local LAI and the clumping index\nlai_eff = F * omega\n\n","type":"content","url":"/b01-row-crops#we-compute-the-clumping-index-and-effective-lai-for-row-crops","position":25},{"hierarchy":{"lvl1":"TSEB in row crops","lvl3":"We can run get the shortwave radiation below canopy using Campbell & Norman (1998)","lvl2":"Implementation with actual data in pyTSEB"},"type":"lvl3","url":"/b01-row-crops#we-can-run-get-the-shortwave-radiation-below-canopy-using","position":26},{"hierarchy":{"lvl1":"TSEB in row crops","lvl3":"We can run get the shortwave radiation below canopy using Campbell & Norman (1998)","lvl2":"Implementation with actual data in pyTSEB"},"content":"\n\n# Estimates the direct and diffuse solar radiation\ndifvis, difnir, fvis, fnir = TSEB.rad.calc_difuse_ratio(rad[\"SW_IN\"].values,\n                                                        sza,\n                                                        press=np.full_like(sza, 1013.15))\npar_dir = fvis * (1. - difvis) * rad[\"SW_IN\"].values\nnir_dir = fnir * (1. - difnir) * rad[\"SW_IN\"].values\npar_dif = fvis * difvis * rad[\"SW_IN\"].values\nnir_dif = fnir * difnir * rad[\"SW_IN\"].values\n\n# Compute the tramistted beam and diffuse radiation at both the PAR and NIR regions\n_, _, taubt, taudt = TSEB.rad.calc_spectra_Cambpell(\n                    rad[\"LAI\"].values,\n                    sza,\n                    np.array([np.full_like(sza, rho_leaf_vis), np.full_like(sza, rho_leaf_nir)]),\n                    np.array([np.full_like(sza, tau_leaf_vis), np.full_like(sza, tau_leaf_nir)]),\n                    np.array([np.full_like(sza, rho_soil_vis), np.full_like(sza, rho_soil_nir)]),\n                    lai_eff=lai_eff)\n\n# Compute the below canopy radiation as product of spectral tranmisttances and PAR and NIR irradiance\nsw_below = np.maximum(taubt[0] * par_dir + taubt[1] * nir_dir + taudt[0] * par_dif + taudt[1] * nir_dif, \n                      0)\n\n","type":"content","url":"/b01-row-crops#we-can-run-get-the-shortwave-radiation-below-canopy-using","position":27},{"hierarchy":{"lvl1":"TSEB in row crops","lvl3":"We now estimate the radiation below canopy using the original clumplend and non-clumped formulation","lvl2":"Implementation with actual data in pyTSEB"},"type":"lvl3","url":"/b01-row-crops#we-now-estimate-the-radiation-below-canopy-using-the-original-clumplend-and-non-clumped-formulation","position":28},{"hierarchy":{"lvl1":"TSEB in row crops","lvl3":"We now estimate the radiation below canopy using the original clumplend and non-clumped formulation","lvl2":"Implementation with actual data in pyTSEB"},"content":"\n\nomega_0 = TSEB.CI.calc_omega0_Kustas(rad[\"LAI\"].values, f_c, x_LAD=1, isLAIeff=True)\nomega = TSEB.CI.calc_omega_Kustas(omega_0, sza, w_C=w_c_ratio)\n# And the effective LAI is the product of local LAI and the clumping index\nlai_eff = F * omega\nalbb, albd, taubt, taudt = TSEB.rad.calc_spectra_Cambpell(\n                    rad[\"LAI\"].values,\n                    sza,\n                    np.array([np.full_like(sza, rho_leaf_vis), np.full_like(sza, rho_leaf_nir)]),\n                    np.array([np.full_like(sza, tau_leaf_vis), np.full_like(sza, tau_leaf_nir)]),\n                    np.array([np.full_like(sza, rho_soil_vis), np.full_like(sza, rho_soil_nir)]),\n                    lai_eff=lai_eff)\n\nsw_below_orig_clumped = np.maximum(taubt[0] * par_dir + taubt[1] * nir_dir + taudt[0] * par_dif + taudt[1] * nir_dif, \n                           0)\n\n# Homogeneous (non-clumped) vegetation\nalbb, albd, taubt, taudt = TSEB.rad.calc_spectra_Cambpell(\n                    rad[\"LAI\"].values,\n                    sza,\n                    np.array([np.full_like(sza, rho_leaf_vis), np.full_like(sza, rho_leaf_nir)]),\n                    np.array([np.full_like(sza, tau_leaf_vis), np.full_like(sza, tau_leaf_nir)]),\n                    np.array([np.full_like(sza, rho_soil_vis), np.full_like(sza, rho_soil_nir)]),\n                    lai_eff=rad[\"LAI\"].values)\n\nsw_below_orig = np.maximum(taubt[0] * par_dir + taubt[1] * nir_dir + taudt[0] * par_dif + taudt[1] * nir_dif, \n                           0)\n\n","type":"content","url":"/b01-row-crops#we-now-estimate-the-radiation-below-canopy-using-the-original-clumplend-and-non-clumped-formulation","position":29},{"hierarchy":{"lvl1":"TSEB in row crops","lvl3":"Finally we compare the different retrievals","lvl2":"Implementation with actual data in pyTSEB"},"type":"lvl3","url":"/b01-row-crops#finally-we-compare-the-different-retrievals","position":30},{"hierarchy":{"lvl1":"TSEB in row crops","lvl3":"Finally we compare the different retrievals","lvl2":"Implementation with actual data in pyTSEB"},"content":"\n\nfrom model_evaluation import double_collocation as dc\nfrom tabulate import tabulate\n\nfig = make_subplots(rows=1, cols=3,\n                    shared_yaxes=True,\n                    horizontal_spacing=0.01,\n                   subplot_titles=[\"Row clumped\", \"Original clumped\", \"Non-clumped\"])\n\n\nfig.add_trace(go.Scattergl(x=sw_below, y=rad[\"SW_BELOW\"], \n                         name=\"Clumpling index for row crops\", mode=\"markers\"),\n             row=1, col=1)\n\nfig.add_trace(go.Scattergl(x=sw_below_orig_clumped, y=rad[\"SW_BELOW\"], \n                         name=\"Original clumpling index\", mode=\"markers\"),\n             row=1, col=2)\n\nfig.add_trace(go.Scattergl(x=sw_below_orig, y=rad[\"SW_BELOW\"], \n                         name=\"Non clumped\", mode=\"markers\"),\n             row=1, col=3)\n\nfig.add_trace(go.Scatter(x=[0, 800], y=[0, 800], mode=\"lines\", name=\"1:1 line\", line={\"color\": \"black\", \"dash\": \"dash\"}),\n             row=1, col=1)\nfig.add_trace(go.Scatter(x=[0, 800], y=[0, 800], mode=\"lines\", name=\"1:1 line\", line={\"color\": \"black\", \"dash\": \"dash\"}),\n             row=1, col=2)\nfig.add_trace(go.Scatter(x=[0, 800], y=[0, 800], mode=\"lines\", name=\"1:1 line\", line={\"color\": \"black\", \"dash\": \"dash\"}),\n             row=1, col=3)\n\nfig.update_layout(title_text=f\"Observed vs. Estimated below canopy radiation at {w_site.label}\",\n                 hovermode=\"y\", yaxis_range=[0, 800], xaxis_range=[0, 800])\n\n\nmean_bias, mae, rmse = dc.error_metrics(rad[\"SW_BELOW\"].values, sw_below)\nmean_bias_orig_clumped, mae_orig_clumped, rmse_orig_clumped = dc.error_metrics(rad[\"SW_BELOW\"].values, sw_below_orig_clumped)\nmean_bias_orig, mae_orig, rmse_orig = dc.error_metrics(rad[\"SW_BELOW\"].values, sw_below_orig)\ncor, p_value, slope, intercept, d = dc.agreement_metrics(rad[\"SW_BELOW\"].values, sw_below)\ncor_orig_clumped, p_value_orig_clumped, slope_orig_clumped, intercept_orig_clumped, d_orig_clumped = dc.agreement_metrics(rad[\"SW_BELOW\"].values, sw_below_orig_clumped)\ncor_orig, p_value_orig, slope_orig, intercept_orig, d_orig = dc.agreement_metrics(rad[\"SW_BELOW\"].values, sw_below_orig)\n\ntable = [[\"bias\", mean_bias, mean_bias_orig_clumped,mean_bias_orig],\n         [\"RMSE\", rmse, rmse_orig_clumped, rmse_orig],\n         [\"MAE\",mae, mae_orig_clumped, mae_orig],\n         [\"Pearson\", cor, cor_orig_clumped, cor_orig],\n         [\"Willmot's d\", d, d_orig_clumped, d_orig]]\n\nprint(tabulate(table, headers=[\"Metric\", \"Row Crop\", \"Original CI\", \"Non clumped\"]))\n\n","type":"content","url":"/b01-row-crops#finally-we-compare-the-different-retrievals","position":31},{"hierarchy":{"lvl1":"TSEB in row crops","lvl3":"Save the results to an ASCII table","lvl2":"Implementation with actual data in pyTSEB"},"type":"lvl3","url":"/b01-row-crops#save-the-results-to-an-ascii-table","position":32},{"hierarchy":{"lvl1":"TSEB in row crops","lvl3":"Save the results to an ASCII table","lvl2":"Implementation with actual data in pyTSEB"},"content":"\n\n# Define the output filename\nout_dir = Path().absolute() / \"output\"\noutfile = out_dir / f\"FLX_US-{w_site.value}_FLUXNET2015_SW-BELOW_HR.csv\"\n\n# Create the output folder in case it does not exist\nif not out_dir.exists():\n    out_dir.mkdir(parents=True)\n\n# Convert the outputs to a Python dictionary\noutdict = {\"TIMESTAMP\": rad[\"TIMESTAMP\"].dt.strftime(\"%Y%m%d%H%M\"),\n           \"SW_BELOW_ROWS\": sw_below, \n           \"SW_BELOW_ORIG-CLUMPED\": sw_below_orig_clumped, \n           \"SW_BELOW_NON-CLUMPED\": sw_below_orig,}\n\n# Crete the output dataframe and save it to csv\npd.DataFrame(outdict).to_csv(outfile, sep=\";\", na_rep=-9999, index=False)\nprint(f\"Saved to {outfile}\")\n\n","type":"content","url":"/b01-row-crops#save-the-results-to-an-ascii-table","position":33},{"hierarchy":{"lvl1":"TSEB in row crops","lvl2":"Conclusions"},"type":"lvl2","url":"/b01-row-crops#conclusions","position":34},{"hierarchy":{"lvl1":"TSEB in row crops","lvl2":"Conclusions"},"content":"However several model model limitations can be discussed based on the assumptions made in this approach:\n\nleaves are small, negligible in size as compared to the canopy size.\n\nleaves absorb all incident radiation (i.e. no scattering or transmission) while computing the shadowing for the clumping index.\n\nCanopy resembles a prism\n\n[...]\n\nNote\n\nPlease feel free comment any thoughts. This is work in progress!!!","type":"content","url":"/b01-row-crops#conclusions","position":35},{"hierarchy":{"lvl1":"Shuttleworth-Wallace TSEB in advective conditions"},"type":"lvl1","url":"/b02-tseb-sw","position":0},{"hierarchy":{"lvl1":"Shuttleworth-Wallace TSEB in advective conditions"},"content":"","type":"content","url":"/b02-tseb-sw","position":1},{"hierarchy":{"lvl1":"Shuttleworth-Wallace TSEB in advective conditions","lvl2":"Summary"},"type":"lvl2","url":"/b02-tseb-sw#summary","position":2},{"hierarchy":{"lvl1":"Shuttleworth-Wallace TSEB in advective conditions","lvl2":"Summary"},"content":"This interactive Jupyter Notebook has the objective of showing the implemenation of TSEB-SW under advective conditions. It is based on \n\nKustas et al. (2022) and \n\nNieto et al. (2022).\n\n","type":"content","url":"/b02-tseb-sw#summary","position":3},{"hierarchy":{"lvl1":"Shuttleworth-Wallace TSEB in advective conditions","lvl2":"Instructions"},"type":"lvl2","url":"/b02-tseb-sw#instructions","position":4},{"hierarchy":{"lvl1":"Shuttleworth-Wallace TSEB in advective conditions","lvl2":"Instructions"},"content":"Read carefully all the text and follow the instructions.\n\nOnce each section is read, run the jupyter code cell underneath (marked as In []) by clicking the icon Run, or pressing the keys SHIFT+ENTER of your keyboard. A graphical interface will then display, which allows you to interact with and perform the assigned tasks.\n\nTo start, please run the following cell to import all the packages required for this notebook. Once you run the cell below, an acknowledgement message, stating all libraries were correctly imported, should be printed on screen.\n\n%matplotlib inline\nfrom pathlib import Path\nfrom ipywidgets import interact, interactive, fixed, widgets\nfrom IPython.display import display\nfrom functions import radiation_and_available_energy as fn\nimport numpy as np\n\n","type":"content","url":"/b02-tseb-sw#instructions","position":5},{"hierarchy":{"lvl1":"Shuttleworth-Wallace TSEB in advective conditions","lvl2":"Shuttleworth-Wallace model"},"type":"lvl2","url":"/b02-tseb-sw#shuttleworth-wallace-model","position":6},{"hierarchy":{"lvl1":"Shuttleworth-Wallace TSEB in advective conditions","lvl2":"Shuttleworth-Wallace model"},"content":"The two-source Shuttleworth-Wallace energy combination model \n\nShuttleworth & Wallace, 1985 was specifically designed to account for evapotranspiration partitioning in sparse crops. Therefore, both the heat and water fluxes are separated into a soil and canopy layer, with a series of resistances set in series).\n\n\n\nTwo-Source energy balance scheme including the transport of both heat (H) and water vapour (\\lambda E). Adapted from \n\nShuttleworth & Wallace (1985).\n\nEnergy fluxes are therefore split into soil and canopy, considering the conservation of energy:R_{n} & \\approx H + \\lambda E + G\\\\\n  R_{n,S} & \\approx H_{S} + \\lambda E_{S} + G\\\\\n  R_{n,C} & \\approx H_{C} + \\lambda E_{C}\n\nwith R_n being the net radiation, H the sensible heat flux, \\lambda E the latent heat flux or evapotranspiration, and G the soil heat flux (all fluxes are expressed in W m^{-2}. The approximation in Eq. \\ref{eq:Energy_Balance} reflects additional components of the energy balance that are usually neglected, such as heat advection, storage of energy in the canopy layer or energy for the fixation of CO_2 \\citep{Hillel1998, Baldocchi1991}, which are not computed by the model.\n\nCanopy latent heat flux (or transpiration) is computed as \\lambda E_C = \\frac{\\Delta R_{n.C} + \\rho_a c_p \\frac{VPD_0}{R_x}}{\\Delta + \\gamma  \\left(1 + \\frac{R_c}{R_x}\\right)}\n\nwhere \\rho_a is the air density; c_p the heat capacity of air, VPD_0 is the air vapour pressure deficit at the canopy-air interface; R_x is the canopy boundary resistance to momentum, heat and vapour transport; and R_c is related to the leaf stomatal conductance g_{s} as we will see later in section \n\nSensitivity of stomatal conductance to vapour pressure deficit\n\nThe vapor pressure deficit at the canopy-air interface (VPD_0) is computed as VPD_0 = VPD + R_a \\frac{\\Delta \\left(R_n - G\\right) - \\left(\\Delta + \\gamma\\right) \\lambda E} {\\rho_a c_p}\n\nwhere VPD is the measured atmospheric vapour pressure deficit, R_a is the aerodynamic resistance to turbulent transport, R_n is the surface net radiation, G is the soil heat flux, and \\lambda E is the surface bulk (soil + canopy) latent heat flux, estimated as:\\lambda E = C_c PM_C + C_s PM_S\n\nPM_C and PM_S are the estimates of an infinite deep canopy and bare soil latent heat fluxes, respectively using the Penman-Monteith equation:  PM_C & = \\frac{\\Delta  \\left(R_n - G\\right) + \\frac{\\rho_a c_p VPD - \\Delta  R_x \\left(R_{n,S} - G\\right)}{\n      R_a + R_x}}{\\Delta + \\gamma \\left(1 + \\frac{R_c}{R_a + R_x}\\right)}\\\\\n  PM_S & = \\frac{\\Delta  \\left(R_n - G\\right) + \\frac{\\rho_a c_p VPD - \\Delta R_s R_{n,C}}{R_a + R_s}}{\\Delta + \\gamma \\left(1 + \\frac{R_{ss}} {R_a + R_s}\\right)}\n\nwhere R_s is the soil boundary layer resistance to turbulent transport and R_{ss} is the near-surface soil resistance to vapour transport. The latter is set to a fixed value of R_{ss}=2000 s m^{-1} considering a rather dry soil surface, in order to be consistent with the definition of potential ET adopted with the Penman-Monteith approach.\n\nSee Also\n\nThe full code for the Shuttleworth and Wallace model is at the \n\npyTSEB GitHub repository\n\n","type":"content","url":"/b02-tseb-sw#shuttleworth-wallace-model","position":7},{"hierarchy":{"lvl1":"Shuttleworth-Wallace TSEB in advective conditions","lvl3":"Sensitivity of stomatal conductance to vapour pressure deficit","lvl2":"Shuttleworth-Wallace model"},"type":"lvl3","url":"/b02-tseb-sw#gs-header","position":8},{"hierarchy":{"lvl1":"Shuttleworth-Wallace TSEB in advective conditions","lvl3":"Sensitivity of stomatal conductance to vapour pressure deficit","lvl2":"Shuttleworth-Wallace model"},"content":"Kustas et al. (2022) showed the advantages of accounting for the sensitivity of stomatal closure at higher VPD in canopies highly coupled with the atmosphere \n\nJarvis & McNaughton, 1986.\n\nWe are going to evaluate the sensitivity of leaf stomata to VPD using estimates of transpiration derived from the Eddy Covariance. This approach is based on the method proposed by \n\nMONTEITH (1995)\n\nThe canopy stomatal resistance (R_c), dependent of VPD variations, is then computed as.R_c = \\frac{1}{g_{s,0} f_s f_g LAI}\n\nwhere LAI is the leaf area index, defined as half of the total leaf area, and f_s is a factor representing the distribution of stomata in the leaf (f_s=1 for hypostomatous leaves and f_s=2 for amphistomatous leaves) and f_g is the fraction of LAI that is green and hence actively transpiring.\n\nAccounting for the negative feedback observed between transpiration (T) rates and stomatal closure based on a wide variety of plant level measurements, \n\nMONTEITH (1995) proposed a method to parameterize the relationship between leaf stomatal conductance (g_s) and VPD, based on measurements of transpiration as follows:g_{s} = \\frac{g_m}{1 + g_m VPD/T_m}\n\nValues of g_m and T_m will be empirically derived by plotting observations of T and VPD, and building a linear regression:1/T = \\frac{1}{a{VPD}} + b\n\nfrom which g_m = a and T_m = 1/b. Finally, from these metrics qe can derive the \n\nLEUNING (1995) stomatal conductance model:g_{s,0} = \\frac{g_m}{1 + VPD / D_0}\n\n","type":"content","url":"/b02-tseb-sw#gs-header","position":9},{"hierarchy":{"lvl1":"Shuttleworth-Wallace TSEB in advective conditions","lvl4":"Application with actual data","lvl3":"Sensitivity of stomatal conductance to vapour pressure deficit","lvl2":"Shuttleworth-Wallace model"},"type":"lvl4","url":"/b02-tseb-sw#application-with-actual-data","position":10},{"hierarchy":{"lvl1":"Shuttleworth-Wallace TSEB in advective conditions","lvl4":"Application with actual data","lvl3":"Sensitivity of stomatal conductance to vapour pressure deficit","lvl2":"Shuttleworth-Wallace model"},"content":"To build the linear regression of Eq. \n\n(8) we need work at leaf scale. Therefore, the estimated canopy transpiration from the eddy covariance tower is (TEC) first downscaled to an effective leaf transpiration rate using the satellite LAI (T_{leaf} = T/LAI).\n\nFirst select the sites that you want to use to derived the g_m, T_m and D_0 metrics. You can select one or several sites and see how sensitive are these parameters to the grape varieties.\n\nw_site_list = widgets.SelectMultiple(\n    options=[('Sierra Loma N', \"slmN\"), ('Sierra Loma S', \"slmS\"), \n             ('Barrelli 007', \"bar007\"), ('Barrelli 012', \"bar012\"),\n             ('Ripperdan 760', \"rip760\"), \n             ('Ripperdan 720-1', \"rip720_1\"),  ('Ripperdan 720-2', \"rip720_2\"),  ('Ripperdan 720-3', \"rip720_3\"),  ('Ripperdan 720-4', \"rip720_4\")],\n    value=[\"rip720_1\", \"rip720_2\", \"rip760\"],\n    description='Sites',\n    rows=9\n)\ndisplay(w_site_list)\n\n","type":"content","url":"/b02-tseb-sw#application-with-actual-data","position":11},{"hierarchy":{"lvl1":"Shuttleworth-Wallace TSEB in advective conditions","lvl5":"Read the EC and LAI data files","lvl4":"Application with actual data","lvl3":"Sensitivity of stomatal conductance to vapour pressure deficit","lvl2":"Shuttleworth-Wallace model"},"type":"lvl5","url":"/b02-tseb-sw#read-the-ec-and-lai-data-files","position":12},{"hierarchy":{"lvl1":"Shuttleworth-Wallace TSEB in advective conditions","lvl5":"Read the EC and LAI data files","lvl4":"Application with actual data","lvl3":"Sensitivity of stomatal conductance to vapour pressure deficit","lvl2":"Shuttleworth-Wallace model"},"content":"\n\n# Import Python libraries\nfrom pathlib import Path\nimport pandas as pd\nfrom pyTSEB import TSEB\n\n# Set the LAI and readiation folders\ninput_dir = Path().absolute() / \"input\"\nlai_dir = input_dir / \"canopy\"\nrad_dir = input_dir / \"meteo\"\n\n# Append all tables in a single merged table\nec_all = pd.DataFrame()\nfor site in w_site_list.value:\n    # Set the input files based on the chosen site\n    lai_filename = lai_dir / f\"FLX_US-{site}_FLUXNET2015_AUXCANOPY_DD.csv\"\n    ec_filename = rad_dir / f\"FLX_US-{site}_FLUXNET2015_SUBSET_HR.csv\"\n    print(f\"LAI file path is {lai_filename}\")\n    print(f\"Micrometeorogy file path is {ec_filename}\")\n    \n    # Read the LAI and radiation tables\n    lai = pd.read_csv(lai_filename, sep=\";\", na_values=-9999)\n    ec = pd.read_csv(ec_filename, sep=\";\", na_values=-9999)\n    \n    # Merge both tables by date\n    ec[\"TIMESTAMP\"] = pd.to_datetime(ec[\"TIMESTAMP\"], format=\"%Y%m%d%H%M\")\n    lai[\"DATE\"] = pd.to_datetime(lai[\"TIMESTAMP\"], format=\"%Y%m%d\").dt.date\n    lai = lai.drop(labels=[\"TIMESTAMP\"], axis=1)\n    ec[\"DATE\"] = ec[\"TIMESTAMP\"].dt.date\n    ec = ec.merge(lai, on=\"DATE\")\n    ec[\"SITE\"] = site\n    \n\n    ec_all = pd.concat([ec_all, ec], ignore_index=True, axis=0)\n\nSee Also\n\nThis is a full description of the EC column fields:\n\n\n\nThe values of T are estimated using a several methods based on relaxed-eddy accumulation and quadrant analysis \n\nThomas et al., 2008\n\nZahn et al., 2022. We compute the average of the three methods (CEC, REA, and FVS). Then we convert those values expressed in energy units into mole fractions:\n\nfrom pyTSEB import physiology as lf\n\n# Only derive the parameters when grapevine in active\nDOY_LIMS = (120, 246)\n\nec_all[\"LE_C\"] = np.nanmean(ec_all[[\"LE_C_ECC\", \"LE_C_REA\", \"LE_C_FVS\"]], axis=1)\n# Convert Celsius to Kelvin\nec_all[\"TA\"] = ec_all[\"TA\"] + 273.15\n# Convert kPa to hPa\nec_all[\"PA\"] = 10 * ec_all[\"PA\"]\n\n# Work only under daytime conditions and positive LE fluxes\nvalid = np.logical_and.reduce((ec_all[\"SW_IN\"] > 100,\n                               ec_all[\"VPD\"] > 0,\n                               np.isfinite(ec_all[\"LE_C\"]),\n                               ec_all[\"TIMESTAMP\"].dt.dayofyear >= DOY_LIMS[0],\n                               ec_all[\"TIMESTAMP\"].dt.dayofyear <= DOY_LIMS[1],\n                               ec_all[\"LE_C\"] > 0))\n\nec_all = ec_all.loc[valid, :]\n# Monteith approach needs to convert units to millimoles\nec_all[\"VPD_MMOL\"] = 1e3 * ec_all[\"VPD\"].values / ec_all[\"PA\"].values\nec_all[\"LE_C_MMOL\"] = ec_all[\"LE_C\"].values / (ec_all[\"LAI\"].values * lf.mmolh20_2_wm2(ec_all[\"TA\"].values))\n\nThe linear relationship between the reciprocals of VPD and maximum T only appears when VPD is the main limiting factor to stomata closure \n\nMONTEITH, 1995. Therefore, this linear relationship is derived from the lower envelope of the 1/T vs. 1/VPD scatterplot for all daytime EC observations under relatively high VPD values.\n\nWe create the following helper functions to get the lower envelope of the vpd vs. T relationship and the stomatal metrics:\n\ndef get_envelope(x_array, y_array, percentile=0.95, n_bins=30):\n    # Bin x_array\n    _, bin_edges = np.histogram(x_array, bins=n_bins)\n\n    x_values = []\n    y_values = []\n    for i, edge in enumerate(bin_edges[:-1]):\n        valid = np.logical_and(x_array >= edge, x_array < bin_edges[i + 1])\n        if np.any(valid):\n            x_values.append(np.mean(x_array[valid]))\n            if percentile == \"minimum\":\n                y_values.append(np.nanmin(y_array[valid]))\n            elif percentile == \"maximum\":\n                y_values.append(np.nanmax(y_array[valid]))\n            else:\n                y_values.append(np.percentile(y_array[valid], 100 * percentile))\n\n    return np.asarray(x_values), np.asarray(y_values)\n\n    \ndef monteith_2_leuning(g_m, t_m, p=1013.15):\n    \"\"\"\n\n    :param g_m: mol m$^{{-2}}$ s$^{{-1}}$\n    :param t_m: mmol m$^{{-2}}$ s$^{{-1}}$\n    :return:\n    d_0: hPa\n    \"\"\"\n    d_0 = t_m / g_m  # mmol mol-1\n    # Convert from mmol mol-1 to mb\n    d_0 *= 1e-3 * p\n    return d_0\n\n\ndef leuning_stress(vpd, d_0):\n\n    stress = 1. / (1. + vpd / d_0)\n    return stress\n\n\n... and with these helper functions we are ready to estimate the stomatal parameters\n\nimport scipy.stats as st\nfrom plotly.subplots import make_subplots\nimport plotly.graph_objects as go\n\n# Set the criteria for the envelope search\nMIN_PERCENTILE = 0.01\nN_BINS = \"auto\"\n\n# We first dervive the parameters based on all the selected sites together\nvalid = 1. / ec_all[\"VPD_MMOL\"] < 0.08\n\nprint(f\"Finding stomatal parameters for all sites together\")\n# Find the lower envelope                         \nxs, ys = get_envelope(1. / ec_all.loc[valid, \"VPD_MMOL\"], 1. / ec_all.loc[valid, \"LE_C_MMOL\"],\n                      percentile=MIN_PERCENTILE,\n                      n_bins=N_BINS)\n\n# Adjust a linear model from the lower envelope\nlm = st.linregress(xs, ys)\n# Plot the linear model\nfig = go.Figure()\nfig.add_trace(go.Scatter(x=xs, y=lm.intercept + lm.slope * xs, name=\"Fit ALL\", mode=\"lines\", line={\"color\":\"black\"}))\n\n# We will store each parameter in a Python dictionary\nn_cases = {}\ngm = {}\nt_m = {}\nd_0 = {}\n\n# Derive the Monteith and Leuning stomata parameters\nn_cases[\"ALL\"] = np.sum(valid)\ngm[\"ALL\"] = 1. / lm.slope\nt_m[\"ALL\"] = 1. / lm.intercept\nd_0[\"ALL\"] = monteith_2_leuning(gm[\"ALL\"], t_m[\"ALL\"], p=np.nanmean(ec_all.loc[valid, \"PA\"]))\n\n# We now repeat the same procedure for each site individually\nfor site, site_label in zip(w_site_list.value, w_site_list.label):\n    print(f\"Finding stomatal parameters for {site_label}\")\n    valid = np.logical_and(1. / ec_all[\"VPD_MMOL\"] < 0.08, ec_all[\"SITE\"] == site)\n    \n    # Find the lower envelope                         \n    xs, ys = get_envelope(1. / ec_all.loc[valid, \"VPD_MMOL\"], 1. / ec_all.loc[valid, \"LE_C_MMOL\"],\n                          percentile=MIN_PERCENTILE,\n                          n_bins=N_BINS)\n    # Adjust a linear model from the lower envelope\n    lm = st.linregress(xs, ys)\n    # Plot the linear model\n    fig.add_trace(go.Scatter(x=xs, y=lm.intercept + lm.slope * xs, name=f\"Fit {site}\", mode=\"lines\")) \n\n    # Derive the Monteith and Leuning stomata parameters\n    n_cases[site] = np.sum(valid)\n    gm[site] = 1. / lm.slope\n    t_m[site] = 1. / lm.intercept\n    d_0[site] = monteith_2_leuning(gm[site], t_m[site], p=np.nanmean(ec_all.loc[valid, \"PA\"]))\n    fig.add_trace(go.Scatter(x=1. / ec_all.loc[valid, \"VPD_MMOL\"], y=1. / ec_all.loc[valid, \"LE_C_MMOL\"], name=site, mode=\"markers\"))  \n\nfig.update_layout(title_text=f\"Derivation of Stomata parameters\", \n                  xaxis_title=\"1/VPD (mol mmol-1)\", yaxis_title=\"1/T (s m2 mmol-1)\",\n                  yaxis_range=[0, 0.5], xaxis_range=[0.01, 0.1])\n\n\n\nfrom tabulate import tabulate\ntable = [#[\"N cases\"] + [value for key, value in n_cases.items()],\n         [\"$g_m$ mol m$^{{-2}}$ s$^{{-1}}$\"] + [value for key, value in gm.items()],\n         [\"$T_m$ mmol m$^{{-2}}$ s$^{{-1}}\"] + [value for key, value in t_m.items()],\n         [\"$D_0$ hPa\"] + [value for key, value in d_0.items()]]\n\nprint(tabulate(table, headers=[\"Parameter\"] + [i for i in gm.keys()]))\n\n","type":"content","url":"/b02-tseb-sw#read-the-ec-and-lai-data-files","position":13},{"hierarchy":{"lvl1":"Shuttleworth-Wallace TSEB in advective conditions","lvl2":"Implementation with actual data in pyTSEB"},"type":"lvl2","url":"/b02-tseb-sw#implementation-with-actual-data-in-pytseb","position":14},{"hierarchy":{"lvl1":"Shuttleworth-Wallace TSEB in advective conditions","lvl2":"Implementation with actual data in pyTSEB"},"content":"As with the previous exercices, we will work with any of the sites of GRAPEX, using the micrometeorological measurements and Earth Observation LAI.\n\nTable 1:Description of GRAPEX sites\n\nSite\n\nLatitude\n\nLongitude\n\nElevation (m)\n\nRow direction (deg.)\n\nRow spacing (m)\n\nMin. height (m)\n\nMax. height (m)\n\nMin. width (m)\n\nMax. width (m)\n\nTA height (m)\n\nWS height (m)\n\nRipperdan 720-1\n\n36.849\n\n-120.176\n\n61\n\n90\n\n3.35\n\n1.2\n\n2.2\n\n0.5\n\n2.25\n\n4\n\n4\n\nRipperdan 720-2\n\n36.849\n\n-120.174\n\n61\n\n90\n\n3.35\n\n1.2\n\n2.2\n\n0.5\n\n2.25\n\n4\n\n4\n\nRipperdan 720-3\n\n36.848\n\n-120.176\n\n61\n\n90\n\n3.35\n\n1.2\n\n2.2\n\n0.5\n\n2.25\n\n4\n\n4\n\nRipperdan 720-4\n\n36.848\n\n-120.174\n\n61\n\n90\n\n3.35\n\n1.2\n\n2.2\n\n0.5\n\n2.25\n\n4\n\n4\n\nBarrelli_007\n\n38.753\n\n-122.98\n\n113\n\n135\n\n3.35\n\n1.25\n\n2.3\n\n0.5\n\n1.8\n\n4\n\n4\n\nBarrelli_012\n\n38.751369\n\n-122.974658\n\n112\n\n45\n\n3.35\n\n1.25\n\n2.3\n\n0.5\n\n1.8\n\n4.4\n\n4.4\n\nSierra Loma-north\n\n38.289338\n\n-121.117764\n\n38\n\n90\n\n3.35\n\n1.42\n\n2.25\n\n0.5\n\n2.6\n\n5\n\n5\n\nSierra Loma-south\n\n38.280488\n\n-121.117597\n\n37\n\n90\n\n3.35\n\n1-42\n\n2.25\n\n0.5\n\n2\n\n5\n\n5\n\nRipperdan 760\n\n36.839025\n\n-120.21014\n\n58\n\n90\n\n2.74\n\n1.2\n\n2.5\n\n0.5\n\n1.8\n\n5.5\n\n5\n\nBarrelli_016\n\n38.747\n\n-122.963\n\n112\n\n135\n\n3.35\n\n1.25\n\n2.3\n\n0.5\n\n1.8\n\n4\n\n4","type":"content","url":"/b02-tseb-sw#implementation-with-actual-data-in-pytseb","position":15},{"hierarchy":{"lvl1":"Shuttleworth-Wallace TSEB in advective conditions","lvl3":"Select a site","lvl2":"Implementation with actual data in pyTSEB"},"type":"lvl3","url":"/b02-tseb-sw#select-a-site","position":16},{"hierarchy":{"lvl1":"Shuttleworth-Wallace TSEB in advective conditions","lvl3":"Select a site","lvl2":"Implementation with actual data in pyTSEB"},"content":"\n\nw_site = widgets.Dropdown(\n    options=[('Sierra Loma N', \"slmN\"), ('Sierra Loma S', \"slmS\"), \n             ('Barrelli 007', \"bar007\"), ('Barrelli 012', \"bar012\"),\n             ('Ripperdan 760', \"rip760\"), \n             ('Ripperdan 720-1', \"rip720_1\"),  ('Ripperdan 720-2', \"rip720_2\"),  ('Ripperdan 720-3', \"rip720_3\"),  ('Ripperdan 720-4', \"rip720_4\")],\n    value=\"rip760\",\n    description='Site:',\n)\ndisplay(w_site)\n\n","type":"content","url":"/b02-tseb-sw#select-a-site","position":17},{"hierarchy":{"lvl1":"Shuttleworth-Wallace TSEB in advective conditions","lvl3":"Read the LAI and Micrometeorology data","lvl2":"Implementation with actual data in pyTSEB"},"type":"lvl3","url":"/b02-tseb-sw#read-the-lai-and-micrometeorology-data","position":18},{"hierarchy":{"lvl1":"Shuttleworth-Wallace TSEB in advective conditions","lvl3":"Read the LAI and Micrometeorology data","lvl2":"Implementation with actual data in pyTSEB"},"content":"\n\n# Import Python libraries\nfrom pathlib import Path\nimport pandas as pd\n\n# Set the LAI and readiation folders\ninput_dir = Path().absolute() / \"input\"\nlai_dir = input_dir / \"canopy\"\nec_dir = input_dir / \"meteo\"\n# Set the input files based on the chosen site\nlai_filename = lai_dir / f\"FLX_US-{w_site.value}_FLUXNET2015_AUXCANOPY_DD.csv\"\nec_filename = ec_dir / f\"FLX_US-{w_site.value}_FLUXNET2015_SUBSET_HR.csv\"\nprint(f\"LAI file path is {lai_filename}\")\nprint(f\"EC file path is {ec_filename}\")\n\n# Read the LAI and radiation tables\nlai = pd.read_csv(lai_filename, sep=\";\", na_values=-9999)\nec = pd.read_csv(ec_filename, sep=\";\", na_values=-9999)\n\n# Merge both tables by date\nec[\"TIMESTAMP\"] = pd.to_datetime(ec[\"TIMESTAMP\"], format=\"%Y%m%d%H%M\")\nlai[\"DATE\"] = pd.to_datetime(lai[\"TIMESTAMP\"], format=\"%Y%m%d\").dt.date\nlai = lai.drop(labels=[\"TIMESTAMP\"], axis=1)\nec[\"DATE\"] = ec[\"TIMESTAMP\"].dt.date\nec = ec.merge(lai, on=\"DATE\")\n\n# We discard all cases at night (SW_IN <=0)\nec = ec[ec[\"SW_IN\"] > 0]\n\n# Convert Celsius to Kelvin\nec[\"TA\"] = ec[\"TA\"] + 273.15\n# Convert kPa to hPa\nec[\"PA\"] = 10 * ec[\"PA\"]\n\n# Evaluate different energy balance closure corrections\nec[\"H_RES\"] = ec[\"NETRAD\"] - ec[\"G\"] - ec[\"LE\"]\nec['LE_RES'] = ec['NETRAD'] - ec['G'] - ec['H']\nec[\"LE_BR\"], ec[\"H_BR\"] = TSEB.met.bowen_ratio_closure(ec[\"NETRAD\"], ec[\"G\"],\n                                                       ec[\"H\"], ec[\"LE\"])\n# Mean of uncorrected, ressidual and Bowen Ratio\nec[\"H_ENS\"] = np.nanmean([ec[\"H_RES\"], ec[\"H_BR\"], ec['H']], axis=0)\nec[\"LE_ENS\"] = np.nanmean([ec[\"LE_RES\"], ec[\"LE_BR\"], ec['LE']], axis=0)\n\n","type":"content","url":"/b02-tseb-sw#read-the-lai-and-micrometeorology-data","position":19},{"hierarchy":{"lvl1":"Shuttleworth-Wallace TSEB in advective conditions","lvl3":"Set the stomata sensitivty to VPD","lvl2":"Implementation with actual data in pyTSEB"},"type":"lvl3","url":"/b02-tseb-sw#set-the-stomata-sensitivty-to-vpd","position":20},{"hierarchy":{"lvl1":"Shuttleworth-Wallace TSEB in advective conditions","lvl3":"Set the stomata sensitivty to VPD","lvl2":"Implementation with actual data in pyTSEB"},"content":"\n\nstyle = {'description_width': 'initial'}\nw_d_0 = widgets.BoundedFloatText(min=0.01, max=20, value=16.93, description=\"$D_0$ (hPa)\", step=0.1, style=style)\nw_g_m = widgets.BoundedFloatText(min=0.01, max=1, value=0.53, description=\"$g_m$ (mol m$^{-2}$ s$^{-1}$)\", step=0.01, style=style)\ndisplay(w_d_0, w_g_m)\n\n","type":"content","url":"/b02-tseb-sw#set-the-stomata-sensitivty-to-vpd","position":21},{"hierarchy":{"lvl1":"Shuttleworth-Wallace TSEB in advective conditions","lvl3":"Get the canopy a priori structural properties","lvl2":"Implementation with actual data in pyTSEB"},"type":"lvl3","url":"/b02-tseb-sw#get-the-canopy-a-priori-structural-properties","position":22},{"hierarchy":{"lvl1":"Shuttleworth-Wallace TSEB in advective conditions","lvl3":"Get the canopy a priori structural properties","lvl2":"Implementation with actual data in pyTSEB"},"content":"\n\nimport yaml\nyaml_file = input_dir / \"site_description.yaml\"\nsite_dict = yaml.safe_load(yaml_file.read_text())\nlat = float(site_dict[\"lat\"][w_site.value])\nlon = float(site_dict[\"lon\"][w_site.value])\nelev = float(site_dict[\"elev\"][w_site.value])\nrow_direction = float(site_dict[\"row_direction\"][w_site.value])\ninterrow = float(site_dict[\"interrow\"][w_site.value])\nhc_min = float(site_dict[\"hc_min\"][w_site.value])\nhc_max = float(site_dict[\"hc_max\"][w_site.value])\nwc_min = float(site_dict[\"wc_min\"][w_site.value])\nwc_max = float(site_dict[\"wc_max\"][w_site.value])\nzh = float(site_dict[\"zh\"][w_site.value])\nzm = float(site_dict[\"zm\"][w_site.value])\n\nprint(f\"{w_site.label} has the following site characteristics:\\n\"\n      f\"\\t Latitude: {lat} deg. \\n\"\n      f\"\\t Longitude: {lon} deg. \\n\"\n      f\"\\t Elevation: {elev} m \\n\"\n      f\"\\t Row direction: {row_direction} deg. \\n\"\n      f\"\\t Row spacing: {interrow} m \\n\"\n      f\"\\t Min. canopy height: {hc_min} m \\n\"\n      f\"\\t Max. canopy height: {hc_max} m \\n\"\n      f\"\\t Min. canopy width: {wc_min} m \\n\"\n      f\"\\t Max. canopy width: {wc_max} m \\n\"\n      f\"\\t Air temperature measurement height: {zh} m \\n\"\n      f\"\\t Wind speed temperature measurement height: {zh} m\"\n)\n\n","type":"content","url":"/b02-tseb-sw#get-the-canopy-a-priori-structural-properties","position":23},{"hierarchy":{"lvl1":"Shuttleworth-Wallace TSEB in advective conditions","lvl3":"Estimate the structural variables based on Earth Observation LAI timeseries","lvl2":"Implementation with actual data in pyTSEB"},"type":"lvl3","url":"/b02-tseb-sw#estimate-the-structural-variables-based-on-earth-observation-lai-timeseries","position":24},{"hierarchy":{"lvl1":"Shuttleworth-Wallace TSEB in advective conditions","lvl3":"Estimate the structural variables based on Earth Observation LAI timeseries","lvl2":"Implementation with actual data in pyTSEB"},"content":"As with the previous exercise, we will estimate timeseries of canopy structural variables based on LAI and empirical observations of trellis development.\n\n\n\nFigure 2:Empirical models relating canopy height , canopy width and the bottom of the canopy with the fused STARFM LAI. Solid dots represent in situ measured values\n\nThese empirical equations are coded in Python as:\n\nimport numpy as np\n\n################################################################################\n# Empirical equations to generate canopy structural parameters from LAI\n################################################################################\ndef lai_2_hc(lai, hc_min):\n    slope = 0.42\n    hc = hc_min + slope * lai\n    return hc\n\n\ndef lai_2_hbratio(lai, hc_min):\n    hb_ratio_mean = 0.4848388065\n    hb_ratio = np.zeros(lai.shape)\n\n    hb_ratio[lai < hc_min] = 1. + ((hb_ratio_mean - 1.) / hc_min) * lai[\n        lai < hc_min]\n    hb_ratio[lai >= hc_min] = hb_ratio_mean\n\n    return hb_ratio\n\n\ndef lai_2_width(lai, wc_min, wc_max):\n    beta = 6.96560056\n    offset = 1.70825736\n\n    width = wc_min + (wc_max - wc_min) / (1.0 + np.exp(-beta * (lai - offset)))\n\n    return width\n\n\ndef lai_2_fcover(lai, fc_min, fc_max):\n    beta = 7.0\n    offset = 1.70\n\n    fcover = fc_min + (fc_max - fc_min) / (1.0 + np.exp(-beta * (lai - offset)))\n\n    return fcover\n\n\ndef lai_2_canopy(lai, hc_min, fc_min, fc_max):\n    hc = lai_2_hc(lai, hc_min)\n    hb_ratio = lai_2_hbratio(lai, hc_min)\n    fcover = lai_2_fcover(lai, fc_min, fc_max)\n\n    return hc, hb_ratio, fcover\n\nFrom these empirical functions together with the site description properties described in \n\nSite Description we can caluculate the time series of canopy structural variables needed to compute the shadowing as shown in \n\nFigure 1\n\nNote\n\nThese equations are site specific and most likely not applicable to other sites and crops. For operational purposes, such as using Earth Observation/satellite data a trade-off must be made between accuracy and applicability.\n\n# Compute the expected minimum and maximum canopy cover based on mininum and maximum canopy width\nfc_min = wc_min / interrow\nfc_max = wc_max / interrow\nh_c, hb_ratio, f_c = lai_2_canopy(ec[\"LAI\"].values,\n                                  hc_min,\n                                  fc_min,\n                                  fc_max)\n\n# Ensure that both canopy height and cover are within the limits\nh_c = np.clip(h_c, hc_min, hc_max)\nf_c = np.clip(f_c, 0, 1)\n\n","type":"content","url":"/b02-tseb-sw#estimate-the-structural-variables-based-on-earth-observation-lai-timeseries","position":25},{"hierarchy":{"lvl1":"Shuttleworth-Wallace TSEB in advective conditions","lvl3":"We can get the shortwave net radiation for row crops","lvl2":"Implementation with actual data in pyTSEB"},"type":"lvl3","url":"/b02-tseb-sw#we-can-get-the-shortwave-net-radiation-for-row-crops","position":26},{"hierarchy":{"lvl1":"Shuttleworth-Wallace TSEB in advective conditions","lvl3":"We can get the shortwave net radiation for row crops","lvl2":"Implementation with actual data in pyTSEB"},"content":"\n\nfrom pyTSEB import TSEB\n\n# We can get the leaf and soil spectral from the values above, or hard code the corresponding values\nrho_leaf_vis = 0.054\nrho_leaf_nir = 0.262\ntau_leaf_vis = 0.038\ntau_leaf_nir = 0.333\nrho_soil_vis = 0.07\nrho_soil_nir = 0.32\n\n# canopy width\nw_c = f_c * interrow\n# Canopy width to height ratio\nw_c_ratio = w_c / (h_c - hb_ratio * h_c)\n# Local LAI\nF = ec[\"LAI\"].values / f_c\n\n# The time zone is PST, which corresponds to -120 deg, time longitude\nstdlon = -120\n# Call calc_sun_angles based on site coordinates and timestamp\nsza, saa = TSEB.met.calc_sun_angles(\n    np.full_like(ec['LAI'].values, lat),\n    np.full_like(ec[\"LAI\"].values, lon),\n    np.full_like(ec[\"LAI\"].values, stdlon),\n    ec['TIMESTAMP'].dt.dayofyear.values,\n    ec['TIMESTAMP'].dt.hour.values + ec['TIMESTAMP'].dt.minute.values / 60.)\n\n# Compute the relative sun-row azimuth angle\npsi = row_direction - saa\n# Compute the clumping index for row crops\nomega = TSEB.CI.calc_omega_rows(ec[\"LAI\"], f_c, theta=sza,\n                                psi=psi, w_c=w_c_ratio)\n\n# And the effective LAI is the product of local LAI and the clumping index\nlai_eff = F * omega\n\n# Estimates the direct and diffuse solar radiation\ndifvis, difnir, fvis, fnir = TSEB.rad.calc_difuse_ratio(ec[\"SW_IN\"].values,\n                                                        sza,\n                                                        press=np.full_like(sza, 1013.15))\npar_dir = fvis * (1. - difvis) * ec[\"SW_IN\"].values\nnir_dir = fnir * (1. - difnir) * ec[\"SW_IN\"].values\npar_dif = fvis * difvis * ec[\"SW_IN\"].values\nnir_dif = fnir * difnir * ec[\"SW_IN\"].values\n\n# Compute the canopy and soil net radiation using Cambpell RTM\nsn_c, sn_s = TSEB.rad.calc_Sn_Campbell(ec[\"LAI\"].values,\n                                       sza,\n                                       par_dir + nir_dir,\n                                       par_dif + nir_dif,\n                                       fvis,\n                                       fnir,\n                                       np.full_like(sza, rho_leaf_vis),\n                                       np.full_like(sza, tau_leaf_vis),\n                                       np.full_like(sza, rho_leaf_nir),\n                                       np.full_like(sza, tau_leaf_nir),\n                                       np.full_like(sza, rho_soil_vis),\n                                       np.full_like(sza, rho_soil_nir),\n                                       x_LAD=1,\n                                       LAI_eff=lai_eff)\n\nsn_c[~np.isfinite(sn_c)] = 0\nsn_s[~np.isfinite(sn_s)] = 0\n\n","type":"content","url":"/b02-tseb-sw#we-can-get-the-shortwave-net-radiation-for-row-crops","position":27},{"hierarchy":{"lvl1":"Shuttleworth-Wallace TSEB in advective conditions","lvl4":"Evaluate the shortwave net radiation estimates","lvl3":"We can get the shortwave net radiation for row crops","lvl2":"Implementation with actual data in pyTSEB"},"type":"lvl4","url":"/b02-tseb-sw#evaluate-the-shortwave-net-radiation-estimates","position":28},{"hierarchy":{"lvl1":"Shuttleworth-Wallace TSEB in advective conditions","lvl4":"Evaluate the shortwave net radiation estimates","lvl3":"We can get the shortwave net radiation for row crops","lvl2":"Implementation with actual data in pyTSEB"},"content":"\n\nfrom model_evaluation import double_collocation as dc\ndaytime = ec[\"SW_IN\"] > 100\n\nsn_model = sn_c + sn_s\nsn_obs = ec[\"SW_IN\"].values - ec[\"SW_OUT\"].values\n\nfig = go.Figure()\nfig.add_trace(go.Scattergl(x=sn_model[daytime], y=sn_obs[daytime], \n                         name=\"Sn for row crops\", mode=\"markers\"))\nfig.add_trace(go.Scatter(x=[0, 1000], y=[0, 1000], mode=\"lines\", name=\"1:1 line\", line={\"color\": \"black\", \"dash\": \"dash\"}))\nfig.update_layout(title_text=f\"Observed vs. Estimated below net radiation at {w_site.label}\",\n                  yaxis_range=[0, 1000], xaxis_range=[0, 1000],\n                  xaxis_title=\"Estimated (W m-2)\", yaxis_title=\"Observed (W m-2)\")\n\n","type":"content","url":"/b02-tseb-sw#evaluate-the-shortwave-net-radiation-estimates","position":29},{"hierarchy":{"lvl1":"Shuttleworth-Wallace TSEB in advective conditions","lvl3":"Set additional site parameters needed for TSEB","lvl2":"Implementation with actual data in pyTSEB"},"type":"lvl3","url":"/b02-tseb-sw#set-additional-site-parameters-needed-for-tseb","position":30},{"hierarchy":{"lvl1":"Shuttleworth-Wallace TSEB in advective conditions","lvl3":"Set additional site parameters needed for TSEB","lvl2":"Implementation with actual data in pyTSEB"},"content":"\n\n# Grapevine leaf width\nleaf_width = 0.10\n\n# Roughness for bare soil\nz0_soil = 0.15\n\n# Kustas and Norman boundary layer resistance parameters\nroil_resistance_c_param = 0.0038\nroil_resistance_b_param = 0.012\nroil_resistance_cprime_param = 90.\n# Thermal spectra\ne_v = 0.99  # Leaf emissivity\ne_s = 0.94  # Soil emissivity\n\n# Resistance for soil evaporation of a well watered situation\nrss_min = 0  # Asumme initial free water evaporation\n\n","type":"content","url":"/b02-tseb-sw#set-additional-site-parameters-needed-for-tseb","position":31},{"hierarchy":{"lvl1":"Shuttleworth-Wallace TSEB in advective conditions","lvl3":"Estimate surface aerodynamic roughness","lvl2":"Implementation with actual data in pyTSEB"},"type":"lvl3","url":"/b02-tseb-sw#estimate-surface-aerodynamic-roughness","position":32},{"hierarchy":{"lvl1":"Shuttleworth-Wallace TSEB in advective conditions","lvl3":"Estimate surface aerodynamic roughness","lvl2":"Implementation with actual data in pyTSEB"},"content":"We estimate aerodynamic roughness for tall canopies based on \n\nRaupach (1994) and \n\n:\n\nz_0m, d_0 = TSEB.res.calc_roughness(ec[\"LAI\"], h_c, w_c_ratio, np.full_like(ec[\"LAI\"], TSEB.res.BROADLEAVED_D), f_c=f_c)\n# Ensure realistic values\nd_0[d_0 < 0] = 0\nz_0m[np.isnan(z_0m)] = z0_soil\nz_0m[z_0m < z0_soil] = z0_soil\n\n","type":"content","url":"/b02-tseb-sw#estimate-surface-aerodynamic-roughness","position":33},{"hierarchy":{"lvl1":"Shuttleworth-Wallace TSEB in advective conditions","lvl3":"We derive the half-hourly LST based on pyrgeomters on the EC tower","lvl2":"Implementation with actual data in pyTSEB"},"type":"lvl3","url":"/b02-tseb-sw#we-derive-the-half-hourly-lst-based-on-pyrgeomters-on-the-ec-tower","position":34},{"hierarchy":{"lvl1":"Shuttleworth-Wallace TSEB in advective conditions","lvl3":"We derive the half-hourly LST based on pyrgeomters on the EC tower","lvl2":"Implementation with actual data in pyTSEB"},"content":"\n\n# Surface emissivity\ne_surf = f_c * e_v + (1. - f_c) * e_s\n\n# LST from longwave radiometers\nlst = ((ec['LW_OUT'].values - (1. - e_surf) * ec['LW_IN'].values) / (\n        TSEB.rad.SB * e_surf)) ** 0.25\n\n# And it is assuming that the radiometer is looking at nadir\nvza = np.zeros_like(lst)\n\n","type":"content","url":"/b02-tseb-sw#we-derive-the-half-hourly-lst-based-on-pyrgeomters-on-the-ec-tower","position":35},{"hierarchy":{"lvl1":"Shuttleworth-Wallace TSEB in advective conditions","lvl3":"We run now TSEB-SW","lvl2":"Implementation with actual data in pyTSEB"},"type":"lvl3","url":"/b02-tseb-sw#we-run-now-tseb-sw","position":36},{"hierarchy":{"lvl1":"Shuttleworth-Wallace TSEB in advective conditions","lvl3":"We run now TSEB-SW","lvl2":"Implementation with actual data in pyTSEB"},"content":"See Also\n\nThe full code for the Shuttleworth and Wallace model is at the \n\npyTSEB GitHub repository\n\n# Initialize the potential stomtal conductance by a minimum value\ngs = np.full_like(lst, 0.01)\n\n# Update the  potential stomtal conductance for daytime\ngs[daytime] = w_g_m.value * leuning_stress(ec[\"VPD\"][daytime],  w_d_0.value)\n\n# Convert stomtata conductance to resistance (s m-1)\nrst_min = 1. / (TSEB.res.molm2s1_2_ms1(ec[\"TA\"].values, ec[\"PA\"].values) * gs)\nrst_min[rst_min < 0] = np.nan\n\nresistance_flag = [0, {\"KN_c\": np.full_like(lst, roil_resistance_c_param),\n                       \"KN_b\": np.full_like(lst, roil_resistance_b_param),\n                       \"KN_C_dash\": np.full_like(lst, roil_resistance_cprime_param)}]\n\n# Run TSEB-SW\n[flag_sw, ts_sw, tc_sw, t_ac_sw, ln_s_sw, ln_c_sw, le_c_sw, h_c_sw, le_s_sw, h_s_sw, g_sw,\n r_s_sw, r_x_sw, r_a_sw, rss_sw, rst_sw, u_friction_sw, lmo_sw, n_iterations_sw] = TSEB.TSEB_SW(                                                     \n     lst,\n     vza,\n     ec[\"TA\"].values,\n     ec[\"WS\"].values,\n     ec[\"EA\"].values,\n     ec[\"PA\"].values,\n     sn_c,\n     sn_s,\n     ec[\"LW_IN\"].values,\n     ec[\"LAI\"].values,\n     h_c,\n     e_v,\n     e_s,\n     z_0m,\n     d_0,\n     zm,\n     zh,\n     x_LAD=np.ones_like(lst),\n     f_c=f_c,\n     f_g=np.ones_like(lst),\n     w_C=w_c_ratio,\n     leaf_width=leaf_width,\n     z0_soil=z0_soil,\n     Rst_min=rst_min,\n     Rss_min=rss_min,\n     resistance_form=resistance_flag,\n     calcG_params=[[1], 0.35])\n\n# ... and finally we compute the bulk fluxes\nle_sw = le_c_sw + le_s_sw\nh_sw = h_c_sw + h_s_sw\nnetrad_sw = sn_c + sn_s + ln_c_sw + ln_s_sw\n\n","type":"content","url":"/b02-tseb-sw#we-run-now-tseb-sw","position":37},{"hierarchy":{"lvl1":"Shuttleworth-Wallace TSEB in advective conditions","lvl4":"... and to compare we also run TSEB-PT","lvl3":"We run now TSEB-SW","lvl2":"Implementation with actual data in pyTSEB"},"type":"lvl4","url":"/b02-tseb-sw#id-and-to-compare-we-also-run-tseb-pt","position":38},{"hierarchy":{"lvl1":"Shuttleworth-Wallace TSEB in advective conditions","lvl4":"... and to compare we also run TSEB-PT","lvl3":"We run now TSEB-SW","lvl2":"Implementation with actual data in pyTSEB"},"content":"\n\n# Run TSEB-PT\nalpha_PT_0 = 1.26\n[flag_pt, ts_pt, tc_pt, t_ac_pt, ln_s_pt, ln_c_pt, le_c_pt, h_c_pt, le_s_pt, h_s_pt, g_pt,\n r_s_pt, r_x_pt, r_a_pt, u_friction_pt, lmo_pt, n_iterations_pt] = TSEB.TSEB_PT(                                                     \n     lst,\n     vza,\n     ec[\"TA\"].values,\n     ec[\"WS\"].values,\n     ec[\"EA\"].values,\n     ec[\"PA\"].values,\n     sn_c,\n     sn_s,\n     ec[\"LW_IN\"].values,\n     ec[\"LAI\"].values,\n     h_c,\n     e_v,\n     e_s,\n     z_0m,\n     d_0,\n     zm,\n     zh,\n     x_LAD=np.ones_like(lst),\n     f_c=f_c,\n     f_g=np.ones_like(lst),\n     w_C=w_c_ratio,\n     leaf_width=leaf_width,\n     z0_soil=z0_soil,\n     alpha_PT=alpha_PT_0,\n     resistance_form=resistance_flag,\n     calcG_params=[[1], 0.35])\n\n# ... and we compute the bulk fluxes\nle_pt = le_c_pt + le_s_pt\nh_pt = h_c_pt + h_s_pt\nnetrad_pt = sn_c + sn_s + ln_c_pt + ln_s_pt\n\n","type":"content","url":"/b02-tseb-sw#id-and-to-compare-we-also-run-tseb-pt","position":39},{"hierarchy":{"lvl1":"Shuttleworth-Wallace TSEB in advective conditions","lvl4":"... and with TSEB-PM","lvl3":"We run now TSEB-SW","lvl2":"Implementation with actual data in pyTSEB"},"type":"lvl4","url":"/b02-tseb-sw#id-and-with-tseb-pm","position":40},{"hierarchy":{"lvl1":"Shuttleworth-Wallace TSEB in advective conditions","lvl4":"... and with TSEB-PM","lvl3":"We run now TSEB-SW","lvl2":"Implementation with actual data in pyTSEB"},"content":"\n\n# Run TSEB-PT\nr_c_min = rst_min / ec[\"LAI\"].values\n[flag_pm, ts_pm, tc_pm, t_ac_pm, ln_s_pm, ln_c_pm, le_c_pm, h_c_pm, le_s_pm, h_s_pm, g_pm,\n r_s_pm, r_x_pm, r_a_pm, u_friction_pm, lmo_pm, n_iterations_pm] = TSEB.TSEB_PM(                                                     \n     lst,\n     vza,\n     ec[\"TA\"].values,\n     ec[\"WS\"].values,\n     ec[\"EA\"].values,\n     ec[\"PA\"].values,\n     sn_c,\n     sn_s,\n     ec[\"LW_IN\"].values,\n     ec[\"LAI\"].values,\n     h_c,\n     e_v,\n     e_s,\n     z_0m,\n     d_0,\n     zm,\n     zh,\n     x_LAD=np.ones_like(lst),\n     f_c=f_c,\n     f_g=np.ones_like(lst),\n     w_C=w_c_ratio,\n     leaf_width=leaf_width,\n     z0_soil=z0_soil,\n     r_c_min=r_c_min,\n     resistance_form=resistance_flag,\n     calcG_params=[[1], 0.35])\n\n# ... and we compute the bulk fluxes\nle_pm = le_c_pm + le_s_pm\nh_pm = h_c_pm + h_s_pm\nnetrad_pm = sn_c + sn_s + ln_c_pm + ln_s_pm\n\n","type":"content","url":"/b02-tseb-sw#id-and-with-tseb-pm","position":41},{"hierarchy":{"lvl1":"Shuttleworth-Wallace TSEB in advective conditions","lvl3":"Finally we compare the different retrievals","lvl2":"Implementation with actual data in pyTSEB"},"type":"lvl3","url":"/b02-tseb-sw#finally-we-compare-the-different-retrievals","position":42},{"hierarchy":{"lvl1":"Shuttleworth-Wallace TSEB in advective conditions","lvl3":"Finally we compare the different retrievals","lvl2":"Implementation with actual data in pyTSEB"},"content":"Select which method of EB correction you want to apply during the validation:\n\nw_ebc = widgets.Dropdown(\n    options=[('No EB correction', (\"LE\", \"H\")), \n             ('Residual to LE', (\"LE_RES\", \"H\")), \n             ('Residual to H', (\"LE_RES\", \"H\")), \n             ('Bowen Ratio', (\"LE_BR\", \"H_BR\")),\n             ('Ensemble correction', (\"LE_ENS\", \"H_ENS\"))],\n    value=(\"LE_ENS\", \"H_ENS\"),\n    description='EBC method:',\n)\ndisplay(w_ebc)\n\nfrom model_evaluation import double_collocation as dc\nfrom tabulate import tabulate\nLE_OBS, H_OBS = w_ebc.value\nprint(f\"Using {LE_OBS} and {H_OBS} fields for validating respectively  LE and H\")\n\nle_marker = {\"color\": \"blue\", \"size\": 3}\nh_marker = {\"color\": \"red\", \"size\": 3}\ng_marker = {\"color\": \"green\", \"size\": 3}\nrn_marker = {\"color\": \"black\", \"size\": 3}\n\nfig = make_subplots(rows=1, cols=3,\n                    shared_yaxes=True,\n                    horizontal_spacing=0.01,\n                   subplot_titles=(\"TSEB-SW\", \"TSEB-PT\", \"TSEB-PM\"))\n\nvalid_sw = np.logical_and(flag_sw < 5, daytime)\nvalid_pt = np.logical_and(flag_pt < 5, daytime)\nvalid_pm = np.logical_and(flag_pm < 5, daytime)\n\n\nfig.add_trace(go.Scattergl(x=netrad_sw[valid_sw], y=ec.loc[valid_sw, \"NETRAD\"], \n                         name=\"Rn TSEB-SW\", mode=\"markers\", marker=rn_marker),\n             row=1, col=1)\n\nfig.add_trace(go.Scattergl(x=netrad_pt[valid_pt], y=ec.loc[valid_pt, \"NETRAD\"], \n                         name=\"Rn TSEB-PT\", mode=\"markers\", marker=rn_marker),\n             row=1, col=2)\n\nfig.add_trace(go.Scattergl(x=netrad_pm[valid_pm], y=ec.loc[valid_pm, \"NETRAD\"], \n                         name=\"Rn TSEB-Pm\", mode=\"markers\", marker=rn_marker),\n             row=1, col=3)\n\nfig.add_trace(go.Scattergl(x=g_sw[valid_sw], y=ec.loc[valid_sw, \"G\"], \n                         name=\"G TSEB-SW\", mode=\"markers\", marker=g_marker),\n             row=1, col=1)\n\nfig.add_trace(go.Scattergl(x=g_pt[valid_pt], y=ec.loc[valid_pt, \"G\"], \n                         name=\"G TSEB-PT\", mode=\"markers\", marker=g_marker),\n             row=1, col=2)\n\nfig.add_trace(go.Scattergl(x=g_pm[valid_pm], y=ec.loc[valid_pm, \"G\"], \n                         name=\"G TSEB-PM\", mode=\"markers\", marker=g_marker),\n             row=1, col=3)\n\nfig.add_trace(go.Scattergl(x=le_sw[valid_sw], y=ec.loc[valid_sw, LE_OBS], \n                         name=\"LE TSEB-SW\", mode=\"markers\", marker=le_marker),\n             row=1, col=1)\n\nfig.add_trace(go.Scattergl(x=le_pt[valid_pt], y=ec.loc[valid_pt, LE_OBS], \n                         name=\"LE TSEB-PT\", mode=\"markers\", marker=le_marker),\n             row=1, col=2)\n\nfig.add_trace(go.Scattergl(x=le_pm[valid_pm], y=ec.loc[valid_pm, LE_OBS], \n                         name=\"LE TSEB-Pm\", mode=\"markers\", marker=le_marker),\n             row=1, col=3)\n\nfig.add_trace(go.Scattergl(x=h_sw[valid_sw], y=ec.loc[valid_sw, H_OBS], \n                         name=\"H TSEB-SW\", mode=\"markers\", marker=h_marker),\n             row=1, col=1)\n\nfig.add_trace(go.Scattergl(x=h_pt[valid_pt], y=ec.loc[valid_pt, H_OBS], \n                         name=\"H TSEB-PT\", mode=\"markers\", marker=h_marker),\n             row=1, col=2)\n\nfig.add_trace(go.Scattergl(x=h_pm[valid_pm], y=ec.loc[valid_pm, H_OBS], \n                         name=\"H TSEB-PM\", mode=\"markers\", marker=h_marker),\n             row=1, col=3)\n\nfig.add_trace(go.Scatter(x=[-200, 800], y=[-200, 800], mode=\"lines\", name=\"1:1 line\", line={\"color\": \"black\", \"dash\": \"dash\"}),\n             row=1, col=1)\nfig.add_trace(go.Scatter(x=[-200, 800], y=[-200, 800], mode=\"lines\", name=\"1:1 line\", line={\"color\": \"black\", \"dash\": \"dash\"}),\n             row=1, col=2)\nfig.add_trace(go.Scatter(x=[-200, 800], y=[-200, 800], mode=\"lines\", name=\"1:1 line\", line={\"color\": \"black\", \"dash\": \"dash\"}),\n             row=1, col=3)\n\n\nfig.update_layout(title_text=f\"Observed vs. Estimated fluxes at {w_site.label}\",\n                  yaxis_range=[-200, 800], xaxis_range=[-200, 800], \n                  xaxis_title=\"Estimated (W m-2)\", yaxis_title=\"Observed (W m-2)\")\n\n\n","type":"content","url":"/b02-tseb-sw#finally-we-compare-the-different-retrievals","position":43},{"hierarchy":{"lvl1":"Shuttleworth-Wallace TSEB in advective conditions","lvl4":"Evaluate the errors in H and LE","lvl3":"Finally we compare the different retrievals","lvl2":"Implementation with actual data in pyTSEB"},"type":"lvl4","url":"/b02-tseb-sw#evaluate-the-errors-in-h-and-le","position":44},{"hierarchy":{"lvl1":"Shuttleworth-Wallace TSEB in advective conditions","lvl4":"Evaluate the errors in H and LE","lvl3":"Finally we compare the different retrievals","lvl2":"Implementation with actual data in pyTSEB"},"content":"In this last step you can evaluate the error metric for both TSEB-SW and TSEB-PT models. In addition, you can filter by observed values of sensible heat flux to see better the performance of both models under advective condition, such as negative H at daytime.\n\nw_h_lims = widgets.IntRangeSlider(value=[-200, 800], min=-200, max=800, step=1, description='Validate on a range for H:', \n                                  style={'description_width': 'auto'}, layout=widgets.Layout(width='50%'))\ndisplay(w_h_lims)\n\n\nvalid_sw_2 = np.logical_and.reduce((valid_sw, ec[H_OBS] >= w_h_lims.value[0], ec[H_OBS] <= w_h_lims.value[1]))\nvalid_pt_2 = np.logical_and.reduce((valid_pt, ec[H_OBS] >= w_h_lims.value[0], ec[H_OBS] <= w_h_lims.value[1]))\nvalid_pm_2 = np.logical_and.reduce((valid_pm, ec[H_OBS] >= w_h_lims.value[0], ec[H_OBS] <= w_h_lims.value[1]))\n\n\nh_sw_bias, h_sw_mae, h_sw_rmse = dc.error_metrics(ec.loc[valid_sw_2, H_OBS].values, h_sw[valid_sw_2])\nh_pt_bias, h_pt_mae, h_pt_rmse = dc.error_metrics(ec.loc[valid_pt_2, H_OBS].values, h_pt[valid_pt_2])\nh_pm_bias, h_pm_mae, h_pm_rmse = dc.error_metrics(ec.loc[valid_pm_2, H_OBS].values, h_pm[valid_pm_2])\nle_sw_bias, le_sw_mae, le_sw_rmse = dc.error_metrics(ec.loc[valid_sw_2, LE_OBS].values, le_sw[valid_sw_2])\nle_pt_bias, le_pt_mae, le_pt_rmse = dc.error_metrics(ec.loc[valid_pt_2, LE_OBS].values,le_pt[valid_pt_2])\nle_pm_bias, le_pm_mae, le_pm_rmse = dc.error_metrics(ec.loc[valid_pm_2, LE_OBS].values,le_pm[valid_pm_2])\n\nh_sw_cor, h_sw_p_value, h_sw_slope, h_sw_intercept, h_sw_d = dc.agreement_metrics(ec.loc[valid_sw_2, H_OBS].values, \n                                                                                  h_sw[valid_sw_2])\nh_pt_cor, h_pt_p_value, h_pt_slope, h_pt_intercept, h_pt_d = dc.agreement_metrics(ec.loc[valid_pt_2, H_OBS].values, \n                                                                                  h_pt[valid_pt_2])\nh_pm_cor, h_pm_p_value, h_pm_slope, h_pm_intercept, h_pm_d = dc.agreement_metrics(ec.loc[valid_pm_2, H_OBS].values, \n                                                                                  h_pm[valid_pm_2])\n\nle_sw_cor, le_sw_p_value, le_sw_slope, le_sw_intercept, le_sw_d = dc.agreement_metrics(ec.loc[valid_sw_2, LE_OBS].values, \n                                                                                       le_sw[valid_sw_2])\nle_pt_cor, le_pt_p_value, le_pt_slope, le_pt_intercept, le_pt_d = dc.agreement_metrics(ec.loc[valid_pt_2, LE_OBS].values, \n                                                                                       le_pt[valid_pt_2])\nle_pm_cor, le_pm_p_value, le_pm_slope, le_pm_intercept, le_pm_d = dc.agreement_metrics(ec.loc[valid_pm_2, LE_OBS].values, \n                                                                                       le_pm[valid_pm_2])\n\ntable_h = [[\"bias\", h_sw_bias, h_pt_bias, h_pm_bias],\n         [\"RMSE\", h_sw_rmse, h_pt_rmse, h_pm_rmse],\n         [\"MAE\", h_sw_mae, h_pt_mae, h_pm_mae],\n         [\"Pearson\", h_sw_cor, h_pt_cor, h_pm_cor],\n         [\"Willmot's d\", h_sw_d, h_pt_d, h_pm_d]]\nprint(\"Error metrics for sensible heat flux\")\nprint(tabulate(table_h, headers=[\"Metric\", \"TSEB-SW\", \"TSEB-PT\", \"TSEB-PM\"]))\n\ntable_le = [[\"bias\", le_sw_bias, le_pt_bias, le_pm_bias],\n         [\"RMSE\", le_sw_rmse, le_pt_rmse, le_pm_rmse],\n         [\"MAE\", le_sw_mae, le_pt_mae, le_pm_mae],\n         [\"Pearson\", le_sw_cor, le_pt_cor, le_pm_cor],\n         [\"Willmot's d\", le_sw_d, le_pt_d, le_pm_d]]\n\nprint(\"\\n=======================================\\n\")\nprint(\"Error metrics for latent heat flux\")\nprint(tabulate(table_le, headers=[\"Metric\", \"TSEB-SW\", \"TSEB-PT\", \"TSEB-PM\"]))\n\n","type":"content","url":"/b02-tseb-sw#evaluate-the-errors-in-h-and-le","position":45},{"hierarchy":{"lvl1":"Shuttleworth-Wallace TSEB in advective conditions","lvl3":"We save the results to ASCII tables","lvl2":"Implementation with actual data in pyTSEB"},"type":"lvl3","url":"/b02-tseb-sw#we-save-the-results-to-ascii-tables","position":46},{"hierarchy":{"lvl1":"Shuttleworth-Wallace TSEB in advective conditions","lvl3":"We save the results to ASCII tables","lvl2":"Implementation with actual data in pyTSEB"},"content":"\n\n# Define the output filename\nout_dir = Path().absolute() / \"output\"\noutfile = out_dir / f\"FLX_US-{w_site.value}_FLUXNET2015_TSEB-PT-ROWS_HR.csv\"\n\n# Create the output folder in case it does not exist\nif not out_dir.exists():\n    out_dir.mkdir(parents=True)\n\n# Convert the outputs to a Python dictionary\noutdict = {\"TIMESTAMP\": ec[\"TIMESTAMP\"].dt.strftime(\"%Y%m%d%H%M\"),\n           \"FLAG_TSEBPT\": flag_pt, \"LE_TSEBPT\": le_pt, \"H_TSEBPT\": h_pt, \"NETRAD_TSEBPT\": netrad_pt, \"G_TSEBPT\": g_pt, \n           \"T_S_TSEBPT\": ts_pt, \"T_C_TSEBPT\": tc_pt, \"T_AC_TSEBPT\": t_ac_pt, \"LN_S_TSEBPT\": ln_s_pt, \"LN_C_TSEBPT\": ln_c_pt, \n           \"LE_C_TSEBPT\": le_c_pt, \"H_C_TSEBPT\": h_c_pt, \"LE_S_TSEBPT\": le_s_pt, \"H_S_TSEBPT\": h_s_pt, \"R_S_TSEBPT\": r_s_pt, \n           \"R_X_TSEBPT\": r_x_pt, \"R_A_TSEBPT\": r_a_pt, \"USTAR_TSEBPT\": u_friction_pt, \"L_MO_TSEBPT\":lmo_pt, \n           \"ITERATIONS_TSEBPT\": n_iterations_pt}\n\n# Crete the output dataframe and save it to csv\npd.DataFrame(outdict).to_csv(outfile, sep=\";\", na_rep=-9999, index=False)\nprint(f\"Saved to {outfile}\")\n\n# Define the output filename\noutfile = out_dir / f\"FLX_US-{w_site.value}_FLUXNET2015_TSEB-SW-ROWS_HR.csv\"\n\n# Convert the outputs to a Python dictionary\noutdict = {\"TIMESTAMP\": ec[\"TIMESTAMP\"].dt.strftime(\"%Y%m%d%H%M\"),\n           \"FLAG_TSEBSW\": flag_sw, \"LE_TSEBSW\": le_sw, \"H_TSEBSW\": h_sw, \"NETRAD_TSEBSW\": netrad_sw, \"G_TSEBSW\": g_sw, \n           \"T_S_TSEBSW\": ts_sw, \"T_C_TSEBSW\": tc_sw, \"T_AC_TSEBSW\": t_ac_sw, \"LN_S_TSEBSW\": ln_s_sw, \"LN_C_TSEBSW\": ln_c_sw, \n           \"LE_C_TSEBSW\": le_c_sw, \"H_C_TSEBSW\": h_c_sw, \"LE_S_TSEBSW\": le_s_sw, \"H_S_TSEBSW\": h_s_sw, \"R_S_TSEBSW\": r_s_sw, \n           \"R_X_TSEBSW\": r_x_sw, \"R_A_TSEBSW\": r_a_sw, \"USTAR_TSEBSW\": u_friction_sw, \"L_MO_TSEBSW\":lmo_sw, \n           \"ITERATIONS_TSEBSW\": n_iterations_sw}\n\n# Crete the output dataframe and save it to csv\npd.DataFrame(outdict).to_csv(outfile, sep=\";\", na_rep=-9999, index=False)\nprint(f\"Saved to {outfile}\")\n\n# Define the output filename\noutfile = out_dir / f\"FLX_US-{w_site.value}_FLUXNET2015_TSEB-PM-ROWS_HR.csv\"\n\n# Convert the outputs to a Python dictionary\noutdict = {\"TIMESTAMP\": ec[\"TIMESTAMP\"].dt.strftime(\"%Y%m%d%H%M\"),\n           \"FLAG_TSEBPM\": flag_pm, \"LE_TSEBPM\": le_pm, \"H_TSEBPM\": h_pm, \"NETRAD_TSEBPM\": netrad_pm, \"G_TSEBPM\": g_pm, \n           \"T_S_TSEBPM\": ts_pm, \"T_C_TSEBPM\": tc_pm, \"T_AC_TSEBPM\": t_ac_pm, \"LN_S_TSEBPM\": ln_s_pm, \"LN_C_TSEBPM\": ln_c_pm, \n           \"LE_C_TSEBPM\": le_c_pm, \"H_C_TSEBPM\": h_c_pm, \"LE_S_TSEBPM\": le_s_pm, \"H_S_TSEBPM\": h_s_pm, \"R_S_TSEBPM\": r_s_pm, \n           \"R_X_TSEBPM\": r_x_pm, \"R_A_TSEBPM\": r_a_pm, \"USTAR_TSEBPM\": u_friction_pm, \"L_MO_TSEBPM\":lmo_pm, \n           \"ITERATIONS_TSEBPM\": n_iterations_pm}\n\n# Crete the output dataframe and save it to csv\npd.DataFrame(outdict).to_csv(outfile, sep=\";\", na_rep=-9999, index=False)\nprint(f\"Saved to {outfile}\")\n\n","type":"content","url":"/b02-tseb-sw#we-save-the-results-to-ascii-tables","position":47},{"hierarchy":{"lvl1":"Shuttleworth-Wallace TSEB in advective conditions","lvl2":"Conclusions"},"type":"lvl2","url":"/b02-tseb-sw#conclusions","position":48},{"hierarchy":{"lvl1":"Shuttleworth-Wallace TSEB in advective conditions","lvl2":"Conclusions"},"content":"TSEB-SW seems to outperform TSEB-PT under advective conditions/sites with negative sensible heat fluxes at daytime\n\nHowever, TSEB-SW requires additional parametrization: minimuim stomata resistance and its relationship to the environmental conditions\n\nBoth TSEB-PT and TSEB-SW seems to produce larger errors in Barelli 007, and Barelli 012*\n\n[...]\n\nNote\n\nPlease feel free comment any thoughts. This is work in progress!!!","type":"content","url":"/b02-tseb-sw#conclusions","position":49},{"hierarchy":{"lvl1":"Corregistration of UAV mosaics"},"type":"lvl1","url":"/b03-mosaics-corregistration","position":0},{"hierarchy":{"lvl1":"Corregistration of UAV mosaics"},"content":"","type":"content","url":"/b03-mosaics-corregistration","position":1},{"hierarchy":{"lvl1":"Corregistration of UAV mosaics","lvl2":"Summary"},"type":"lvl2","url":"/b03-mosaics-corregistration#summary","position":2},{"hierarchy":{"lvl1":"Corregistration of UAV mosaics","lvl2":"Summary"},"content":"This interactive Jupyter Notebook has the objective of showing one prototype method that automates the search of Ground Control Points between two UAV mosaics.\n\n","type":"content","url":"/b03-mosaics-corregistration#summary","position":3},{"hierarchy":{"lvl1":"Corregistration of UAV mosaics","lvl2":"Instructions"},"type":"lvl2","url":"/b03-mosaics-corregistration#instructions","position":4},{"hierarchy":{"lvl1":"Corregistration of UAV mosaics","lvl2":"Instructions"},"content":"Read carefully all the text and follow the instructions.\n\nOnce each section is read, run the jupyter code cell underneath (marked as In []) by clicking the icon Run, or pressing the keys SHIFT+ENTER of your keyboard. A graphical interface will then display, which allows you to interact with and perform the assigned tasks.\n\nTo start, please run the following cell to import all the packages required for this notebook. Once you run the cell below, an acknowledgement message, stating all libraries were correctly imported, should be printed on screen.\n\n%matplotlib inline\nfrom pathlib import Path\nfrom ipywidgets import interact, interactive, fixed, widgets\nfrom IPython.display import display\nimport numpy as np\nprint(\"Libraries imported correctly, you can continue to the next cells\")\n\n","type":"content","url":"/b03-mosaics-corregistration#instructions","position":5},{"hierarchy":{"lvl1":"Corregistration of UAV mosaics","lvl2":"Corregistering orthomosaics"},"type":"lvl2","url":"/b03-mosaics-corregistration#corregistering-orthomosaics","position":6},{"hierarchy":{"lvl1":"Corregistration of UAV mosaics","lvl2":"Corregistering orthomosaics"},"content":"In the previous exercise we saw how important is having well collocated UAV mosaicks between the TIR and spectral cameras. Not only for accurately extracting the soil and canopy temperatures, but for later be able to robustly parse the different canopy tratis and radiometric temperatures in TSEB.\n\nAlthouh both phototgrametric software and UAV avionics/payloads have evolve a lot in the last years, it is not uncommon that the different orthomosaics generated from the different payload cameras do not perfectly match. This would involve the manual tasks of adding Ground Control Points, either with targets placed on ground or by indentifying distinctive patters in each mosaick.\n\nImportant\n\nThis task can be tedious and time consuming, thus it woulc preclude the use of UAV imager in operational and/or near-real-time services.","type":"content","url":"/b03-mosaics-corregistration#corregistering-orthomosaics","position":7},{"hierarchy":{"lvl1":"Corregistration of UAV mosaics","lvl2":"The gcp_tools in GitHub airborne_tools package"},"type":"lvl2","url":"/b03-mosaics-corregistration#the-gcp-tools-in-github-airborne-tools-package","position":8},{"hierarchy":{"lvl1":"Corregistration of UAV mosaics","lvl2":"The gcp_tools in GitHub airborne_tools package"},"content":"For that reason, we have developed a prototype that aims to automatize the corregistration of orthomosaics. This prototype aims to collocate an orthomosaic (from now on we will call it the slave) over another orthomosaic or image that is considered as reference.\n\nHint\n\nThe reference image can be a well georreferenced orthomosaic such as an RGB UAV mosaic, an aerial orthoimage or any other dataset. Indeed the scale/resolution between the reference and the slave mosaic to be collocated does not need to be the same\n\nBasically we are using SIFT \n\nLowe, 2004 algorithm to find relevant features in each image, followed by FLANN \n\nMuja & Lowe, 2014 algorithm to evaluate the similarities of features between both images (reference and slave) and find feature mathing in both images, which will be the ones considered as potential Ground Control Points (GCPs).\n\nNote\n\nIndeed SIFT+FLANN are the typical algorithms that photogrammetric software uses to peform the matching and overlapping between snapshots, pior to building the photogrammetric point cloud.","type":"content","url":"/b03-mosaics-corregistration#the-gcp-tools-in-github-airborne-tools-package","position":9},{"hierarchy":{"lvl1":"Corregistration of UAV mosaics","lvl3":"Dataset","lvl2":"The gcp_tools in GitHub airborne_tools package"},"type":"lvl3","url":"/b03-mosaics-corregistration#dataset","position":10},{"hierarchy":{"lvl1":"Corregistration of UAV mosaics","lvl3":"Dataset","lvl2":"The gcp_tools in GitHub airborne_tools package"},"content":"For this exercise we will use the test example of \n\nairborne_tools package. The data is already located at the \n\n./input/UAV folder. It consists of a UAV flight over an experimental vineyard located near Madrid (Spain) that acquired (among others):\n\nA multispectral image (\n\nSequoia​_vnir​_20220916​.tif) with the following bands:\n\nGreen\n\nRed\n\nRed-edge\n\nNear Infrared\n\nA thermal image (\n\ntir​_odm​_20220916​.tif)with temperatures in Kelvin, scaled by a factor of 100\n\nWe recommend you to open both images in QGIS to better browse them and be aware of the lack of corregistration between mosaics.\n\nHint\n\nYou can use the cars/pannels in the upper part of the scene as reference.\n\nEven the UAV was equipped with a RTK differential GPS and Ground Control Points were place on ground, you can still see some some displacements between mosaics.","type":"content","url":"/b03-mosaics-corregistration#dataset","position":11},{"hierarchy":{"lvl1":"Corregistration of UAV mosaics","lvl3":"Preprocess the mosaics","lvl2":"The gcp_tools in GitHub airborne_tools package"},"type":"lvl3","url":"/b03-mosaics-corregistration#preprocess-the-mosaics","position":12},{"hierarchy":{"lvl1":"Corregistration of UAV mosaics","lvl3":"Preprocess the mosaics","lvl2":"The gcp_tools in GitHub airborne_tools package"},"content":"As an optional step we could do is to preprocess the mosaics. Either the reference or the slave. This could be usefull for multidimensional imagery such as multispectral/hyperspectral data, since SIFT algorithm only works for single-band grayscale or RGB pictures.\n\nFor this case we will reduce the multispectral reference scene to a single band brightness image, by applying a Principal Component Analysis, and selecting the first PCA, since this is the one that will\n\nOr any other geospatial raster image such as satellite imagery.\n\nfrom airborne_tools import image_preprocessing as img\n\n# Set the input folder location and raw VNIR and output PCA single-band image\nworkdir = Path()\ntest_dir = workdir / \"input\" / \"UAV\"\n\n# Set the path to the input LST and VNIR images\nlst_file = test_dir / 'tir_odm_20220916.tif'\nvnir_image = test_dir / 'Sequoia_vnir_20220916.tif'\npca_image = test_dir / 'Sequoia_vnir_20220916_PC1.tif'\n\n# Set the nodata of the VNIR imager\nno_data=4294967296\n\n# We will use all the VNIR bands (4) to create the PCA image\nvnir_bands = [0, 1, 2, 3]\n\n# And we will save only the first PC band, considering that this component \npca_components = 1\n# We need to reduce the dimensionality of the master image to a single grayscale band.\n# We therefore apply a PCA reduction to get a grayscale image combining all spectral bands\nif not pca_image.exists():\n    img.pca(vnir_image,\n            no_data=no_data,\n            use_bands=vnir_bands,\n            pca_components=pca_components,\n            outfile=pca_image,\n            normalize=True)\n\nprint(f\"Created VNIR PCA image at {pca_image}\")\n\nSee Also\n\nYou can check the \n\nPCA image reduction GitHub source code","type":"content","url":"/b03-mosaics-corregistration#preprocess-the-mosaics","position":13},{"hierarchy":{"lvl1":"Corregistration of UAV mosaics","lvl4":"Visualize both grayscale images","lvl3":"Preprocess the mosaics","lvl2":"The gcp_tools in GitHub airborne_tools package"},"type":"lvl4","url":"/b03-mosaics-corregistration#visualize-both-grayscale-images","position":14},{"hierarchy":{"lvl1":"Corregistration of UAV mosaics","lvl4":"Visualize both grayscale images","lvl3":"Preprocess the mosaics","lvl2":"The gcp_tools in GitHub airborne_tools package"},"content":"You can now visualized the grayscale images for both the reference VNIR PCA1 and the slave LST.\n\nNote\n\nYou can also use QGIS to better visualize both images and confirm the corregistration issues between mosaics.\n\nfrom osgeo import gdal\nfrom bokeh.plotting import *\nfrom bokeh import palettes as pal\nfrom bokeh.models.mappers import LinearColorMapper\nfrom bokeh.io import output_notebook\nfrom bokeh.resources import INLINE\noutput_notebook(resources=INLINE)\n\n# Open and read the LST file\nfid = gdal.Open(lst_file, gdal.GA_ReadOnly)\nlst = fid.GetRasterBand(1).ReadAsArray().astype(float)\n# Set LST NaN\nlst_no_data = 65535\nlst[lst == lst_no_data] = np.nan\n# Open and read the NDVI file\nfid = gdal.Open(pca_image, gdal.GA_ReadOnly)\npca = fid.GetRasterBand(1).ReadAsArray()\nmaster_geo = fid.GetGeoTransform()\ndel fid\n\nrows, cols = int(0.3 * lst.shape[0]), int(0.3 * lst.shape[1])\ns1 = figure(title=\"LST\", width=cols, height=rows, x_range=[0, cols], y_range=[0, rows])\ns1.axis.visible = False\ns1.image(image=[np.flipud(lst)], x=[0], y=[0], dw=cols, dh=rows)\ns2= figure(title=\"VNIR PCA1\", width=cols, height=rows, x_range=s1.x_range, y_range=s1.y_range)\ns2.axis.visible = False\ns2.image(image=[np.flipud(pca)], x=[0], y=[0], dw=[cols], dh=[rows])\n\np = gridplot([[s1], [s2]], toolbar_location='above')\nshow(p)\n\nLook that the brightness patters seems to overal match, which will help SIFT+FLANN to find the matheces.\nFor instance,  within the grapevine that the brightest vines in the the LST (warmer temperatures) match with the lowest brighness in the PCA, these areas were under a more stressed deficit irrigation and thus both temperatures. However, some other areas have opposite brighness, such as the calibration pannels placed on top of the scenes, the warmest pannels (brightest in LST) are however the darkest (black painted) in the VNIR PCA1.","type":"content","url":"/b03-mosaics-corregistration#visualize-both-grayscale-images","position":15},{"hierarchy":{"lvl1":"Corregistration of UAV mosaics","lvl3":"Run SIFT + FLANN","lvl2":"The gcp_tools in GitHub airborne_tools package"},"type":"lvl3","url":"/b03-mosaics-corregistration#run-sift-flann","position":16},{"hierarchy":{"lvl1":"Corregistration of UAV mosaics","lvl3":"Run SIFT + FLANN","lvl2":"The gcp_tools in GitHub airborne_tools package"},"content":"Now that we have the data preprocess, we can run our SIFT and FLANN algorithms to find common features that we will be considered as potential GCPs. For this task we will use the powerful [OpenvCV] library, available in Python, which, among many others, contains SIFT and FLANN methods:\n\nalso in C++ and Java\n\n# Import Python OpenCV\nimport cv2\n# matching factor between keypoint descriptor\nmatch_factor = 0.80 \n\n# SIFT and FLANN needs to deal with 8bit images, so we need to rescale the floaging point input to 0-255 bit range\nmaster_scaled = img.scale_grayscale_image(pca, no_data=np.nan)\nslave_scaled = img.scale_grayscale_image(lst, no_data=np.nan)\n\n# Get the LST (slave) GDAL geotransform and projection\nfid = gdal.Open(lst_file, gdal.GA_ReadOnly)\nslave_geo = fid.GetGeoTransform()\nproj = fid.GetProjection()\ndel fid\n# Get the VNIR (master) GDAL geotransform and projection\nfid = gdal.Open(pca_image, gdal.GA_ReadOnly)\nmaster_geo = fid.GetGeoTransform()\nproj = fid.GetProjection()\ndel fid\n\n# Initiate SIFT detector\ndetector = cv2.SIFT_create()\n# We use NORM distance measurement for SIFT\nnorm_type = cv2.NORM_L1\n\nprint(\"Finding features and their descriptors, this might take a while...\")\nkp_master, des_master = detector.detectAndCompute(master_scaled, None)\nkp_slave, des_slave = detector.detectAndCompute(slave_scaled, None)\n\n# Find matches between slave and master descriptors\nmatcher = cv2.BFMatcher(norm_type)\n# Get the 2 best matches per feature\nmatches = matcher.knnMatch(des_master, des_slave, k=2)\n\nprint(f\"Found {len(matches)}, filtering by FLANN factor similarity of {match_factor}\")\n# Create a list of potential GCPs\ngcp_list = []\ngood_matches = []\nfor i, (m, n) in enumerate(matches):\n    # Only the most similar matches, based on FLANN match factor, are selected\n    if m.distance < match_factor * n.distance:\n        good_matches.append(m)\n        master_pt = np.float32(kp_master[m.queryIdx].pt)\n        # Get the projected map coordinates (X, Y) of the master\n        x_master, y_master = img.get_map_coordinates(float(master_pt[1]),\n                                                     float(master_pt[0]),\n                                                     master_geo)\n        # Get the image coordinates (row, col) of the slave\n        slave_pt = np.float32(kp_slave[m.trainIdx].pt)\n        gcp_list.append((x_master,\n                         y_master,\n                         float(slave_pt[1]),\n                         float(slave_pt[0])))\n\nprint(f\"Found {len(gcp_list)} potential GCPs\")\n\n","type":"content","url":"/b03-mosaics-corregistration#run-sift-flann","position":17},{"hierarchy":{"lvl1":"Corregistration of UAV mosaics","lvl4":"Visualize the potential GCP","lvl3":"Run SIFT + FLANN","lvl2":"The gcp_tools in GitHub airborne_tools package"},"type":"lvl4","url":"/b03-mosaics-corregistration#visualize-the-potential-gcp","position":18},{"hierarchy":{"lvl1":"Corregistration of UAV mosaics","lvl4":"Visualize the potential GCP","lvl3":"Run SIFT + FLANN","lvl2":"The gcp_tools in GitHub airborne_tools package"},"content":"We can now visualize all the matches found by SIFT+FLANN, according to the resemblance ratio we have just set:\n\nfrom matplotlib import pyplot as plt\n#-- Draw matches\nimg_matches = np.empty((max(slave_scaled.shape[0], master_scaled.shape[0]), \n                        slave_scaled.shape[1] + master_scaled.shape[1], 3), \n                       dtype=np.uint8)\ncv2.drawMatches(master_scaled, kp_master, slave_scaled, kp_slave, good_matches, img_matches,\n                matchesThickness=10, flags=cv2.DrawMatchesFlags_NOT_DRAW_SINGLE_POINTS)\n#-- Show detected matches\nplt.imshow(img_matches)\nplt.show()\n\n","type":"content","url":"/b03-mosaics-corregistration#visualize-the-potential-gcp","position":19},{"hierarchy":{"lvl1":"Corregistration of UAV mosaics","lvl3":"Filter GCP by translation distance","lvl2":"The gcp_tools in GitHub airborne_tools package"},"type":"lvl3","url":"/b03-mosaics-corregistration#filter-gcp-by-translation-distance","position":20},{"hierarchy":{"lvl1":"Corregistration of UAV mosaics","lvl3":"Filter GCP by translation distance","lvl2":"The gcp_tools in GitHub airborne_tools package"},"content":"Since we assume that a priori both orthomosaics were georreferenced, either the UAV avionics information, the use of in situ GCP, or both, we can consider that the displacment between the slave and the master should not be too large, and thus we could discard GCPs which translation vector is larger than a given distance\n\nHint\n\nFor instance we can assume that the UAV GPS could have an unsistematic error of 10m and thus the displacement between mosaics should not be larger than this distance.\n\nOr we can just browse both mosaics and evaluate the observed maximum displacement between mosaics\n\n# Set a maximum translation distance between slave and master\ndist_threshold = 10\n\n# Convert the list of potential GCPs to a numpy array to make computations more effective\ngcp_list = np.asarray(gcp_list)\n\nif len(gcp_list.shape) == 1:\n    gcp_list = gcp_list.reshape(1, -1)\n\n# Get the GCP map coordinates (X, Y) from the slave image coordinates\nx_slave, y_slave = img.get_map_coordinates(gcp_list[:, 2], gcp_list[:, 3], slave_geo)\n# Compute the the distance between the slave map coordinates and the master map coordinates for each GCP\ndist = np.sqrt((x_slave - gcp_list[:, 0]) ** 2 + (y_slave - gcp_list[:, 1]) ** 2)\n# Keep only those GCPs whose distance is lower than the threshold we set\ngcp_list = gcp_list[dist <= dist_threshold]\n# Convert back the list of GPC to a Python list\ngcp_list = gcp_list.tolist()\ngood_matches = np.array(good_matches)[dist <= dist_threshold].tolist()\nprint(f'Got {len(gcp_list)} valid GPCs with a translation lower than {dist_threshold}m')\n\n","type":"content","url":"/b03-mosaics-corregistration#filter-gcp-by-translation-distance","position":21},{"hierarchy":{"lvl1":"Corregistration of UAV mosaics","lvl4":"Visualize the potential GCP filtered by distance","lvl3":"Filter GCP by translation distance","lvl2":"The gcp_tools in GitHub airborne_tools package"},"type":"lvl4","url":"/b03-mosaics-corregistration#visualize-the-potential-gcp-filtered-by-distance","position":22},{"hierarchy":{"lvl1":"Corregistration of UAV mosaics","lvl4":"Visualize the potential GCP filtered by distance","lvl3":"Filter GCP by translation distance","lvl2":"The gcp_tools in GitHub airborne_tools package"},"content":"\n\ncv2.drawMatches(master_scaled, kp_master, slave_scaled, kp_slave, good_matches, img_matches,\n                matchesThickness=10, flags=cv2.DrawMatchesFlags_NOT_DRAW_SINGLE_POINTS)\n#-- Show detected matches\nplt.imshow(img_matches)\nplt.show()\n\nSee Also\n\nYou can check \n\nthis function in the GitHub source code","type":"content","url":"/b03-mosaics-corregistration#visualize-the-potential-gcp-filtered-by-distance","position":23},{"hierarchy":{"lvl1":"Corregistration of UAV mosaics","lvl3":"Remove GCPs that are too close each other","lvl2":"The gcp_tools in GitHub airborne_tools package"},"type":"lvl3","url":"/b03-mosaics-corregistration#remove-gcps-that-are-too-close-each-other","position":24},{"hierarchy":{"lvl1":"Corregistration of UAV mosaics","lvl3":"Remove GCPs that are too close each other","lvl2":"The gcp_tools in GitHub airborne_tools package"},"content":"On the other hand, we wanted to have well distributed GCPs across the whole image. Theferore we will discard GCPs that were very close to other GCPs, aiming to avoid overrepresnting one area over others:\n\n# Set minimum distance in pixels that GCPs should be from other GCPs\npixel_threshold = 5\n\ngcps_good = []\nmatches_good = []\nfor i, gcp_test in enumerate(gcp_list):\n    good = True\n    if i == len(gcp_list) - 2:\n        continue\n    for j in range(i + 1, len(gcp_list)):\n        dist = np.sqrt((gcp_test[2] - gcp_list[j][2]) ** 2 + (gcp_test[3] - gcp_list[j][3]) ** 2)\n        if dist < pixel_threshold:  # GCPs closer to each other are discarded to avoid overfitting\n            good = False\n            break\n    if good:\n        gcps_good.append(gcp_test)\n        matches_good.append(good_matches[i])\n\ngcp_list = list(gcps_good)\ngood_matches = list(matches_good)\nprint(f'Got {len(gcp_list)} valid GPCs far enough from each other by a distance of {dist_threshold} pixels')\n\n","type":"content","url":"/b03-mosaics-corregistration#remove-gcps-that-are-too-close-each-other","position":25},{"hierarchy":{"lvl1":"Corregistration of UAV mosaics","lvl4":"Visualize the filtered GCP","lvl3":"Remove GCPs that are too close each other","lvl2":"The gcp_tools in GitHub airborne_tools package"},"type":"lvl4","url":"/b03-mosaics-corregistration#visualize-the-filtered-gcp","position":26},{"hierarchy":{"lvl1":"Corregistration of UAV mosaics","lvl4":"Visualize the filtered GCP","lvl3":"Remove GCPs that are too close each other","lvl2":"The gcp_tools in GitHub airborne_tools package"},"content":"\n\ncv2.drawMatches(master_scaled, kp_master, slave_scaled, kp_slave, good_matches, img_matches,\n                matchesThickness=10, flags=cv2.DrawMatchesFlags_NOT_DRAW_SINGLE_POINTS)\n#-- Show detected matches\nplt.imshow(img_matches)\nplt.show()\n\nSee Also\n\nYou can check \n\nthis function in the GitHub source code","type":"content","url":"/b03-mosaics-corregistration#visualize-the-filtered-gcp","position":27},{"hierarchy":{"lvl1":"Corregistration of UAV mosaics","lvl3":"Remove GCPs that are outliers in a 3rd degree polynomial warp","lvl2":"The gcp_tools in GitHub airborne_tools package"},"type":"lvl3","url":"/b03-mosaics-corregistration#remove-gcps-that-are-outliers-in-a-3rd-degree-polynomial-warp","position":28},{"hierarchy":{"lvl1":"Corregistration of UAV mosaics","lvl3":"Remove GCPs that are outliers in a 3rd degree polynomial warp","lvl2":"The gcp_tools in GitHub airborne_tools package"},"content":"To finalize, we will discard all the GCPs that are outliers after fitting at 3rd degree polynomial warp\n\n# Set a warping error threshold of 2.5 cm\nwarp_threshold = 0.025\n\n# Convert the list of GPCs to a python numpy array to vectorize the calculations\ngcps = np.asarray(gcp_list)\ngood_matches = np.asarray(good_matches)\n\n# Create our 3rd degree polynomial warping helper function\ndef _fit_polynomial_warp(gcps):\n\n    gcps = np.asarray(gcps)\n    if gcps.shape[0] < 15:\n        return None, None\n    rows = gcps[:, 2]\n    cols = gcps[:, 3]\n    rows2 = rows ** 2\n    cols2 = cols ** 2\n    rowscols = rows * cols\n    rows2cols = rows ** 2 * cols\n    rowscols2 = rows * cols ** 2\n    rows3 = rows ** 3\n    cols3 = cols ** 3\n\n    x = np.matrix([np.ones(rows.shape), rows, cols, rowscols, rows2, cols2, rows2cols, rowscols2, rows3, cols3]).T\n    map_x = gcps[:, 0].reshape(-1, 1)\n    map_y = gcps[:, 1].reshape(-1, 1)\n    theta_x = (x.T * x).I * x.T * map_x\n    theta_y = (x.T * x).I * x.T * map_y\n    return np.asarray(theta_x).reshape(-1), np.asarray(theta_y).reshape(-1)\n\n\n# Create our helper function to compute the warping error for each GCP\ndef _calc_warp_erors(gcps, theta_x, theta_y):\n    def _polynomial_warp(rows, cols, theta_x, theta_y):\n        x = theta_x[0] + theta_x[1] * rows + theta_x[2] * cols + theta_x[3] * rows * cols + theta_x[4] * rows ** 2 + \\\n            theta_x[5] * cols ** 2 + theta_x[6] * rows ** 2 * cols + theta_x[7] * rows * cols ** 2 + \\\n            theta_x[8] * rows ** 3 + theta_x[9] * cols ** 3\n        y = theta_y[0] + theta_y[1] * rows + theta_y[2] * cols + theta_y[3] * rows * cols + theta_y[4] * rows ** 2 + \\\n            theta_y[5] * cols ** 2 + theta_y[6] * rows ** 2 * cols + theta_y[7] * rows * cols ** 2 + \\\n            theta_y[8] * rows ** 3 + theta_y[9] * cols ** 3\n        return x, y\n\n    gcps = np.asarray(gcps)\n    if len(gcps.shape) == 1:\n        gcps = gcps.reshape(1, -1)\n\n    rows = gcps[:, 2]\n    cols = gcps[:, 3]\n    x_model, y_model = _polynomial_warp(rows, cols, theta_x, theta_y)\n    error = np.sqrt((x_model - gcps[:, 0]) ** 2 + (y_model - gcps[:, 1]) ** 2)\n    return error\n\n# FIt a 3rd order polynomial warp\ntheta_x, theta_y = _fit_polynomial_warp(gcps)\nerror = _calc_warp_erors(gcps, theta_x, theta_y)\nwhile np.max(error) > warp_threshold and len(error) > 30:\n    index = error.argsort()[::-1]\n    gcps = gcps[index[1:]]\n    good_matches = good_matches[index[1:]]\n    theta_x, theta_y = _fit_polynomial_warp(gcps)\n    error = _calc_warp_erors(gcps, theta_x, theta_y)\n\ngcp_valid = list(gcps)\ngood_matches = list(good_matches)\nprint(f'Got {len(gcp_valid)} valid GPCs that fit well in a 3rd degree polynomial warp')\n\n","type":"content","url":"/b03-mosaics-corregistration#remove-gcps-that-are-outliers-in-a-3rd-degree-polynomial-warp","position":29},{"hierarchy":{"lvl1":"Corregistration of UAV mosaics","lvl4":"Visualize the filtered GCPs","lvl3":"Remove GCPs that are outliers in a 3rd degree polynomial warp","lvl2":"The gcp_tools in GitHub airborne_tools package"},"type":"lvl4","url":"/b03-mosaics-corregistration#visualize-the-filtered-gcps","position":30},{"hierarchy":{"lvl1":"Corregistration of UAV mosaics","lvl4":"Visualize the filtered GCPs","lvl3":"Remove GCPs that are outliers in a 3rd degree polynomial warp","lvl2":"The gcp_tools in GitHub airborne_tools package"},"content":"\n\ncv2.drawMatches(master_scaled, kp_master, slave_scaled, kp_slave, good_matches, img_matches,\n                matchesThickness=10, flags=cv2.DrawMatchesFlags_NOT_DRAW_SINGLE_POINTS)\n#-- Show detected matches\nplt.imshow(img_matches)\nplt.show()\n\nSee Also\n\nYou can check \n\nthis function in the GitHub source code","type":"content","url":"/b03-mosaics-corregistration#visualize-the-filtered-gcps","position":31},{"hierarchy":{"lvl1":"Corregistration of UAV mosaics","lvl3":"Create and save the new collocated slave image","lvl2":"The gcp_tools in GitHub airborne_tools package"},"type":"lvl3","url":"/b03-mosaics-corregistration#create-and-save-the-new-collocated-slave-image","position":32},{"hierarchy":{"lvl1":"Corregistration of UAV mosaics","lvl3":"Create and save the new collocated slave image","lvl2":"The gcp_tools in GitHub airborne_tools package"},"content":"After running the cell below a new image will be saved in the /input/UAV folder, with suffix _collocated.tif. You can visualize the results on QGIS. In addition, in the /input/UAV/GCS you will have access to an ASCII table that summarizes the automatic GCPs found, and a line shapefile that represents the traslation vector from the original slave GCP coordinate to its corresponding coordinate in the reference.\n\nfrom airborne_tools import gcp_tools as gcp\n# Set transformation method\n# 0 for thin plate spline transformation, \n# 1 for 1st degree polynomial\n# 2 for 2nd degree polynomial\n# ...\ntransform = 0  \n\n# Set the extent for the output image equal as the master image\nxmin, ymax = img.get_map_coordinates(0, 0, master_geo)\nxmax, ymin = img.get_map_coordinates(master_scaled.shape[1], master_scaled.shape[0], master_geo)\noutput_extent = (xmin, ymin, xmax, ymax)\n\ncollocated_image = test_dir / 'tir_odm_20220916_collocated.tif'\n\n# Get the origial GCP map coordinates\nslave_xcoord, slave_yCoord = img.get_map_coordinates(np.asarray(gcp_valid)[:, 2],\n                                                     np.asarray(gcp_valid)[:, 3],\n                                                     slave_geo)\n\n# Create an anciillary GCP subfolder to store the final GPCs\nif not (test_dir / \"GCPs\").is_dir():\n    (test_dir / \"GCPs\").mkdir(parents=True)\n\n# Save the transformation line vector betwen the original coordinates and the collocated coordiantes\noutshapefile = test_dir / 'GCPs' / f\"{collocated_image.name[:-4]}_Transform.shp\"\ngcp._write_transformation_vector((slave_xcoord, slave_yCoord),\n                                 (np.asarray(gcp_valid)[:, 0], np.asarray(gcp_valid)[:, 1]),\n                                 outshapefile,\n                                 proj)\n\n# Write the GCP to ascii file\nouttxtfile = test_dir / 'GCPs' / f\"{collocated_image.name[:-4]}_GCPs.txt\"\ngcp.gcps_to_ascii(gcp_valid, outtxtfile)\n\n# Finally use a airbone_tools helper function to perform the reprojection with the GCPs\ngcp.warp_image_with_gcps(lst_file,\n                         gcp_valid,\n                         collocated_image,\n                         output_extent=None,\n                         src_no_data=lst_no_data,\n                         transform=transform,\n                         data_type=gdal.GDT_UInt16)\n\nprint(f\"Saved collocated image in f{collocated_image}\")\n\nSee Also\n\nYou can check the full code in the \n\nairborne_tools GitHub source code repository\n\nHint\n\nHave a look in QGIS at the collocated TIR image comapred to the uncorrected TIR and Sequoia Multispectral image to visualize the colocation change.\n\n","type":"content","url":"/b03-mosaics-corregistration#create-and-save-the-new-collocated-slave-image","position":33},{"hierarchy":{"lvl1":"Corregistration of UAV mosaics","lvl2":"Conclusions"},"type":"lvl2","url":"/b03-mosaics-corregistration#conclusions","position":34},{"hierarchy":{"lvl1":"Corregistration of UAV mosaics","lvl2":"Conclusions"},"content":"We introduced an automatic method to corregister two mosaics\n\nThis method does not require that both mosaics share the same resolution nor the same extension, as SIFT tries to find scale-invariant features in the images.\n\nAfter running SIFT+FLANN we run serveral filter criteria in order to use only the best GCPs.\n\n[...]\n\nNote\n\nPlease feel free to comment any thoughts. This is work in progress!!!","type":"content","url":"/b03-mosaics-corregistration#conclusions","position":35},{"hierarchy":{"lvl1":"Retrieval of leaf stomatal conductance with TSEB"},"type":"lvl1","url":"/b04-stomata-conductance","position":0},{"hierarchy":{"lvl1":"Retrieval of leaf stomatal conductance with TSEB"},"content":"","type":"content","url":"/b04-stomata-conductance","position":1},{"hierarchy":{"lvl1":"Retrieval of leaf stomatal conductance with TSEB","lvl2":"Summary"},"type":"lvl2","url":"/b04-stomata-conductance#summary","position":2},{"hierarchy":{"lvl1":"Retrieval of leaf stomatal conductance with TSEB","lvl2":"Summary"},"content":"This interactive Jupyter Notebook has the objective of showing how to derive leaf stomata conductance via TSEB outputs. It is based on \n\nNieto et al. (2022) and ongoing work.\n\n","type":"content","url":"/b04-stomata-conductance#summary","position":3},{"hierarchy":{"lvl1":"Retrieval of leaf stomatal conductance with TSEB","lvl2":"Instructions"},"type":"lvl2","url":"/b04-stomata-conductance#instructions","position":4},{"hierarchy":{"lvl1":"Retrieval of leaf stomatal conductance with TSEB","lvl2":"Instructions"},"content":"Read carefully all the text and follow the instructions.\n\nOnce each section is read, run the jupyter code cell underneath (marked as In []) by clicking the icon Run, or pressing the keys SHIFT+ENTER of your keyboard. A graphical interface will then display, which allows you to interact with and perform the assigned tasks.\n\nTo start, please run the following cell to import all the packages required for this notebook. Once you run the cell below, an acknowledgement message, stating all libraries were correctly imported, should be printed on screen.\n\n%matplotlib inline\nfrom pathlib import Path\nfrom ipywidgets import interact, interactive, fixed, widgets\nfrom IPython.display import display\nimport numpy as np\n\n","type":"content","url":"/b04-stomata-conductance#instructions","position":5},{"hierarchy":{"lvl1":"Retrieval of leaf stomatal conductance with TSEB","lvl2":"TSEB and the Shuttleworth-Wallace model"},"type":"lvl2","url":"/b04-stomata-conductance#tseb-and-the-shuttleworth-wallace-model","position":6},{"hierarchy":{"lvl1":"Retrieval of leaf stomatal conductance with TSEB","lvl2":"TSEB and the Shuttleworth-Wallace model"},"content":"If we revisit again the two-source Shuttleworth-Wallace energy combination model \n\nShuttleworth & Wallace, 1985 we can see that TSEB indded is retrieving the “sensible heat flux side” of the graph:\n\n\n\nTwo-Source energy balance scheme including the transport of both heat (H) and water vapour (\\lambda E). Adapted from \n\nShuttleworth & Wallace (1985).\n\nFrom \n\nShuttleworth-Wallace model, the canopy latent heat flux (\\lambda E_C) can be express as:\\lambda E_C &= \\frac{\\rho_a c_p}{\\gamma}\\frac{e_{*}-e_0}{R_x + R_c}\\\\\n\nTherefore with the TSEB estimates of canopy latent heat fluxes and aerodynamic resistances, the effective conductance to water vapour diffusion exerted by all leaves in the canopy (R_{c}, s m^{-1}) can then be estimated by the resistance network of \n\nShuttleworth-Wallace model:R_c &= \\frac{\\rho_a c_p\\left(e_{*}-e_0\\right)}{\\lambda{}E_C\\,\\gamma}-R_x\n\nwhere R_{c} represents the resistance to water diffusion through both the cuticle and stomata in the canopy (m s^{-1}), e_* is the water vapour pressure in the leaf (kPa), which is assumed saturated at the leaf temperature T_C (K) \n\nFarquhar & Sharkey, 1982, R_{x} is the resistance to momentum and heat transport at the boundary layer of the canopy interface (m s^{-1}), and e_{0} is the vapour pressure of the air at the canopy interface (kPa), which is related to the air water vapour pressure measured at the reference height e_{a} through {}(#e_ac) (after \n\nShuttleworth-Wallace model):     e_{0}  = e_{a}+\\frac{\\lambda E\\,\\gamma\\,R_{a}}{\\rho_a c_p}\n\nThe conductance of the cuticle can be neglected with respect to the conductance of the stoma \n\nDuursma et al., 2018. Therefore the stomatal conductance to H_2O of an effective leaf (g_{st}) can finally be computed by inverting \n\n(6)R_c = \\frac{1}{g_{st} f_s f_g LAI}\n\nEq. \n\n(2) shows that stomatal conductance depends on canopy transpiration (\\lambda E_C) and the canopy boundary layer resistances (R_x). Furthermore, \\lambda E_C depends at the same time on both soil R_{s} and canopy R_x resistances, since we assume an interaction of tubulent fluxes between canopy, soil and the atmosphere.\n\n","type":"content","url":"/b04-stomata-conductance#tseb-and-the-shuttleworth-wallace-model","position":7},{"hierarchy":{"lvl1":"Retrieval of leaf stomatal conductance with TSEB","lvl2":"Implementation with actual data in pyTSEB"},"type":"lvl2","url":"/b04-stomata-conductance#implementation-with-actual-data-in-pytseb","position":8},{"hierarchy":{"lvl1":"Retrieval of leaf stomatal conductance with TSEB","lvl2":"Implementation with actual data in pyTSEB"},"content":"As with the previous exercices, we will work with any of the sites of GRAPEX, using the micrometeorological measurements and Earth Observation LAI.\n\nTable 1:Description of GRAPEX sites\n\nSite\n\nLatitude\n\nLongitude\n\nElevation (m)\n\nRow direction (deg.)\n\nRow spacing (m)\n\nMin. height (m)\n\nMax. height (m)\n\nMin. width (m)\n\nMax. width (m)\n\nTA height (m)\n\nWS height (m)\n\nRipperdan 720-1\n\n36.849\n\n-120.176\n\n61\n\n90\n\n3.35\n\n1.2\n\n2.2\n\n0.5\n\n2.25\n\n4\n\n4\n\nRipperdan 720-2\n\n36.849\n\n-120.174\n\n61\n\n90\n\n3.35\n\n1.2\n\n2.2\n\n0.5\n\n2.25\n\n4\n\n4\n\nRipperdan 720-3\n\n36.848\n\n-120.176\n\n61\n\n90\n\n3.35\n\n1.2\n\n2.2\n\n0.5\n\n2.25\n\n4\n\n4\n\nRipperdan 720-4\n\n36.848\n\n-120.174\n\n61\n\n90\n\n3.35\n\n1.2\n\n2.2\n\n0.5\n\n2.25\n\n4\n\n4\n\nBarrelli_007\n\n38.753\n\n-122.98\n\n113\n\n135\n\n3.35\n\n1.25\n\n2.3\n\n0.5\n\n1.8\n\n4\n\n4\n\nBarrelli_012\n\n38.751369\n\n-122.974658\n\n112\n\n45\n\n3.35\n\n1.25\n\n2.3\n\n0.5\n\n1.8\n\n4.4\n\n4.4\n\nSierra Loma-north\n\n38.289338\n\n-121.117764\n\n38\n\n90\n\n3.35\n\n1.42\n\n2.25\n\n0.5\n\n2.6\n\n5\n\n5\n\nSierra Loma-south\n\n38.280488\n\n-121.117597\n\n37\n\n90\n\n3.35\n\n1-42\n\n2.25\n\n0.5\n\n2\n\n5\n\n5\n\nRipperdan 760\n\n36.839025\n\n-120.21014\n\n58\n\n90\n\n2.74\n\n1.2\n\n2.5\n\n0.5\n\n1.8\n\n5.5\n\n5\n\nBarrelli_016\n\n38.747\n\n-122.963\n\n112\n\n135\n\n3.35\n\n1.25\n\n2.3\n\n0.5\n\n1.8\n\n4\n\n4","type":"content","url":"/b04-stomata-conductance#implementation-with-actual-data-in-pytseb","position":9},{"hierarchy":{"lvl1":"Retrieval of leaf stomatal conductance with TSEB","lvl3":"Select a site","lvl2":"Implementation with actual data in pyTSEB"},"type":"lvl3","url":"/b04-stomata-conductance#select-a-site","position":10},{"hierarchy":{"lvl1":"Retrieval of leaf stomatal conductance with TSEB","lvl3":"Select a site","lvl2":"Implementation with actual data in pyTSEB"},"content":"\n\nw_site = widgets.Dropdown(\n    options=[('Sierra Loma N', \"slmN\"), ('Sierra Loma S', \"slmS\"), \n             ('Barrelli 007', \"bar007\"), ('Barrelli 012', \"bar012\"),\n             ('Ripperdan 760', \"rip760\"), \n             ('Ripperdan 720-1', \"rip720_1\"),  ('Ripperdan 720-2', \"rip720_2\"),  \n             ('Ripperdan 720-3', \"rip720_3\"),  ('Ripperdan 720-4', \"rip720_4\")],\n    value=\"rip760\",\n    description='Site:',\n)\ndisplay(w_site)\n\n","type":"content","url":"/b04-stomata-conductance#select-a-site","position":11},{"hierarchy":{"lvl1":"Retrieval of leaf stomatal conductance with TSEB","lvl3":"Run TSEB-PT","lvl2":"Implementation with actual data in pyTSEB"},"type":"lvl3","url":"/b04-stomata-conductance#run-tseb-pt","position":12},{"hierarchy":{"lvl1":"Retrieval of leaf stomatal conductance with TSEB","lvl3":"Run TSEB-PT","lvl2":"Implementation with actual data in pyTSEB"},"content":"To speed up the process and also show how to put the low-level code of pyTSEB in a single script, in this final exercise we are putting all the code together:\n\n################################################################################\n# Empirical equations to generate canopy structural parameters from LAI\n################################################################################\nimport numpy as np\n\n\ndef lai_2_hc(lai, hc_min):\n    slope = 0.42\n    hc = hc_min + slope * lai\n    return hc\n\n\ndef lai_2_hbratio(lai, hc_min):\n    hb_ratio_mean = 0.4848388065\n    hb_ratio = np.zeros(lai.shape)\n\n    hb_ratio[lai < hc_min] = 1. + ((hb_ratio_mean - 1.) / hc_min) * lai[\n        lai < hc_min]\n    hb_ratio[lai >= hc_min] = hb_ratio_mean\n\n    return hb_ratio\n\n\ndef lai_2_width(lai, wc_min, wc_max):\n    beta = 6.96560056\n    offset = 1.70825736\n\n    width = wc_min + (wc_max - wc_min) / (1.0 + np.exp(-beta * (lai - offset)))\n\n    return width\n\n\ndef lai_2_fcover(lai, fc_min, fc_max):\n    beta = 7.0\n    offset = 1.70\n\n    fcover = fc_min + (fc_max - fc_min) / (1.0 + np.exp(-beta * (lai - offset)))\n\n    return fcover\n\n\ndef lai_2_canopy(lai, hc_min, fc_min, fc_max):\n    hc = lai_2_hc(lai, hc_min)\n    hb_ratio = lai_2_hbratio(lai, hc_min)\n    fcover = lai_2_fcover(lai, fc_min, fc_max)\n\n    return hc, hb_ratio, fcover\n\n# Import Python libraries\nfrom pathlib import Path\nimport pandas as pd\nimport numpy as np\nimport yaml\nfrom pyTSEB import TSEB\n\n# We can get the leaf and soil spectral from the values above, or hard code the corresponding values\nrho_leaf_vis = 0.054\nrho_leaf_nir = 0.262\ntau_leaf_vis = 0.038\ntau_leaf_nir = 0.333\nrho_soil_vis = 0.07\nrho_soil_nir = 0.32\n\n# Grapevine leaf width\nleaf_width = 0.10\n\n# Roughness for bare soil\nz0_soil = 0.15\n\n# Kustas and Norman boundary layer resistance parameters\nroil_resistance_c_param = 0.0038\nroil_resistance_b_param = 0.012\nroil_resistance_cprime_param = 90.\n\n# Thermal spectra\ne_v = 0.99  # Leaf emissivity\ne_s = 0.94  # Soil emissivity\n\n# Priestley-Taylor coefficient for potential transpiration\nalpha_PT_0 = 1.26\n\n# Read the LAI and Micrometeorology data\n# ======================================\n# Set the LAI and readiation folders\ninput_dir = Path().absolute() / \"input\"\nlai_dir = input_dir / \"canopy\"\nec_dir = input_dir / \"meteo\"\n# Set the input files based on the chosen site\nlai_filename = lai_dir / f\"FLX_US-{w_site.value}_FLUXNET2015_AUXCANOPY_DD.csv\"\nec_filename = ec_dir / f\"FLX_US-{w_site.value}_FLUXNET2015_SUBSET_HR.csv\"\nprint(f\"LAI file path is {lai_filename}\")\nprint(f\"EC file path is {ec_filename}\")\n\n# Read the LAI and radiation tables\nlai = pd.read_csv(lai_filename, sep=\";\", na_values=-9999)\nec = pd.read_csv(ec_filename, sep=\";\", na_values=-9999)\n\n# Merge both tables by date\nec[\"TIMESTAMP\"] = pd.to_datetime(ec[\"TIMESTAMP\"], format=\"%Y%m%d%H%M\")\nlai[\"DATE\"] = pd.to_datetime(lai[\"TIMESTAMP\"], format=\"%Y%m%d\").dt.date\nlai = lai.drop(labels=[\"TIMESTAMP\"], axis=1)\nec[\"DATE\"] = ec[\"TIMESTAMP\"].dt.date\nec = ec.merge(lai, on=\"DATE\")\n\n# We discard all cases at night (SW_IN <=0)\nec = ec[ec[\"SW_IN\"] > 0]\n\n# Convert Celsius to Kelvin\nec[\"TA\"] = ec[\"TA\"] + 273.15\n# Convert kPa to hPa\nec[\"PA\"] = 10 * ec[\"PA\"]\n\n# Evaluate different energy balance closure corrections\nec[\"H_RES\"] = ec[\"NETRAD\"] - ec[\"G\"] - ec[\"LE\"]\nec['LE_RES'] = ec['NETRAD'] - ec['G'] - ec['H']\nec[\"LE_BR\"], ec[\"H_BR\"] = TSEB.met.bowen_ratio_closure(ec[\"NETRAD\"], ec[\"G\"],\n                                                       ec[\"H\"], ec[\"LE\"])\n# Mean of uncorrected, ressidual and Bowen Ratio\nec[\"H_ENS\"] = np.nanmean([ec[\"H_RES\"], ec[\"H_BR\"], ec['H']], axis=0)\nec[\"LE_ENS\"] = np.nanmean([ec[\"LE_RES\"], ec[\"LE_BR\"], ec['LE']], axis=0)\n\n\n# Get the canopy a priori structural properties\n# =============================================\nyaml_file = input_dir / \"site_description.yaml\"\nsite_dict = yaml.safe_load(yaml_file.read_text())\nlat = float(site_dict[\"lat\"][w_site.value])\nlon = float(site_dict[\"lon\"][w_site.value])\nelev = float(site_dict[\"elev\"][w_site.value])\nrow_direction = float(site_dict[\"row_direction\"][w_site.value])\ninterrow = float(site_dict[\"interrow\"][w_site.value])\nhc_min = float(site_dict[\"hc_min\"][w_site.value])\nhc_max = float(site_dict[\"hc_max\"][w_site.value])\nwc_min = float(site_dict[\"wc_min\"][w_site.value])\nwc_max = float(site_dict[\"wc_max\"][w_site.value])\nzh = float(site_dict[\"zh\"][w_site.value])\nzm = float(site_dict[\"zm\"][w_site.value])\n\nprint(f\"{w_site.label} has the following site characteristics:\\n\"\n      f\"\\t Latitude: {lat} deg. \\n\"\n      f\"\\t Longitude: {lon} deg. \\n\"\n      f\"\\t Elevation: {elev} m \\n\"\n      f\"\\t Row direction: {row_direction} deg. \\n\"\n      f\"\\t Row spacing: {interrow} m \\n\"\n      f\"\\t Min. canopy height: {hc_min} m \\n\"\n      f\"\\t Max. canopy height: {hc_max} m \\n\"\n      f\"\\t Min. canopy width: {wc_min} m \\n\"\n      f\"\\t Max. canopy width: {wc_max} m \\n\"\n      f\"\\t Air temperature measurement height: {zh} m \\n\"\n      f\"\\t Wind speed temperature measurement height: {zh} m\"\n)\n\n# Estimate the structural variables based on Earth Observation LAI timeseries\n# ===========================================================================\nfc_min = wc_min / interrow\nfc_max = wc_max / interrow\nh_c, hb_ratio, f_c = lai_2_canopy(ec[\"LAI\"].values,\n                                  hc_min,\n                                  fc_min,\n                                  fc_max)\n\n# Ensure that both canopy height and cover are within the limits\nh_c = np.clip(h_c, hc_min, hc_max)\nf_c = np.clip(f_c, 0, 1)\n\n# canopy width\nw_c = f_c * interrow\n# Canopy width to height ratio\nw_c_ratio = w_c / (h_c - hb_ratio * h_c)\n# Local LAI\nF = ec[\"LAI\"].values / f_c\n\n# The time zone is PST, which corresponds to -120 deg, time longitude\nstdlon = -120\n# Call calc_sun_angles based on site coordinates and timestamp\nsza, saa = TSEB.met.calc_sun_angles(\n    np.full_like(ec['LAI'].values, lat),\n    np.full_like(ec[\"LAI\"].values, lon),\n    np.full_like(ec[\"LAI\"].values, stdlon),\n    ec['TIMESTAMP'].dt.dayofyear.values,\n    ec['TIMESTAMP'].dt.hour.values + ec['TIMESTAMP'].dt.minute.values / 60.)\n\n# Compute the relative sun-row azimuth angle\npsi = row_direction - saa\n# Compute the clumping index for row crops\nomega = TSEB.CI.calc_omega_rows(ec[\"LAI\"], f_c, theta=sza,\n                                psi=psi, w_c=w_c_ratio)\n\n# And the effective LAI is the product of local LAI and the clumping index\nlai_eff = F * omega\n\n# Estimates the direct and diffuse solar radiation\ndifvis, difnir, fvis, fnir = TSEB.rad.calc_difuse_ratio(ec[\"SW_IN\"].values,\n                                                        sza,\n                                                        press=np.full_like(sza, 1013.15))\npar_dir = fvis * (1. - difvis) * ec[\"SW_IN\"].values\nnir_dir = fnir * (1. - difnir) * ec[\"SW_IN\"].values\npar_dif = fvis * difvis * ec[\"SW_IN\"].values\nnir_dif = fnir * difnir * ec[\"SW_IN\"].values\n\n# Compute the canopy and soil net radiation using Cambpell RTM\nsn_c, sn_s = TSEB.rad.calc_Sn_Campbell(ec[\"LAI\"].values,\n                                       sza,\n                                       par_dir + nir_dir,\n                                       par_dif + nir_dif,\n                                       fvis,\n                                       fnir,\n                                       np.full_like(sza, rho_leaf_vis),\n                                       np.full_like(sza, tau_leaf_vis),\n                                       np.full_like(sza, rho_leaf_nir),\n                                       np.full_like(sza, tau_leaf_nir),\n                                       np.full_like(sza, rho_soil_vis),\n                                       np.full_like(sza, rho_soil_nir),\n                                       x_LAD=1,\n                                       LAI_eff=lai_eff)\n\nsn_c[~np.isfinite(sn_c)] = 0\nsn_s[~np.isfinite(sn_s)] = 0\n\n# Estimate surface aerodynamic roughness\n# ======================================\nz_0m, d_0 = TSEB.res.calc_roughness(ec[\"LAI\"], h_c, w_c_ratio, np.full_like(ec[\"LAI\"], TSEB.res.BROADLEAVED_D), f_c=f_c)\n# Ensure realistic values\nd_0[d_0 < 0] = 0\nz_0m[np.isnan(z_0m)] = z0_soil\nz_0m[z_0m < z0_soil] = z0_soil\n\n# We derive the LST from the insitu pyrgeometers\n# Surface emissivity\ne_surf = f_c * e_v + (1. - f_c) * e_s\n\n# LST from longwave radiometers\nlst = ((ec['LW_OUT'].values - (1. - e_surf) * ec['LW_IN'].values) / (\n        TSEB.rad.SB * e_surf)) ** 0.25\n\n# And it is assuming that the radiometer is looking at nadir\nvza = np.zeros_like(lst)\n\n# Run TSEB-PT\n# ===========\nresistance_flag = [0, {\"KN_c\": np.full_like(lst, roil_resistance_c_param),\n                       \"KN_b\": np.full_like(lst, roil_resistance_b_param),\n                       \"KN_C_dash\": np.full_like(lst, roil_resistance_cprime_param)}]\n\n[flag_pt, ts_pt, tc_pt, t_ac_pt, ln_s_pt, ln_c_pt, le_c_pt, h_c_pt, le_s_pt, h_s_pt, g_pt,\n r_s_pt, r_x_pt, r_a_pt, u_friction_pt, lmo_pt, n_iterations_pt] = TSEB.TSEB_PT(                                                     \n     lst,\n     vza,\n     ec[\"TA\"].values,\n     ec[\"WS\"].values,\n     ec[\"EA\"].values,\n     ec[\"PA\"].values,\n     sn_c,\n     sn_s,\n     ec[\"LW_IN\"].values,\n     ec[\"LAI\"].values,\n     h_c,\n     e_v,\n     e_s,\n     z_0m,\n     d_0,\n     zm,\n     zh,\n     x_LAD=np.ones_like(lst),\n     f_c=f_c,\n     f_g=np.ones_like(lst),\n     w_C=w_c_ratio,\n     leaf_width=leaf_width,\n     z0_soil=z0_soil,\n     alpha_PT=alpha_PT_0,\n     resistance_form=resistance_flag,\n     calcG_params=[[1], 0.35])\n\n# ... and we compute the bulk fluxes\nle_pt = le_c_pt + le_s_pt\nh_pt = h_c_pt + h_s_pt\nnetrad_pt = sn_c + sn_s + ln_c_pt + ln_s_pt\n\nprint(\"Finished running TSEB-PT\")\n\n","type":"content","url":"/b04-stomata-conductance#run-tseb-pt","position":13},{"hierarchy":{"lvl1":"Retrieval of leaf stomatal conductance with TSEB","lvl3":"Invert the SW resistance network to obtain g_{st}","lvl2":"Implementation with actual data in pyTSEB"},"type":"lvl3","url":"/b04-stomata-conductance#invert-the-sw-resistance-network-to-obtain-g-st","position":14},{"hierarchy":{"lvl1":"Retrieval of leaf stomatal conductance with TSEB","lvl3":"Invert the SW resistance network to obtain g_{st}","lvl2":"Implementation with actual data in pyTSEB"},"content":"With the TSEB estimates of \\lambda E (le_pt), \\lambda E_C (le_c_pt), T_c (tc_pt), R_a (r_a_pt), R_x (r_x_pt), together with LAI and meteo forcing we derived the effective leaf stomata conductance to water vapour (g_{st})\n\n# Set leaf stomata distribution (1: hypostomatous, 2: amphistomatous)\nleaf_type = TSEB.res.HYPOSTOMATOUS\n# Set expected maximum conductance\nmax_gst = 0.53  # Can be derived from the Monteith 1995 retrievals seen in TSEB-SW notebook\n\ndef calc_stomatal_resistance_TSEB(\n        LE_C,\n        LE,\n        R_A,\n        R_x,\n        e_a,\n        T_A,\n        T_C,\n        F,\n        p=1013.0,\n        leaf_type=1,\n        f_g=1,\n        f_dry=1):\n    ''' TSEB Stomatal conductace\n\n    Estimates the effective Stomatal conductace by inverting the\n    resistance-based canopy latent heat flux from a Two source perspective\n\n    Parameters\n    ----------\n    LE_C : float\n        Canopy latent heat flux (W m-2).\n    LE : float\n        Surface (bulk) latent heat flux (W m-2).\n    R_A : float\n        Aerodynamic resistance to heat transport (s m-1).\n    R_x : float\n        Bulk aerodynamic resistance to heat transport at the canopy boundary layer (s m-1).\n    e_a : float\n        Water vapour pressure at the reference height (mb).\n    T_A : float\n        Air temperature at the reference height (K).\n    T_C : float\n        Canopy (leaf) temperature (K).\n    F : float\n        local Leaf Area Index.\n    p : float, optional\n        Atmospheric pressure (mb) use 1013.0 as default.\n    leaf_type : int, optional\n        type of leaf regarding stomata distribution.\n\n            1=HYPOSTOMATOUS stomata in the lower surface of the leaf (default).\n            2=AMPHISTOMATOUS, stomata in both surfaces of the leaf.\n    f_g : float, optional\n        Fraction of green leaves.\n    f_dry : float, optional\n        Fraction of dry (non-wet) leaves.\n\n    Returns\n    -------\n    G_s : float\n        effective leaf stomata conductance (m s-1).\n\n    References\n    ----------\n    .. [Anderson2000] M.C. Anderson, J.M. Norman, T.P. Meyers, G.R. Diak, An analytical\n        model for estimating canopy transpiration and carbon assimilation fluxes based on\n        canopy light-use efficiency, Agricultural and Forest Meteorology, Volume 101,\n        Issue 4, 12 April 2000, Pages 265-289, ISSN 0168-1923,\n        http://dx.doi.org/10.1016/S0168-1923(99)00170-7.'''\n\n    # Convert input scalars to numpy arrays\n    LE_C, LE, R_A, R_x, e_a, T_A, T_C, F, p, leaf_type, f_g, f_dry = map(\n        np.asarray, (LE_C, LE, R_A, R_x, e_a, T_A, T_C, F, p, leaf_type, f_g, f_dry))\n\n    # Invert the bulk SW to obtain eb (vapor pressure at the canopy interface)\n    rho = TSEB.met.calc_rho(p, e_a, T_A)\n    Cp = TSEB.met.calc_c_p(p, e_a)\n    Lambda = TSEB.met.calc_lambda(T_A)\n    psicr = TSEB.met.calc_psicr(Cp, p, Lambda)\n    e_ac = e_a + LE * R_A * psicr / (rho * Cp)\n    # Calculate the saturation vapour pressure in the leaf in mb\n    e_star = TSEB.met.calc_vapor_pressure(T_C)\n    # Ensure physical constrains in canopy-air vpd\n    e_ac = np.clip(e_ac, 0, e_star)\n    # Calculate the boundary layer canopy resisitance to water vapour (Anderson et al. 2000)\n    # Invert the SW LE_S equation to calculate the bulk stomatal resistance\n    R_c = np.asarray((rho * Cp * (e_star - e_ac) / (LE_C * psicr)) - R_x)\n    K_c = np.asarray(f_dry * f_g * leaf_type)\n    # Get the mean stomatal resistance (here LAI comes in as stomatal resistances\n    # are in parallel: 1/Rc=sum(1/R_st)=LAI/Rst\n    r_st = R_c * K_c * F\n    # Ensure positive stomatal resistance\n    r_st = np.maximum(r_st, 0)\n    return np.asarray(r_st)\n    \n    \nr_st = calc_stomatal_resistance_TSEB(le_c_pt, le_pt, r_a_pt, r_x_pt, ec[\"EA\"].values, ec[\"TA\"].values,\n                                     tc_pt, ec[\"LAI\"].values, p=ec[\"PA\"].values, leaf_type=leaf_type)\n\n# and the mean leaf conductance is the reciprocal of R_st (m s-1)\ng_st = np.full(r_st.shape, np.nan)\nvalid = np.logical_and(np.isfinite(r_st), r_st > 0)\ng_st[valid] = 1.0 / r_st[valid]\n# Convert from m s-1 to mol m-2 s-1\ng_st[valid] = g_st[valid] / TSEB.res.molm2s1_2_ms1(ec.loc[valid, \"TA\"], p=ec.loc[valid, \"PA\"])\ng_st[valid] = np.clip(g_st[valid], 0, max_gst)\n\nSee Also\n\nCheck in the pyTSEB GitHub repository: \n\ncalc​_stomatal​_resistance​_TSEB and \n\ncalc​_stomatal​_conductance​_TSEB for more details)\n\n","type":"content","url":"/b04-stomata-conductance#invert-the-sw-resistance-network-to-obtain-g-st","position":15},{"hierarchy":{"lvl1":"Retrieval of leaf stomatal conductance with TSEB","lvl4":"We plot time series of stomata conductance","lvl3":"Invert the SW resistance network to obtain g_{st}","lvl2":"Implementation with actual data in pyTSEB"},"type":"lvl4","url":"/b04-stomata-conductance#we-plot-time-series-of-stomata-conductance","position":16},{"hierarchy":{"lvl1":"Retrieval of leaf stomatal conductance with TSEB","lvl4":"We plot time series of stomata conductance","lvl3":"Invert the SW resistance network to obtain g_{st}","lvl2":"Implementation with actual data in pyTSEB"},"content":"The next cell will let you plot the full timeseries of g_{st} and LAI. You can zoom in to see more in details the daily trends of stomata conductance with a trend of skewness before noon, probably due to stomata closure in the afternoon caused by larger VPD?.\n\nfrom plotly.subplots import make_subplots\nimport plotly.graph_objects as go\nfig = make_subplots(specs=[[{\"secondary_y\": True}]])\n\nfig.add_trace(go.Scatter(x=ec[\"TIMESTAMP\"], y=ec[\"LAI\"], \n                         name=\"LAI\", \n                         mode=\"lines\", line={\"color\":\"green\"}),\n              secondary_y=True)\n\nfig.add_trace(go.Scatter(x=ec[\"TIMESTAMP\"], y=g_st, \n                         name=\"Stomata conductance\",\n                         mode=\"lines\",line={\"color\":\"black\"})\n             )\n\nfig.update_layout(title_text=f\"Timeseries of stomata conductance for {w_site.label}\",\n                 hovermode=\"x\")\nfig.update_yaxes(title_text=\"LAI\", secondary_y=True)\nfig.update_yaxes(title_text=\"g_st (mol m-2 s-1)\", secondary_y=False)\n\n","type":"content","url":"/b04-stomata-conductance#we-plot-time-series-of-stomata-conductance","position":17},{"hierarchy":{"lvl1":"Retrieval of leaf stomatal conductance with TSEB","lvl2":"Implementing the TSEB stomatal conductance into a photosyntheis model"},"type":"lvl2","url":"/b04-stomata-conductance#implementing-the-tseb-stomatal-conductance-into-a-photosyntheis-model","position":18},{"hierarchy":{"lvl1":"Retrieval of leaf stomatal conductance with TSEB","lvl2":"Implementing the TSEB stomatal conductance into a photosyntheis model"},"content":"Our TSEB-derived g_{gs} could be implemented in the t wo-source model of heat, water and carbon exchange between the canopy and the atmosphere by \n\nTUZET et al. (2003), which at the same time relies on the biochemical model of photosynthesis of \n\nFarquhar et al. (1980):A_c & = V_{c,max}\\frac{C_i - \\Gamma_*}{C_i + K_c\\left(1 + O_i/K_o\\right)}\\\\\nA_q & = \\frac{J}{4}\\frac{C_i - \\Gamma_*}{C_i + 2\\Gamma_*}\\\\\n\nA_c is the assimilation rate, limited by Rubisco activity, A_q the assimilation rate when photosynthetic electron transport limits RuP_2 regeneration, J is the electron transport rate for a given absorbed photon irradiance, Q\\theta J^2 - \\left(\\alpha Q + J_{max}\\right)J + \\alpha Q J_{max} = 0\n\nwhere \\theta=0.9 determines the shape of the non-rectangular hyperbola, J_{max} is the potential rate of whole-chain electron transport and \\alpha=0.2 is the quantum yield of whole-chain electron transport.\n\nThe approach requires the parametrization of the enzimatic activity (V_{c,max}, J_{max}, ...), which in this case we use standard values derived for bibliography for simplicity.\n\nfrom pyTSEB import physiology as lf\n# Convert leaf stomata conductance to H2O to CO2\nGV_GC_RATIO = 1.6\ng_st_co2 = g_st / GV_GC_RATIO\ngs = g_st_co2 * ec[\"LAI\"] * leaf_type\n\n# Get a rough estimate of soil respiration based on soil temperature\nf_soil_10_0 = 1.5\ne_0 = 308.56 \nt_ref = 283.15\nr_soil = f_soil_10_0 * np.exp(e_0 * (1. / (t_ref - 227.13) - 1. / (ts_pt - 227.13)))\n# Assume a constant atmospheric C02 concentration (one could also use the measured CO2 concentration at the EC system)\nca = np.full_like(gs, 412)\nassim, rd, ci, temp_lim = lf.gpp_canopy(gs,\n                                        r_x_pt,\n                                        r_a_pt,\n                                        tc_pt,\n                                        ec[\"TA\"].values,\n                                        ec[\"LAI\"].values,\n                                        par_dir / lf.MUEINSTEIN_2_WATT,  # from Wm-2 to micromol of photons/s\n                                        par_dif / lf.MUEINSTEIN_2_WATT,  # from Wm-2 to micromol of photons/s\n                                        sza,\n                                        lai_eff=lai_eff,\n                                        rho_leaf=np.full_like(gs, rho_leaf_vis),\n                                        tau_leaf=np.full_like(gs, tau_leaf_vis),\n                                        rho_soil=np.full_like(gs, rho_soil_vis),\n                                        press=ec[\"PA\"].values,\n                                        f_soil=r_soil,\n                                        ca=ca)\n\n# GPP is the net assimilation rate plus the leaf respiration\ngpp = assim + rd\nprint(\"Calculation of CO2 assimilation completed!\")\n\nSee Also\n\nYou can also check the \n\npyTSEB GitHub source code","type":"content","url":"/b04-stomata-conductance#implementing-the-tseb-stomatal-conductance-into-a-photosyntheis-model","position":19},{"hierarchy":{"lvl1":"Retrieval of leaf stomatal conductance with TSEB","lvl3":"Evaluate the output with the EC data","lvl2":"Implementing the TSEB stomatal conductance into a photosyntheis model"},"type":"lvl3","url":"/b04-stomata-conductance#evaluate-the-output-with-the-ec-data","position":20},{"hierarchy":{"lvl1":"Retrieval of leaf stomatal conductance with TSEB","lvl3":"Evaluate the output with the EC data","lvl2":"Implementing the TSEB stomatal conductance into a photosyntheis model"},"content":"We have processed some EC data using the \n\nONEFlux code in order to obtain in situ estimates of GPP and NEE that we could use to validate. These files are located at the \n\n folder, with a GPPFLX prefix.\n\nSince the \n\nONEFlux software used several methods for partitioning GPP \n\nPastorello et al., 2020, choose first the metric you want to use:\n\nw_gpp = widgets.Dropdown(\n    options=[('GPP_NT_VUT_REF'), \n             ('GPP_NT_VUT_50'), \n             ('GPP_DT_VUT_REF'), \n             ('GPP_DT_VUT_50')],\n    value=(\"GPP_NT_VUT_REF\"),\n    description='GPP FLUXNET2015 metric:',\n)\ndisplay(w_gpp)\n\nfrom model_evaluation import double_collocation as dc\n\ngpp_filename = ec_dir / f\"GPPFLX_US-{w_site.value}_FLUXNET2015_SUBSET_HR.csv\"\n\n# Read the ONEFLux table\ngpp_insitu = pd.read_csv(gpp_filename, sep=\",\", na_values=-9999)\ngpp_insitu[\"TIMESTAMP_START\"] = pd.to_datetime(gpp_insitu[\"TIMESTAMP_START\"], format=\"%Y%m%d%H%M\")\ngpp_insitu[\"TIMESTAMP_END\"] = pd.to_datetime(gpp_insitu[\"TIMESTAMP_END\"], format=\"%Y%m%d%H%M\")\ngpp_insitu[\"TIMESTAMP\"] = gpp_insitu[['TIMESTAMP_START', 'TIMESTAMP_END']].mean(axis=1)\ngpp_insitu = gpp_insitu[[\"TIMESTAMP\", w_gpp.value]] \n\n# Before merging add the estimated GPP to the pandas dataframe\nec[\"GPP_TSEB\"] = gpp\n# Merge both dataframes by date\nec_new = ec.merge(gpp_insitu, on=\"TIMESTAMP\")\n\ndaytime = ec_new[\"SW_IN\"] > 100\n\nfig = go.Figure()\nfig.add_trace(go.Scattergl(x=ec_new.loc[daytime, \"GPP_TSEB\"], y=ec_new.loc[daytime, w_gpp.value], mode=\"markers\", name=\"TSEB GPP\"))\nfig.add_trace(go.Scatter(x=[-10, 50], y=[-10, 50], mode=\"lines\", name=\"1:1 line\", line={\"color\": \"black\", \"dash\": \"dash\"}))\nfig.update_layout(title_text=f\"Observed vs. Estimated below net radiation at {w_site.label}\",\n                  yaxis_range=[-10, 50], xaxis_range=[-10, 50],\n                  xaxis_title=\"Estimated GPP (micromol m-2 s-1)\", yaxis_title=\"Observed GPP (micromol m-2 s-1)\")\n\nfrom tabulate import tabulate\nmean_bias, mae, rmse = dc.error_metrics(ec_new.loc[daytime, w_gpp.value].values, ec_new.loc[daytime, \"GPP_TSEB\"].values)\ncor, p_value, slope, intercept, d = dc.agreement_metrics(ec_new.loc[daytime, w_gpp.value].values, ec_new.loc[daytime, \"GPP_TSEB\"].values)\n\ntable = [[\"bias\", mean_bias],\n         [\"RMSE\", rmse],\n         [\"MAE\",mae],\n         [\"Pearson\", cor],\n         [\"Willmot's d\", d]]\n\nprint(tabulate(table, headers=[\"Metric\", \"TSEB GPP\"]))\n\n","type":"content","url":"/b04-stomata-conductance#evaluate-the-output-with-the-ec-data","position":21},{"hierarchy":{"lvl1":"Retrieval of leaf stomatal conductance with TSEB","lvl3":"Save the outputs to an ASCII table","lvl2":"Implementing the TSEB stomatal conductance into a photosyntheis model"},"type":"lvl3","url":"/b04-stomata-conductance#save-the-outputs-to-an-ascii-table","position":22},{"hierarchy":{"lvl1":"Retrieval of leaf stomatal conductance with TSEB","lvl3":"Save the outputs to an ASCII table","lvl2":"Implementing the TSEB stomatal conductance into a photosyntheis model"},"content":"\n\n# Define the output filename\nout_dir = Path().absolute() / \"output\"\noutfile = out_dir / f\"GPPFLX_US-{w_site.value}_FLUXNET2015_TSEB-PT-ROWS_HR.csv\"\n\n# Create the output folder in case it does not exist\nif not out_dir.exists():\n    out_dir.mkdir(parents=True)\n\n# Convert the outputs to a Python dictionary\noutdict = {\"TIMESTAMP\": ec[\"TIMESTAMP\"].dt.strftime(\"%Y%m%d%H%M\"),\n           \"FLAG_TSEBPT\": flag_pt, \"LE_TSEBPT\": le_pt, \"H_TSEBPT\": h_pt, \"NETRAD_TSEBPT\": netrad_pt, \"G_TSEBPT\": g_pt, \n           \"T_S_TSEBPT\": ts_pt, \"T_C_TSEBPT\": tc_pt, \"T_AC_TSEBPT\": t_ac_pt, \"LN_S_TSEBPT\": ln_s_pt, \"LN_C_TSEBPT\": ln_c_pt, \n           \"LE_C_TSEBPT\": le_c_pt, \"H_C_TSEBPT\": h_c_pt, \"LE_S_TSEBPT\": le_s_pt, \"H_S_TSEBPT\": h_s_pt, \"R_S_TSEBPT\": r_s_pt, \n           \"R_X_TSEBPT\": r_x_pt, \"R_A_TSEBPT\": r_a_pt, \"USTAR_TSEBPT\": u_friction_pt, \"L_MO_TSEBPT\":lmo_pt, \n           \"ITERATIONS_TSEBPT\": n_iterations_pt, \"G_ST_TSEBPT\": g_st, \"GPP_TSEBPT\": gpp, \"R_D_TSEBPT\": rd, \n           \"CI_TSEBPT\": ci, \"R_SOIL_TSEBPT\": r_soil}\n\n# Crete the output dataframe and save it to csv\npd.DataFrame(outdict).to_csv(outfile, sep=\";\", na_rep=-9999, index=False)\nprint(f\"Saved to {outfile}\")\n\n","type":"content","url":"/b04-stomata-conductance#save-the-outputs-to-an-ascii-table","position":23},{"hierarchy":{"lvl1":"Retrieval of leaf stomatal conductance with TSEB","lvl2":"Conclusions"},"type":"lvl2","url":"/b04-stomata-conductance#conclusions","position":24},{"hierarchy":{"lvl1":"Retrieval of leaf stomatal conductance with TSEB","lvl2":"Conclusions"},"content":"By inverting the water fluxes and aerodynamic resistances from TSEB it is possible to get an estimate of leaf stomata conductance\n\nThis value should be considered as an effective value, in which it aggregates all variability of g_{st} values occurring in the canopy, due to different exposures, positions whitin the canopy...\n\nWith this estimate, we could potentially link the energy and water fluxes to the CO2 fluxes via a Farquhar-based mechanistic model. We could hypothesize an improvement using this approach under water-stress conditions.\n\n[...]\n\nNote\n\nPlease feel free to comment any thoughts. This is work in progress!!!","type":"content","url":"/b04-stomata-conductance#conclusions","position":25},{"hierarchy":{"lvl1":"Workshop on 3SEB modelling framework"},"type":"lvl1","url":"/intro","position":0},{"hierarchy":{"lvl1":"Workshop on 3SEB modelling framework"},"content":"","type":"content","url":"/intro","position":1},{"hierarchy":{"lvl1":"Workshop on 3SEB modelling framework","lvl2":"Summary"},"type":"lvl2","url":"/intro#summary","position":2},{"hierarchy":{"lvl1":"Workshop on 3SEB modelling framework","lvl2":"Summary"},"content":"This repository contains the online material needed to run the digital notebooks (Jupyter Notebook) developed for the course.","type":"content","url":"/intro#summary","position":3},{"hierarchy":{"lvl1":"Workshop on 3SEB modelling framework","lvl2":"Installation"},"type":"lvl2","url":"/intro#installation","position":4},{"hierarchy":{"lvl1":"Workshop on 3SEB modelling framework","lvl2":"Installation"},"content":"Prerequisites - Install Python and QGIS\n\nYou should have these programs installed:\n\nPython and/or \n\nAnaconda.\n\nGit\n\nQGIS (not necessary but recommended to visualize outputs)\n\nWe need to install all the library requisites for this tutorial.\n\nFirst navigate in a terminal to the py3SEB-workshop folder:\n\nOpen the Anaconda Prompt Terminal\n\nin the terminal navigate where to the py3SEB-workshop folder:cd C:\\Users\\<user>\\Downloads\\py3SEB-workshop\n\nOpen a Terminal (e.g. by presing CTRL+ALT+T)\n\nin the terminal navigate where to the py3SEB-workshop folder:cd /home/<user>/downloads/py3SEB-workshop\n\nThen install the requirements either with pip or with conda/mamba (recommended):\n\npip install requirements.txt\n\nmamba env create -f environment\nconda activate py3seb-workshop","type":"content","url":"/intro#installation","position":5},{"hierarchy":{"lvl1":"Workshop on 3SEB modelling framework","lvl2":"Run the interactive book"},"type":"lvl2","url":"/intro#run-the-interactive-book","position":6},{"hierarchy":{"lvl1":"Workshop on 3SEB modelling framework","lvl2":"Run the interactive book"},"content":"Open the Anaconda Prompt Terminal\n\nin the terminal navigate where to the py3SEB-workshop folder:cd C:\\Users\\<user>\\Downloads\\py3SEB-workshop\n\nRun this commandrun_workshop.bat\n\nOpen a Terminal (e.g. by presing CTRL+ALT+T)\n\nin the terminal navigate where to the py3SEB-workshop folder:cd /home/<user>/downloads/py3SEB-workshop\n\nRun this commandbash run_workshop.sh\n\nOpen your web browser to \n\nhttp://localhost:3000\n.","type":"content","url":"/intro#run-the-interactive-book","position":7},{"hierarchy":{"lvl1":"Workshop on 3SEB modelling framework","lvl2":"Jupyter Book contents"},"type":"lvl2","url":"/intro#jupyter-book-contents","position":8},{"hierarchy":{"lvl1":"Workshop on 3SEB modelling framework","lvl2":"Jupyter Book contents"},"content":"","type":"content","url":"/intro#jupyter-book-contents","position":9},{"hierarchy":{"lvl1":"Workshop on 3SEB modelling framework","lvl2":"3SEB workshop"},"type":"lvl2","url":"/intro#id-3seb-workshop","position":10},{"hierarchy":{"lvl1":"Workshop on 3SEB modelling framework","lvl2":"3SEB workshop"},"content":"Three-day workshop where sessions will include a short lecture on the topic followed by interactive textbooks/exercises using Jupyter Lab","type":"content","url":"/intro#id-3seb-workshop","position":11},{"hierarchy":{"lvl1":"Workshop on 3SEB modelling framework","lvl3":"Day 1 (Introduction and proximal sensing)","lvl2":"3SEB workshop"},"type":"lvl3","url":"/intro#day-1-introduction-and-proximal-sensing","position":12},{"hierarchy":{"lvl1":"Workshop on 3SEB modelling framework","lvl3":"Day 1 (Introduction and proximal sensing)","lvl2":"3SEB workshop"},"content":"Physical principles (2 hours).\n\na. \n\nRadiation transfer\n\nb. \n\nTurbulent exchange of heat and vapour\n\nIntroduction to TSEB and 3SEB (2 hours)\n\na. \n\nHow TSEB works?: a quick overview of low-level code\n\nb. \n\nHow 3SEB works?: a quick overview of low-level code","type":"content","url":"/intro#day-1-introduction-and-proximal-sensing","position":13},{"hierarchy":{"lvl1":"Workshop on 3SEB modelling framework","lvl3":"Day 2 (UAV high resolution imagery)","lvl2":"3SEB workshop"},"type":"lvl3","url":"/intro#day-2-uav-high-resolution-imagery","position":14},{"hierarchy":{"lvl1":"Workshop on 3SEB modelling framework","lvl3":"Day 2 (UAV high resolution imagery)","lvl2":"3SEB workshop"},"content":"Running pyTSEB and py3SEB with UAV imagery (4 hours)\n\na. \n\nRetrieving canopy and soil temperatures with UAV\n\nb. \n\nRunning TSEB-2T\n\nc. \n\nRunning 3SEB with high resolution imagery","type":"content","url":"/intro#day-2-uav-high-resolution-imagery","position":15},{"hierarchy":{"lvl1":"Workshop on 3SEB modelling framework","lvl3":"Day 3 (Satellite imagery)","lvl2":"3SEB workshop"},"type":"lvl3","url":"/intro#day-3-satellite-imagery","position":16},{"hierarchy":{"lvl1":"Workshop on 3SEB modelling framework","lvl3":"Day 3 (Satellite imagery)","lvl2":"3SEB workshop"},"content":"Satellite-based implementation (4 hours)\n\na. \n\nCopernicus TSEB and TSEB\n\nb. \n\nRetrieval of biophysical traits with RTM","type":"content","url":"/intro#day-3-satellite-imagery","position":17},{"hierarchy":{"lvl1":"Workshop on 3SEB modelling framework","lvl3":"Bonus Material","lvl2":"3SEB workshop"},"type":"lvl3","url":"/intro#bonus-material","position":18},{"hierarchy":{"lvl1":"Workshop on 3SEB modelling framework","lvl3":"Bonus Material","lvl2":"3SEB workshop"},"content":"other tools, applications and developments\n\na. \n\nTSEB in row crops\n\nb. \n\nShuttleworth-Wallace TSEB\n\nc. \n\nAutomatic co-registration between mosaics\n\nd. \n\nDerivation of stomata conductance and link to CO_2 fluxes","type":"content","url":"/intro#bonus-material","position":19},{"hierarchy":{"lvl1":"Workshop on 3SEB modelling framework","lvl2":"License"},"type":"lvl2","url":"/intro#license","position":20},{"hierarchy":{"lvl1":"Workshop on 3SEB modelling framework","lvl2":"License"},"content":"Creative Commons Attribution-ShareAlike 4.0 International.\n\nThis work is licensed under Attribution-ShareAlike 4.0 International. To view a copy of this license, visit \n\nhttp://​creativecommons​.org​/licenses​/by​-sa​/4​.0/\n\nThis license requires that reusers give credit to the creator. It allows reusers to distribute, remix, adapt, and build upon the material in any medium or format, even for commercial purposes. If others remix, adapt, or build upon the material, they must license the modified material under identical terms.\n\nBY: Credit must be given to you, the creator.\n\nSA: Adaptations must be shared under the same terms.","type":"content","url":"/intro#license","position":21}]}